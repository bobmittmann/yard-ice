
c:/devel/yard-ice/src/sdk/libthinkos/test/alloc/debug/alloc_test.elf:     file format elf32-littlearm

SYMBOL TABLE:
40000000 l    d  .dcclog	00000000 .dcclog
400007a0 l    d  .dccdata	00000000 .dccdata
08000000 l    d  .init	00000000 .init
08000190 l    d  .text	00000000 .text
20000000 l    d  .data	00000000 .data
20000008 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 stm32f-usart_baudrate_set.c
08004bc4 l     O .text	00000019 __FUNCTION__.5716
400007a0 l     O .dccdata	00000046 _f.5713
400007e8 l     O .dccdata	00000011 _m.5714
400007fc l     O .dccdata	00000046 _f.5718
40000844 l     O .dccdata	0000001c _m.5719
40000000 l     O .dcclog	00000010 log_entry.5715
40000010 l     O .dcclog	00000010 log_entry.5720
00000000 l    df *ABS*	00000000 stm32f-otg_fs_dev.c
08000a44 l     F .text	00000058 __ep_tx_push.constprop.5
08004c18 l     O .text	0000001b __FUNCTION__.5986
08004c34 l     O .text	0000001b __FUNCTION__.6007
08004c50 l     O .text	00000017 __FUNCTION__.6045
08004c68 l     O .text	00000012 __FUNCTION__.6284
08004c7c l     O .text	0000000c __FUNCTION__.5938
08004c88 l     O .text	00000016 __FUNCTION__.6182
08004ca0 l     O .text	0000000d __FUNCTION__.5921
08004cb0 l     O .text	00000019 __FUNCTION__.6212
40000860 l     O .dccdata	0000003f _f.5983
400008a0 l     O .dccdata	00000022 _m.5984
400008c4 l     O .dccdata	0000003f _f.6012
40000904 l     O .dccdata	00000015 _m.6013
4000091c l     O .dccdata	0000003f _f.6042
4000095c l     O .dccdata	00000018 _m.6043
40000974 l     O .dccdata	0000003f _f.6341
400009b4 l     O .dccdata	00000015 _m.6342
400009cc l     O .dccdata	0000003f _f.5943
40000a0c l     O .dccdata	0000002f _m.5944
40000a3c l     O .dccdata	0000003f _f.6188
40000a7c l     O .dccdata	00000022 _m.6189
40000aa0 l     O .dccdata	0000003f _f.5918
40000ae0 l     O .dccdata	00000021 _m.5919
40000b04 l     O .dccdata	0000003f _f.6228
40000b44 l     O .dccdata	00000022 _m.6229
40000b68 l     O .dccdata	0000003f _f.6236
40000ba8 l     O .dccdata	00000028 _m.6237
40000020 l     O .dcclog	00000010 log_entry.5985
40000030 l     O .dcclog	00000010 log_entry.6014
40000040 l     O .dcclog	00000010 log_entry.5920
40000050 l     O .dcclog	00000010 log_entry.6044
40000060 l     O .dcclog	00000010 log_entry.5945
40000070 l     O .dcclog	00000010 log_entry.6343
40000080 l     O .dcclog	00000010 log_entry.6190
40000090 l     O .dcclog	00000010 log_entry.6230
400000a0 l     O .dcclog	00000010 log_entry.6238
00000000 l    df *ABS*	00000000 stm32f-otg_fs.c
08004d0c l     O .text	00000018 __FUNCTION__.5810
08004d24 l     O .text	00000017 __FUNCTION__.5838
08004d3c l     O .text	00000016 __FUNCTION__.5892
40000bd0 l     O .dccdata	0000003b _f.5807
40000c0c l     O .dccdata	0000002f _m.5808
40000c3c l     O .dccdata	0000003b _f.5840
40000c78 l     O .dccdata	00000012 _m.5841
40000c8c l     O .dccdata	0000003b _f.5844
40000cc8 l     O .dccdata	00000011 _m.5845
40000cdc l     O .dccdata	0000003b _f.5902
40000d18 l     O .dccdata	00000011 _m.5903
400000b0 l     O .dcclog	00000010 log_entry.5809
400000c0 l     O .dcclog	00000010 log_entry.5842
400000d0 l     O .dcclog	00000010 log_entry.5846
400000e0 l     O .dcclog	00000010 log_entry.5904
00000000 l    df *ABS*	00000000 thinkos_core.c
08004d5c l     O .text	00000014 __FUNCTION__.4881
08004d70 l     O .text	0000000d __FUNCTION__.4903
40000d2c l     O .dccdata	00000034 _f.4878
40000d60 l     O .dccdata	0000000d _m.4879
40000d70 l     O .dccdata	00000034 _f.4900
40000da4 l     O .dccdata	00000017 _m.4901
40000dbc l     O .dccdata	00000034 _f.4940
40000df0 l     O .dccdata	0000001a _m.4941
40000e0c l     O .dccdata	00000034 _f.4944
40000e40 l     O .dccdata	00000015 _m.4945
40000e58 l     O .dccdata	00000034 _f.4948
40000e8c l     O .dccdata	00000021 _m.4949
400000f0 l     O .dcclog	00000010 log_entry.4880
40000100 l     O .dcclog	00000010 log_entry.4902
40000110 l     O .dcclog	00000010 log_entry.4942
40000120 l     O .dcclog	00000010 log_entry.4946
40000130 l     O .dcclog	00000010 log_entry.4950
00000000 l    df *ABS*	00000000 thinkos_svc.c
08004d84 l     O .text	0000000c __FUNCTION__.5285
40000eb0 l     O .dccdata	00000033 _f.5334
40000ee4 l     O .dccdata	00000018 _m.5335
40000140 l     O .dcclog	00000010 log_entry.5336
00000000 l    df *ABS*	00000000 thinkos_irq.c
08004d90 l     O .text	00000015 __FUNCTION__.5342
40000efc l     O .dccdata	00000033 _f.5339
40000f30 l     O .dccdata	00000010 _m.5340
40000150 l     O .dcclog	00000010 log_entry.5341
00000000 l    df *ABS*	00000000 thinkos_flag.c
08004da8 l     O .text	00000017 __FUNCTION__.5337
08004dc0 l     O .text	00000016 __FUNCTION__.5347
08004dd8 l     O .text	00000016 __FUNCTION__.5358
08004df0 l     O .text	0000001b __FUNCTION__.5378
08004e0c l     O .text	00000019 __FUNCTION__.5398
08004e28 l     O .text	00000016 __FUNCTION__.5417
08004e40 l     O .text	0000001b __FUNCTION__.5437
08004e5c l     O .text	00000016 __FUNCTION__.5456
08004e74 l     O .text	00000015 __FUNCTION__.5474
08004e8c l     O .text	00000015 __FUNCTION__.5489
40000f40 l     O .dccdata	00000034 _f.5334
40000f74 l     O .dccdata	00000006 _m.5335
40000f7c l     O .dccdata	00000034 _f.5344
40000fb0 l     O .dccdata	0000001a _m.5345
40000fcc l     O .dccdata	00000034 _f.5355
40001000 l     O .dccdata	00000019 _m.5356
4000101c l     O .dccdata	00000034 _f.5360
40001050 l     O .dccdata	00000011 _m.5361
40001064 l     O .dccdata	00000034 _f.5375
40001098 l     O .dccdata	00000019 _m.5376
400010b4 l     O .dccdata	00000034 _f.5380
400010e8 l     O .dccdata	00000011 _m.5381
400010fc l     O .dccdata	00000034 _f.5395
40001130 l     O .dccdata	00000019 _m.5396
4000114c l     O .dccdata	00000034 _f.5400
40001180 l     O .dccdata	00000011 _m.5401
40001194 l     O .dccdata	00000034 _f.5414
400011c8 l     O .dccdata	00000019 _m.5415
400011e4 l     O .dccdata	00000034 _f.5419
40001218 l     O .dccdata	00000011 _m.5420
4000122c l     O .dccdata	00000034 _f.5434
40001260 l     O .dccdata	00000019 _m.5435
4000127c l     O .dccdata	00000034 _f.5439
400012b0 l     O .dccdata	00000011 _m.5440
400012c4 l     O .dccdata	00000034 _f.5453
400012f8 l     O .dccdata	00000019 _m.5454
40001314 l     O .dccdata	00000034 _f.5458
40001348 l     O .dccdata	00000011 _m.5459
4000135c l     O .dccdata	00000034 _f.5471
40001390 l     O .dccdata	00000019 _m.5472
400013ac l     O .dccdata	00000034 _f.5476
400013e0 l     O .dccdata	00000011 _m.5477
400013f4 l     O .dccdata	00000034 _f.5486
40001428 l     O .dccdata	00000019 _m.5487
40001444 l     O .dccdata	00000034 _f.5491
40001478 l     O .dccdata	00000011 _m.5492
40000160 l     O .dcclog	00000010 log_entry.5336
40000170 l     O .dcclog	00000010 log_entry.5346
40000180 l     O .dcclog	00000010 log_entry.5357
40000190 l     O .dcclog	00000010 log_entry.5362
400001a0 l     O .dcclog	00000010 log_entry.5377
400001b0 l     O .dcclog	00000010 log_entry.5382
400001c0 l     O .dcclog	00000010 log_entry.5397
400001d0 l     O .dcclog	00000010 log_entry.5402
400001e0 l     O .dcclog	00000010 log_entry.5416
400001f0 l     O .dcclog	00000010 log_entry.5421
40000200 l     O .dcclog	00000010 log_entry.5436
40000210 l     O .dcclog	00000010 log_entry.5441
40000220 l     O .dcclog	00000010 log_entry.5455
40000230 l     O .dcclog	00000010 log_entry.5460
40000240 l     O .dcclog	00000010 log_entry.5473
40000250 l     O .dcclog	00000010 log_entry.5478
40000260 l     O .dcclog	00000010 log_entry.5488
40000270 l     O .dcclog	00000010 log_entry.5493
00000000 l    df *ABS*	00000000 thinkos_except.c
08004ea8 l     O .text	0000000b __FUNCTION__.6050
08004eb4 l     O .text	0000000a __FUNCTION__.6112
08004ec0 l     O .text	0000000c __FUNCTION__.6144
4000148c l     O .dccdata	00000036 _f.6047
400014c4 l     O .dccdata	00000012 _m.6048
400014d8 l     O .dccdata	00000036 _f.6052
40001510 l     O .dccdata	00000025 _m.6053
40001538 l     O .dccdata	00000036 _f.6056
40001570 l     O .dccdata	00000025 _m.6057
40001598 l     O .dccdata	00000036 _f.6060
400015d0 l     O .dccdata	00000025 _m.6061
400015f8 l     O .dccdata	00000036 _f.6064
40001630 l     O .dccdata	00000025 _m.6065
40001658 l     O .dccdata	00000036 _f.6068
40001690 l     O .dccdata	00000025 _m.6069
400016b8 l     O .dccdata	00000036 _f.6072
400016f0 l     O .dccdata	0000000a _m.6073
400016fc l     O .dccdata	00000036 _f.6076
40001734 l     O .dccdata	0000000a _m.6077
40001740 l     O .dccdata	00000036 _f.6080
40001778 l     O .dccdata	0000000a _m.6081
40001784 l     O .dccdata	00000036 _f.6086
400017bc l     O .dccdata	0000000a _m.6087
400017c8 l     O .dccdata	00000036 _f.6090
40001800 l     O .dccdata	00000013 _m.6091
40001814 l     O .dccdata	00000036 _f.6094
4000184c l     O .dccdata	0000000a _m.6095
40001858 l     O .dccdata	00000036 _f.6098
40001890 l     O .dccdata	00000011 _m.6099
400018a4 l     O .dccdata	00000036 _f.6109
400018dc l     O .dccdata	0000000b _m.6110
400018e8 l     O .dccdata	00000036 _f.6114
40001920 l     O .dccdata	00000025 _m.6115
40001948 l     O .dccdata	00000036 _f.6118
40001980 l     O .dccdata	00000025 _m.6119
400019a8 l     O .dccdata	00000036 _f.6122
400019e0 l     O .dccdata	00000025 _m.6123
40001a08 l     O .dccdata	00000036 _f.6126
40001a40 l     O .dccdata	00000025 _m.6127
40001a68 l     O .dccdata	00000036 _f.6130
40001aa0 l     O .dccdata	00000025 _m.6131
40001ac8 l     O .dccdata	00000036 _f.6141
40001b00 l     O .dccdata	0000000d _m.6142
40001b10 l     O .dccdata	00000036 _f.6146
40001b48 l     O .dccdata	00000025 _m.6147
40001b70 l     O .dccdata	00000036 _f.6150
40001ba8 l     O .dccdata	00000025 _m.6151
40001bd0 l     O .dccdata	00000036 _f.6154
40001c08 l     O .dccdata	00000025 _m.6155
40001c30 l     O .dccdata	00000036 _f.6158
40001c68 l     O .dccdata	00000025 _m.6159
40001c90 l     O .dccdata	00000036 _f.6162
40001cc8 l     O .dccdata	00000025 _m.6163
40000280 l     O .dcclog	00000010 log_entry.6049
40000290 l     O .dcclog	00000010 log_entry.6054
400002a0 l     O .dcclog	00000010 log_entry.6058
400002b0 l     O .dcclog	00000010 log_entry.6062
400002c0 l     O .dcclog	00000010 log_entry.6066
400002d0 l     O .dcclog	00000010 log_entry.6070
400002e0 l     O .dcclog	00000010 log_entry.6074
400002f0 l     O .dcclog	00000010 log_entry.6078
40000300 l     O .dcclog	00000010 log_entry.6082
40000310 l     O .dcclog	00000010 log_entry.6088
40000320 l     O .dcclog	00000010 log_entry.6092
40000330 l     O .dcclog	00000010 log_entry.6096
40000340 l     O .dcclog	00000010 log_entry.6100
40000350 l     O .dcclog	00000010 log_entry.6111
40000360 l     O .dcclog	00000010 log_entry.6116
40000370 l     O .dcclog	00000010 log_entry.6120
40000380 l     O .dcclog	00000010 log_entry.6124
40000390 l     O .dcclog	00000010 log_entry.6128
400003a0 l     O .dcclog	00000010 log_entry.6132
400003b0 l     O .dcclog	00000010 log_entry.6143
400003c0 l     O .dcclog	00000010 log_entry.6148
400003d0 l     O .dcclog	00000010 log_entry.6152
400003e0 l     O .dcclog	00000010 log_entry.6156
400003f0 l     O .dcclog	00000010 log_entry.6160
40000400 l     O .dcclog	00000010 log_entry.6164
00000000 l    df *ABS*	00000000 thinkos.c
0800515c l     O .text	00000011 __FUNCTION__.5197
08005170 l     O .text	0000001a __FUNCTION__.5209
40001cf0 l     O .dccdata	0000002f _f.5194
40001d20 l     O .dccdata	00000018 _m.5195
40001d38 l     O .dccdata	0000002f _f.5223
40001d68 l     O .dccdata	00000019 _m.5224
40001d84 l     O .dccdata	0000002f _f.5231
40001db4 l     O .dccdata	00000008 _m.5232
40000410 l     O .dcclog	00000010 log_entry.5196
40000420 l     O .dcclog	00000010 log_entry.5225
40000430 l     O .dcclog	00000010 log_entry.5233
00000000 l    df *ABS*	00000000 thinkos_mutex.c
0800518c l     O .text	00000017 __FUNCTION__.5196
080051a4 l     O .text	00000017 __FUNCTION__.5207
080051bc l     O .text	0000001a __FUNCTION__.5234
080051d8 l     O .text	0000001c __FUNCTION__.5262
080051f4 l     O .text	00000019 __FUNCTION__.5286
40001dbc l     O .dccdata	00000035 _f.5193
40001df4 l     O .dccdata	0000001a _m.5194
40001e10 l     O .dccdata	00000035 _f.5204
40001e48 l     O .dccdata	00000012 _m.5205
40001e5c l     O .dccdata	00000035 _f.5209
40001e94 l     O .dccdata	00000012 _m.5210
40001ea8 l     O .dccdata	00000035 _f.5217
40001ee0 l     O .dccdata	00000022 _m.5218
40001f04 l     O .dccdata	00000035 _f.5231
40001f3c l     O .dccdata	00000012 _m.5232
40001f50 l     O .dccdata	00000035 _f.5236
40001f88 l     O .dccdata	00000012 _m.5237
40001f9c l     O .dccdata	00000035 _f.5259
40001fd4 l     O .dccdata	00000012 _m.5260
40001fe8 l     O .dccdata	00000035 _f.5264
40002020 l     O .dccdata	00000012 _m.5265
40002034 l     O .dccdata	00000035 _f.5283
4000206c l     O .dccdata	00000012 _m.5284
40002080 l     O .dccdata	00000035 _f.5288
400020b8 l     O .dccdata	00000012 _m.5289
400020cc l     O .dccdata	00000035 _f.5292
40002104 l     O .dccdata	00000021 _m.5293
40000440 l     O .dcclog	00000010 log_entry.5195
40000450 l     O .dcclog	00000010 log_entry.5206
40000460 l     O .dcclog	00000010 log_entry.5211
40000470 l     O .dcclog	00000010 log_entry.5219
40000480 l     O .dcclog	00000010 log_entry.5233
40000490 l     O .dcclog	00000010 log_entry.5238
400004a0 l     O .dcclog	00000010 log_entry.5261
400004b0 l     O .dcclog	00000010 log_entry.5266
400004c0 l     O .dcclog	00000010 log_entry.5285
400004d0 l     O .dcclog	00000010 log_entry.5290
400004e0 l     O .dcclog	00000010 log_entry.5294
00000000 l    df *ABS*	00000000 thinkos_cond.c
08005210 l     O .text	00000016 __FUNCTION__.5196
08005228 l     O .text	00000016 __FUNCTION__.5214
08005240 l     O .text	0000001b __FUNCTION__.5257
0800525c l     O .text	00000018 __FUNCTION__.5296
08005274 l     O .text	0000001b __FUNCTION__.5315
40002128 l     O .dccdata	00000034 _f.5193
4000215c l     O .dccdata	00000023 _m.5194
40002180 l     O .dccdata	00000034 _f.5211
400021b4 l     O .dccdata	00000021 _m.5212
400021d8 l     O .dccdata	00000034 _f.5216
4000220c l     O .dccdata	00000012 _m.5217
40002220 l     O .dccdata	00000034 _f.5220
40002254 l     O .dccdata	00000021 _m.5221
40002278 l     O .dccdata	00000034 _f.5224
400022ac l     O .dccdata	00000012 _m.5225
400022c0 l     O .dccdata	00000034 _f.5228
400022f4 l     O .dccdata	00000020 _m.5229
40002314 l     O .dccdata	00000034 _f.5254
40002348 l     O .dccdata	00000012 _m.5255
4000235c l     O .dccdata	00000034 _f.5259
40002390 l     O .dccdata	00000021 _m.5260
400023b4 l     O .dccdata	00000034 _f.5263
400023e8 l     O .dccdata	00000012 _m.5264
400023fc l     O .dccdata	00000034 _f.5267
40002430 l     O .dccdata	00000021 _m.5268
40002454 l     O .dccdata	00000034 _f.5271
40002488 l     O .dccdata	00000020 _m.5272
400024a8 l     O .dccdata	00000034 _f.5293
400024dc l     O .dccdata	00000021 _m.5294
40002500 l     O .dccdata	00000034 _f.5298
40002534 l     O .dccdata	00000021 _m.5299
40002558 l     O .dccdata	00000034 _f.5312
4000258c l     O .dccdata	00000021 _m.5313
400025b0 l     O .dccdata	00000034 _f.5317
400025e4 l     O .dccdata	00000021 _m.5318
400004f0 l     O .dcclog	00000010 log_entry.5195
40000500 l     O .dcclog	00000010 log_entry.5213
40000510 l     O .dcclog	00000010 log_entry.5218
40000520 l     O .dcclog	00000010 log_entry.5222
40000530 l     O .dcclog	00000010 log_entry.5226
40000540 l     O .dcclog	00000010 log_entry.5230
40000550 l     O .dcclog	00000010 log_entry.5256
40000560 l     O .dcclog	00000010 log_entry.5261
40000570 l     O .dcclog	00000010 log_entry.5265
40000580 l     O .dcclog	00000010 log_entry.5269
40000590 l     O .dcclog	00000010 log_entry.5273
400005a0 l     O .dcclog	00000010 log_entry.5295
400005b0 l     O .dcclog	00000010 log_entry.5300
400005c0 l     O .dcclog	00000010 log_entry.5314
400005d0 l     O .dcclog	00000010 log_entry.5319
00000000 l    df *ABS*	00000000 thinkos_semaphore.c
08005290 l     O .text	00000016 __FUNCTION__.5187
080052a8 l     O .text	00000015 __FUNCTION__.5197
080052c0 l     O .text	00000015 __FUNCTION__.5208
080052d8 l     O .text	00000015 __FUNCTION__.5227
080052f0 l     O .text	00000018 __FUNCTION__.5245
08005308 l     O .text	0000001a __FUNCTION__.5261
08005324 l     O .text	00000015 __FUNCTION__.5280
40002608 l     O .dccdata	00000039 _f.5184
40002644 l     O .dccdata	0000000d _m.5185
40002654 l     O .dccdata	00000039 _f.5194
40002690 l     O .dccdata	0000001e _m.5195
400026b0 l     O .dccdata	00000039 _f.5205
400026ec l     O .dccdata	0000001e _m.5206
4000270c l     O .dccdata	00000039 _f.5210
40002748 l     O .dccdata	00000016 _m.5211
40002760 l     O .dccdata	00000039 _f.5214
4000279c l     O .dccdata	0000000e _m.5215
400027ac l     O .dccdata	00000039 _f.5224
400027e8 l     O .dccdata	0000001e _m.5225
40002808 l     O .dccdata	00000039 _f.5229
40002844 l     O .dccdata	00000016 _m.5230
4000285c l     O .dccdata	00000039 _f.5242
40002898 l     O .dccdata	0000001e _m.5243
400028b8 l     O .dccdata	00000039 _f.5247
400028f4 l     O .dccdata	00000016 _m.5248
4000290c l     O .dccdata	00000039 _f.5258
40002948 l     O .dccdata	0000001e _m.5259
40002968 l     O .dccdata	00000039 _f.5263
400029a4 l     O .dccdata	00000016 _m.5264
400029bc l     O .dccdata	00000039 _f.5277
400029f8 l     O .dccdata	0000001e _m.5278
40002a18 l     O .dccdata	00000039 _f.5282
40002a54 l     O .dccdata	00000016 _m.5283
400005e0 l     O .dcclog	00000010 log_entry.5186
400005f0 l     O .dcclog	00000010 log_entry.5196
40000600 l     O .dcclog	00000010 log_entry.5207
40000610 l     O .dcclog	00000010 log_entry.5212
40000620 l     O .dcclog	00000010 log_entry.5216
40000630 l     O .dcclog	00000010 log_entry.5226
40000640 l     O .dcclog	00000010 log_entry.5231
40000650 l     O .dcclog	00000010 log_entry.5244
40000660 l     O .dcclog	00000010 log_entry.5249
40000670 l     O .dcclog	00000010 log_entry.5260
40000680 l     O .dcclog	00000010 log_entry.5265
40000690 l     O .dcclog	00000010 log_entry.5279
400006a0 l     O .dcclog	00000010 log_entry.5284
00000000 l    df *ABS*	00000000 thinkos_event.c
0800533c l     O .text	00000014 __FUNCTION__.5347
08005350 l     O .text	00000014 __FUNCTION__.5363
08005364 l     O .text	00000019 __FUNCTION__.5392
08005380 l     O .text	00000015 __FUNCTION__.5412
08005398 l     O .text	00000014 __FUNCTION__.5443
080053ac l     O .text	00000016 __FUNCTION__.5460
40002a6c l     O .dccdata	00000035 _f.5344
40002aa4 l     O .dccdata	0000001f _m.5345
40002ac4 l     O .dccdata	00000035 _f.5360
40002afc l     O .dccdata	0000001f _m.5361
40002b1c l     O .dccdata	00000035 _f.5365
40002b54 l     O .dccdata	00000016 _m.5366
40002b6c l     O .dccdata	00000035 _f.5389
40002ba4 l     O .dccdata	0000001f _m.5390
40002bc4 l     O .dccdata	00000035 _f.5394
40002bfc l     O .dccdata	00000016 _m.5395
40002c14 l     O .dccdata	00000035 _f.5409
40002c4c l     O .dccdata	00000015 _m.5410
40002c64 l     O .dccdata	00000035 _f.5414
40002c9c l     O .dccdata	0000001f _m.5415
40002cbc l     O .dccdata	00000035 _f.5418
40002cf4 l     O .dccdata	00000016 _m.5419
40002d0c l     O .dccdata	00000035 _f.5440
40002d44 l     O .dccdata	0000001f _m.5441
40002d64 l     O .dccdata	00000035 _f.5445
40002d9c l     O .dccdata	00000016 _m.5446
40002db4 l     O .dccdata	00000035 _f.5457
40002dec l     O .dccdata	0000001f _m.5458
40002e0c l     O .dccdata	00000035 _f.5462
40002e44 l     O .dccdata	00000016 _m.5463
40002e5c l     O .dccdata	00000035 _f.5466
40002e94 l     O .dccdata	0000001f _m.5467
40002eb4 l     O .dccdata	00000035 _f.5470
40002eec l     O .dccdata	0000001f _m.5471
400006b0 l     O .dcclog	00000010 log_entry.5346
400006c0 l     O .dcclog	00000010 log_entry.5362
400006d0 l     O .dcclog	00000010 log_entry.5367
400006e0 l     O .dcclog	00000010 log_entry.5391
400006f0 l     O .dcclog	00000010 log_entry.5396
40000700 l     O .dcclog	00000010 log_entry.5411
40000710 l     O .dcclog	00000010 log_entry.5416
40000720 l     O .dcclog	00000010 log_entry.5420
40000730 l     O .dcclog	00000010 log_entry.5442
40000740 l     O .dcclog	00000010 log_entry.5447
40000750 l     O .dcclog	00000010 log_entry.5459
40000760 l     O .dcclog	00000010 log_entry.5464
40000770 l     O .dcclog	00000010 log_entry.5468
40000780 l     O .dcclog	00000010 log_entry.5472
00000000 l    df *ABS*	00000000 ice-trace_init.c
08005508 l     O .text	0000000f __FUNCTION__.4549
40002f0c l     O .dccdata	00000037 __f.4546
40002f44 l     O .dccdata	00000015 _m.4547
40000790 l     O .dcclog	00000010 log_entry.4548
00000000 l    df *ABS*	00000000 stm32f-crt0.o
00000000 l    df *ABS*	00000000 alloc_test.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 stm32f-gpio.c
00000000 l    df *ABS*	00000000 stm32f-usart_init.c
00000000 l    df *ABS*	00000000 stm32f-usart_mode_set.c
00000000 l    df *ABS*	00000000 stm32f-usart_enable.c
00000000 l    df *ABS*	00000000 stm32f-usart_fops.c
00000000 l    df *ABS*	00000000 stm32f-init.c
00000000 l    df *ABS*	00000000 stm32f-usart.c
00000000 l    df *ABS*	00000000 stm32f-usart_power_off.c
00000000 l    df *ABS*	00000000 stm32f-usart_flush.c
00000000 l    df *ABS*	00000000 stm32f-usart_read.c
00000000 l    df *ABS*	00000000 stm32f-usart_canon_write.c
00000000 l    df *ABS*	00000000 stm32f-usart_getc.c
00000000 l    df *ABS*	00000000 stm32f-usart_putc.c
00000000 l    df *ABS*	00000000 cm3-udelay.c
08001988 l     F .text	00000010 cm3_get_ticks
00000000 l    df *ABS*	00000000 udelay.c
00000000 l    df *ABS*	00000000 thinkos_util.c
00000000 l    df *ABS*	00000000 thinkos_type.c
00000000 l    df *ABS*	00000000 thinkos_sleep.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 stdin.c
00000000 l    df *ABS*	00000000 stdout.c
00000000 l    df *ABS*	00000000 stderr.c
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 uint2dec.c
08005424 l     O .text	0000002c __div_tab
00000000 l    df *ABS*	00000000 ull2dec.c
08005450 l     O .text	000000a8 __div_tab
00000000 l    df *ABS*	00000000 uint2hex.c
00000000 l    df *ABS*	00000000 ull2hex.c
00000000 l    df *ABS*	00000000 ice-comm.c
00000000 l    df *ABS*	00000000 ice-trace0.c
00000000 l    df *ABS*	00000000 ice-trace1.c
00000000 l    df *ABS*	00000000 ice-trace2.c
00000000 l    df *ABS*	00000000 ice-trace3.c
00000000 l    df *ABS*	00000000 ice-trace4.c
00000000 l    df *ABS*	00000000 ice-trace6.c
00000000 l    df *ABS*	00000000 ice-trace7.c
00000000 l    df *ABS*	00000000 ice-comm_wr32.c
00000000 l    df *ABS*	00000000 
080013e4  w    F .text	0000000a stm32f_otg_fs_wkup_isr
08003e70 g     F .text	0000000e putchar
08000d78 g     F .text	00000038 otg_fs_power_off
08001aa0 g     F .text	0000003a cm3_pendsv_isr
08001dd0 g     F .text	00000062 thinkos_bmp_alloc
080013e4  w    F .text	0000000a stm32f_tim1_brk_isr
080020a0 g     F .text	00000048 cm3_default_isr
0800183c g     F .text	000000ba stm32f_otg_fs_device_init
080013e4  w    F .text	0000000a stm32f_tim1_cc_isr
0800153c g     F .text	00000090 stm32_usart_power_off
080013e4  w    F .text	0000000a stm32f_can1_rx1_isr
08004ce0 g     O .text	00000004 cm3_systick_load_1ms
0800197c g     F .text	0000000c stm32_usart_putc
080013e4  w    F .text	0000000a stm32f_dma1_stream6_isr
08003e48 g     F .text	00000026 printf
20000ecc g     O .bss	00000004 stdout
08002bdc g     F .text	0000000e thinkos_alloc_bmp_get
08000850 g     F .text	0000007e stm32_usart_mode_set
08002450 g     F .text	000000a4 thinkos_flag_take_svc
08002280 g     F .text	000000e4 thinkos_flag_timedwait_svc
08000b34 g     F .text	000001c4 stm32f_otg_dev_ep_init
080013e4  w    F .text	0000000a stm32f_tim8_trg_com_tim14_isr
080013e4  w    F .text	0000000a stm32f_dma2_stream2_isr
08002c90 g     F .text	00000054 thinkos_exit_svc
08004360 g     F .text	0000001e ice_comm_sync
080008d0 g     F .text	0000000e stm32_usart_enable
08004ce4 g     O .text	00000014 stm32_usart_lut
0800426c g     F .text	00000070 ull2dec
08001b80 g     F .text	00000068 thinkos_thread_exit
080013e4  w    F .text	0000000a stm32f_exti9_5_isr
080013e4  w    F .text	0000000a stm32f_tim1_brk_tim15_isr
08002a40 g     F .text	00000090 usage_fault
08004218 g     F .text	00000054 uint2dec
08001938 g     F .text	00000018 otg_fs_fifo
080013e4  w    F .text	0000000a stm32f_tim1_trg_com_tim11_isr
080053e4 g     O .text	00000040 __blanks
080013e4  w    F .text	0000000a stm32f_exti15_10_isr
080013e4  w    F .text	0000000a stm32f_usart1_exti25_isr
08001520 g     F .text	0000001c stm32_usart_lookup
08000db0 g     F .text	00000086 stm32f_otg_fs_dev_init
080045e4 g     F .text	000000e4 ice_trace6
080013e4  w    F .text	0000000a stm32f_usb_wkup_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream0_isr
08004cd0 g     O .text	00000004 stm32f_apb2_hz
20000088 g     O .bss	00000cb0 thinkos_rt
08000d2c g     F .text	00000016 otg_fs_disconnect
080037bc g     F .text	000000cc thinkos_sem_timedwait_svc
08004cd4 g     O .text	00000004 stm32f_tim1_hz
080043b0  w    F .text	00000016 dcclog_init
080013e4  w    F .text	0000000a stm32f_i2c2_ev_exti24_isr
080017a8 g     F .text	00000094 stm32f_otg_fs_txf_push
08000934 g     F .text	0000004c stm32f_otg_dev_ep_tx_start
080013e4  w    F .text	0000000a stm32f_usart6_isr
08003b4c g     F .text	000000e4 thinkos_ev_raise_svc
080013e4  w    F .text	0000000a stm32f_cec_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream1_isr
08003e80 g     F .text	00000036 puts
08004bf8 g     O .text	00000020 stm32f_otg_fs_ops
0800514c g     O .text	00000010 thinkos_main_inf
080029b0 g     F .text	00000090 bus_fault
080013e4  w    F .text	0000000a stm32f_i2c2_er_isr
0800364c g     F .text	00000068 thinkos_sem_init_svc
080013e4  w    F .text	0000000a stm32f_flash_isr
08004d58 g     O .text	00000004 thinkos_svc_link
080036b4 g     F .text	000000a0 thinkos_sem_wait_svc
08003c88 g     F .text	000001c0 thinkos_ev_unmask_svc
080013e4  w    F .text	0000000a stm32f_i2c3_ev_isr
08004d08 g     O .text	00000004 stm32f_otg_fs_ep0_mpsiz_lut
080016d4 g     F .text	00000040 stm32f_otg_fs_ep_out_start
08000728 g     F .text	0000003c stm32_gpio_af
080008e0 g     F .text	0000001c stm32f_otg_dev_ep_nak
080013e4  w    F .text	0000000a stm32f_tim1_trg_com_isr
080007e8 g     F .text	00000068 stm32_usart_baudrate_set
08004554 g     F .text	00000090 ice_trace4
080013e4  w    F .text	0000000a stm32f_exti4_isr
08002670 g     F .text	00000054 thinkos_flag_clr_svc
080034ec g     F .text	000000f4 thinkos_cond_broadcast_svc
2000000c g     O .bss	00000074 stm32f_otg_fs_drv0
080013e4  w    F .text	0000000a stm32f_uart4_isr
08002364 g     F .text	000000ec thinkos_flag_release_svc
08002bec g     F .text	00000054 thinkos_sleep_svc
08004d80 g     O .text	00000004 thinkos_svc_nm
08000924 g     F .text	0000000e stm32f_otg_dev_ep_disable
080013e4  w    F .text	0000000a stm32f_tim5_isr
08000764 g     F .text	00000084 stm32_usart_init
080013e4  w    F .text	0000000a stm32f_tim2_isr
20000f24 g       .bss	00000000 __bss_end
08002ad0 g     F .text	00000002 thinkos_default_exception_dsr
08003164 g     F .text	00000030 thinkos_cond_free_svc
080013e4  w    F .text	0000000a stm32f_rtc_wkup_isr
08001658 g     F .text	00000018 stm32f_otg_fs_txfifo_flush
080041f4 g     F .text	00000002 abort
080013e4  w    F .text	0000000a stm32f_exti0_isr
080015cc g     F .text	0000000c stm32_usart_flush
080042dc g     F .text	00000038 uint2hex
08002e48 g     F .text	00000030 thinkos_mutex_free_svc
08001460 g     F .text	000000c0 _init
080027c0 g     F .text	000001f0 hard_fault
08004bac g     O .text	00000018 stm32_gpio_lut
080053c4 g     O .text	00000020 __zeros
08004ccc g     O .text	00000004 stm32f_tim2_hz
080013e4  w    F .text	0000000a stm32f_tamp_stamp_isr
08004414 g     F .text	0000005c ice_trace1
08000a9c g     F .text	00000098 __ep_pktbuf_alloc
08001628 g     F .text	00000030 stm32f_otg_fs_core_reset
080013e4  w    F .text	0000000a stm32f_usart2_exti26_isr
080013e4  w    F .text	0000000a stm32f_tim1_up_isr
080024f4 g     F .text	000000c8 thinkos_flag_timedtake_svc
080013e4  w    F .text	0000000a stm32f_tim3_isr
080013e4  w    F .text	0000000a stm32f_usart2_isr
080005d8 g     F .text	000000a6 stdio_init
08004470  w    F .text	00000068 dcclog2
08000e38 g     F .text	000005a8 stm32f_otg_fs_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream4_isr
080013e4  w    F .text	0000000a stm32f_tim6_dac_isr
08003754 g     F .text	00000068 thinkos_sem_trywait_svc
08001998 g     F .text	00000036 cm3_udelay_calibrate
20000d38 g     O .bss	00000190 thinkos_idle
080013e4  w    F .text	0000000a stm32f_wwdg_isr
080054f8 g     O .text	00000010 __hextab
08004314 g     F .text	0000004c ull2hex
080047d0 g     F .text	00000040 ice_comm_w32
080013e4  w    F .text	0000000a stm32f_usart3_isr
0800219c g     F .text	00000030 thinkos_flag_free_svc
080013e4  w    F .text	0000000a stm32f_tim8_brk_tim12_isr
080046c8  w    F .text	00000108 dcclog7
080043b0 g     F .text	00000016 ice_trace_init
080006ac g     F .text	0000007a stm32_gpio_mode
080025bc g     F .text	000000b4 thinkos_flag_give_svc
080013e4  w    F .text	0000000a stm32f_dcmi_isr
08003c30 g     F .text	00000058 thinkos_ev_mask_svc
080013e0  w    F .text	00000004 cm3_mem_manage_isr
08002f98 g     F .text	000000d8 thinkos_mutex_timedlock_svc
20000000 g     O .data	00000008 stm32f_uart_file
08002e1c g     F .text	0000002c thinkos_mutex_alloc_svc
08002bc8 g     F .text	00000014 thinkos_obj_type_get
080046c8 g     F .text	00000108 ice_trace7
08002b94 g     F .text	00000034 thinkos_rt_snapshot_svc
20000ec8 g     O .bss	00000004 stdin
0800068c g     F .text	00000020 stm32_gpio_clock_en
080013f0 g     F .text	00000002 _void
08001670 g     F .text	00000010 stm32f_otg_fs_rxfifo_flush
20000080 g     O .bss	00000004 udelay_factor
08004bf0 g     O .text	00000008 stm32f_otg_fs_dev
08004d54 g     O .text	00000004 thinkos_execpt_link
080013e4  w    F .text	0000000a stm32f_usart3_exti28_isr
08000000 g     O .init	00000184 __rom_vectors
20000ed4 g     O .bss	00000050 ice_comm_blk
08002b14 g     F .text	0000003e cm3_usage_fault_isr
00000000 g       .debug_frame	00000000 __vectors
080043c8  w    F .text	0000004c dcclog0
08003444 g     F .text	000000a8 thinkos_cond_signal_svc
20000008 g       .data	00000000 __data_end
080013e4  w    F .text	0000000a stm32f_dma2_stream6_isr
080013e4  w    F .text	0000000a stm32f_i2c2_ev_isr
080019d0 g     F .text	00000020 udelay
080013e4  w    F .text	0000000a stm32f_tim8_up_tim13_isr
080013e4  w    F .text	0000000a stm32f_i2c3_er_isr
08000d14 g     F .text	00000016 otg_fs_connect
080013e4  w    F .text	0000000a stm32f_i2c1_ev_isr
080013e4  w    F .text	0000000a stm32f_dma2_stream3_isr
08004554  w    F .text	00000090 dcclog4
080013e4  w    F .text	0000000a stm32f_can2_tx_isr
080015d8 g     F .text	00000014 stm32_usart_read
08004f70 g     O .text	00000018 thinkos_wq_base_lut
080013e4  w    F .text	0000000a stm32f_can2_rx0_isr
080013e4  w    F .text	0000000a stm32f_tim1_brk_tim9_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream7_isr
080013e4  w    F .text	0000000a stm32f_spi1_isr
08004470 g     F .text	00000068 ice_trace2
080013e4  w    F .text	0000000a stm32f_rtc_alarm_isr
08005518 g       .text	00000000 __text_end
08005518 g       .text	00000000 __ctors_start
080013e4  w    F .text	0000000a stm32f_can1_sce_isr
08003a68 g     F .text	000000e4 thinkos_ev_timedwait_svc
08002f2c g     F .text	0000006c thinkos_mutex_trylock_svc
20000008 g     O .bss	00000001 __
080013e4  w    F .text	0000000a stm32f_exti1_isr
08000d44 g     F .text	00000034 otg_fs_power_on
080013e4  w    F .text	0000000a stm32f_otg_hs_isr
08000cf8 g     F .text	0000001a otg_fs_vbus_connect
20000008 g       .bss	00000000 __bss_start
080013e4  w    F .text	0000000a stm32f_dma2_stream1_isr
08001ae0 g     F .text	000000a0 cm3_systick_isr
08004be0 g     O .text	00000010 stm32_usart_fops
08000190 g     F .text	00000448 main
080013e4  w    F .text	0000000a stm32f_tim1_up_tim10_isr
080013e4  w    F .text	0000000a stm32f_tim1_trg_com_tim17_isr
08001698 g     F .text	0000003a stm32f_otg_fs_ep_disable
08004f88 g     O .text	00000030 thinkos_obj_alloc_lut
08004cf8 g     O .text	00000006 stm32_usart_clk_lut
08000900 g     F .text	00000022 stm32f_otg_dev_ep_zlp_send
080044d8  w    F .text	0000007c dcclog3
08004380 g     F .text	00000030 ice_comm_connect
080013e4  w    F .text	0000000a stm32f_tim14_isr
08002ce4 g     F .text	00000138 thinkos_thread_create_svc
08004cdc g     O .text	00000004 stm32f_ahb_hz
080039a8 g     F .text	000000c0 thinkos_ev_wait_svc
080026c4 g     F .text	000000fc thinkos_flag_set_svc
080013e4 g     F .text	0000000a _isr
080013e0  w    F .text	00000004 cm3_nmi_isr
08004d00 g     O .text	00000005 stm32_usart_irq_lut
080019f0 g     F .text	000000a0 udelay_calibrate
08002b54 g     F .text	0000003e cm3_bus_fault_isr
08001680 g     F .text	00000016 stm32f_otg_fs_addr_set
080013e4  w    F .text	0000000a stm32f_tim12_isr
080013e4  w    F .text	0000000a stm32f_can1_rx0_isr
080013e4  w    F .text	0000000a stm32f_tim4_isr
080043c8 g     F .text	0000004c ice_trace0
20000ed0 g     O .bss	00000004 stderr
08003194 g     F .text	00000148 thinkos_cond_wait_svc
080013e4  w    F .text	0000000a stm32f_can1_tx_isr
08004ea4 g     O .text	00000004 thinkos_except_nm
08000980 g     F .text	000000c4 stm32f_otg_dev_ep_pkt_recv
0800361c g     F .text	00000030 thinkos_sem_free_svc
080013e4  w    F .text	0000000a stm32f_hash_rng_isr
080013e4  w    F .text	0000000a stm32f_tim1_up_tim16_isr
080013e4  w    F .text	0000000a stm32f_exti2_isr
080013e4  w    F .text	0000000a stm32f_can2_sce_isr
080021cc g     F .text	000000b4 thinkos_flag_wait_svc
080041f8 g     F .text	0000001e fputc
08001950 g     F .text	0000002a stm32_usart_getc
20000f24 g       .bss	00000000 __heap_start
080015ec g     F .text	0000003c stm32_usart_canon_write
080045e4  w    F .text	000000e4 dcclog6
080013e4  w    F .text	0000000a stm32f_dma1_stream5_isr
08000680 g     F .text	0000000c stm32_gpio_id
08005518 g       .text	00000000 __ctors_end
08001e40 g     F .text	00000260 cm3_svc_isr
080013f4 g     F .text	0000006c _reset
08001714 g     F .text	00000094 stm32f_otg_fs_txf_setup
080013e4  w    F .text	0000000a stm32f_usart1_isr
08002ad0  w    F .text	00000002 thinkos_exception_dsr
080013e4  w    F .text	0000000a stm32f_spi3_isr
080013e4  w    F .text	0000000a stm32f_tim13_isr
080013e4  w    F .text	0000000a stm32f_cryp_isr
08004fb8 g     O .text	00000192 thinkos_obj_type_lut
08003978 g     F .text	00000030 thinkos_ev_free_svc
080013e4  w    F .text	0000000a stm32f_exti3_isr
080013e4  w    F .text	0000000a stm32f_dma2_stream7_isr
080013e0  w    F .text	00000004 halt
080013e4  w    F .text	0000000a stm32f_rcc_isr
080013e4  w    F .text	0000000a stm32f_tim7_isr
08004cd8 g     O .text	00000004 stm32f_apb1_hz
080013e4  w    F .text	0000000a stm32f_dma2_stream0_isr
080013e4  w    F .text	0000000a stm32f_otg_hs_ep1_out_isr
080013e4  w    F .text	0000000a stm32f_dma2_stream4_isr
080018f8 g     F .text	00000040 stm32f_otg_fs_ep_dump
08001a90 g     F .text	00000004 thinkos_idle_task
080020e8 g     F .text	0000006c thinkos_irq_wait_svc
080013e4  w    F .text	0000000a stm32f_adc_isr
080013e4  w    F .text	0000000a stm32f_eth_wkup_isr
080013e0  w    F .text	00000004 cm3_debug_mon_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream3_isr
080013e4  w    F .text	0000000a stm32f_i2c1_ev_exti23_isr
08003070 g     F .text	000000d4 thinkos_mutex_unlock_svc
08003888 g     F .text	000000b8 thinkos_sem_post_svc
080013e4  w    F .text	0000000a stm32f_tim8_cc_isr
080013e4  w    F .text	0000000a stm32f_exti2_tsc_isr
08003144 g     F .text	00000020 thinkos_cond_alloc_svc
08002c40 g     F .text	00000050 thinkos_alarm_svc
08002e78 g     F .text	000000b4 thinkos_mutex_lock_svc
080013e4  w    F .text	0000000a stm32f_i2c1_er_isr
08003eb8 g     F .text	00000012 strlen
08001be8 g     F .text	000001e8 thinkos_init
08002ad4 g     F .text	0000003e cm3_hard_fault_isr
10010000 g       *ABS*	00000000 _stack
08003940 g     F .text	00000038 thinkos_ev_alloc_svc
080013e4  w    F .text	0000000a stm32f_uart5_isr
080044d8 g     F .text	0000007c ice_trace3
080032dc g     F .text	00000168 thinkos_cond_timedwait_svc
20000000 g       .data	00000000 __data_start
080013e4  w    F .text	0000000a stm32f_dma2_stream5_isr
080035e0 g     F .text	0000003c thinkos_sem_alloc_svc
080013e0 g     F .text	00000004 _halt
080013e4  w    F .text	0000000a stm32f_eth_isr
080008fc g     F .text	00000004 stm32f_otg_dev_ep_stall
080013e4  w    F .text	0000000a stm32f_sdio_isr
080013e4  w    F .text	0000000a stm32f_dma1_stream2_isr
080013e4  w    F .text	0000000a stm32f_otg_hs_wkup_isr
080013e4  w    F .text	0000000a stm32f_fsmc_isr
08002154 g     F .text	00000048 thinkos_flag_alloc_svc
08004414  w    F .text	0000005c dcclog1
080013e4  w    F .text	0000000a stm32f_pvd_isr
080013e4  w    F .text	0000000a stm32f_can2_rx1_isr
08003ecc g     F .text	00000328 vfprintf
080013e4  w    F .text	0000000a stm32f_spi2_isr
080013e4  w    F .text	0000000a stm32f_otg_hs_ep1_in_isr



Disassembly of section .init:

08000000 <__rom_vectors>:
 8000000:	00 00 01 10 f5 13 00 08 e1 13 00 08 d5 2a 00 08     .............*..
 8000010:	e1 13 00 08 55 2b 00 08 15 2b 00 08 00 00 00 00     ....U+...+......
 8000020:	d4 0e 00 20 00 00 00 00 00 00 00 00 41 1e 00 08     ... ........A...
 8000030:	e1 13 00 08 00 00 00 00 a1 1a 00 08 e1 1a 00 08     ................
 8000040:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000050:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000060:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000070:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000080:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000090:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000a0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000b0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000c0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000d0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000e0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 80000f0:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000100:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000110:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000120:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000130:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000140:	e5 13 00 08 e5 13 00 08 e5 13 00 08 39 0e 00 08     ............9...
 8000150:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000160:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000170:	e5 13 00 08 e5 13 00 08 e5 13 00 08 e5 13 00 08     ................
 8000180:	e5 13 00 08                                         ....

Disassembly of section .text:

08000190 <main>:
#include <sys/dcclog.h>

void stdio_init(void);

int main(int argc, char ** argv)
{
 8000190:	b570      	push	{r4, r5, r6, lr}
 8000192:	f5ad 6da0 	sub.w	sp, sp, #1280	; 0x500
	int16_t ev[128];
	int i;
	int n;

	/* Run the test */
	DCC_LOG_INIT();
 8000196:	f004 f90b 	bl	80043b0 <ice_trace_init>
	DCC_LOG_CONNECT();
 800019a:	f004 f8f1 	bl	8004380 <ice_comm_connect>

	/* Calibrate the the uDelay loop */
	cm3_udelay_calibrate();
 800019e:	f001 fbfb 	bl	8001998 <cm3_udelay_calibrate>

	/* Initialize the stdin, stdout and stderr */
	stdio_init();
 80001a2:	f000 fa19 	bl	80005d8 <stdio_init>

	/* Print a useful information message */
	printf("\n");
 80001a6:	200a      	movs	r0, #10
 80001a8:	f003 fe62 	bl	8003e70 <putchar>
	printf("---------------------------------------------------------\n");
 80001ac:	4897      	ldr	r0, [pc, #604]	; (800040c <main+0x27c>)
 80001ae:	f003 fe67 	bl	8003e80 <puts>
	printf(" ThinkOS - Alloc demo\n");
 80001b2:	4897      	ldr	r0, [pc, #604]	; (8000410 <main+0x280>)
 80001b4:	f003 fe64 	bl	8003e80 <puts>
	printf("---------------------------------------------------------\n");
 80001b8:	4894      	ldr	r0, [pc, #592]	; (800040c <main+0x27c>)
 80001ba:	f003 fe61 	bl	8003e80 <puts>
	printf("\n");
 80001be:	200a      	movs	r0, #10
 80001c0:	f003 fe56 	bl	8003e70 <putchar>

	/* Initialize the ThinkOS kernel */
	thinkos_init(THINKOS_OPT_PRIORITY(0) | THINKOS_OPT_ID(0));
 80001c4:	2000      	movs	r0, #0
 80001c6:	f001 fd0f 	bl	8001be8 <thinkos_init>
static inline uint32_t __attribute__((always_inline)) thinkos_clock(void) {
	return THINKOS_SVC(THINKOS_CLOCK);
}

static inline int __attribute__((always_inline)) thinkos_mutex_alloc(void) {
	return THINKOS_SVC(THINKOS_MUTEX_ALLOC);
 80001ca:	df20      	svc	32

	/* -------------------------------------------------------------------
	   Mutexes
	   ------------------------------------------------------------------- */
	for (n = 0; (mutex[n] = thinkos_mutex_alloc()) > 0; ++n);
 80001cc:	b280      	uxth	r0, r0
 80001ce:	b203      	sxth	r3, r0
 80001d0:	2b00      	cmp	r3, #0
 80001d2:	f8ad 0000 	strh.w	r0, [sp]
 80001d6:	f340 814f 	ble.w	8000478 <main+0x2e8>
 80001da:	466e      	mov	r6, sp
 80001dc:	466b      	mov	r3, sp
 80001de:	2200      	movs	r2, #0
 80001e0:	e000      	b.n	80001e4 <main+0x54>
 80001e2:	4622      	mov	r2, r4
 80001e4:	1c54      	adds	r4, r2, #1
 80001e6:	df20      	svc	32
 80001e8:	b280      	uxth	r0, r0
 80001ea:	b201      	sxth	r1, r0
 80001ec:	2900      	cmp	r1, #0
 80001ee:	f823 0f02 	strh.w	r0, [r3, #2]!
 80001f2:	dcf6      	bgt.n	80001e2 <main+0x52>
	if (n == 0) {
		printf("#ERROR: thinkos_mutex_alloc() failed!\n");
		abort();
	}

	printf(" - %d mutexs: %d..%d \n", n, mutex[0], mutex[n - 1]);
 80001f4:	f8bd 5000 	ldrh.w	r5, [sp]
 80001f8:	f93d 3012 	ldrsh.w	r3, [sp, r2, lsl #1]
 80001fc:	4885      	ldr	r0, [pc, #532]	; (8000414 <main+0x284>)
 80001fe:	4621      	mov	r1, r4
 8000200:	b22a      	sxth	r2, r5
 8000202:	f003 fe21 	bl	8003e48 <printf>

	for (i = 0; i < n; ++i) {
 8000206:	2300      	movs	r3, #0
 8000208:	e001      	b.n	800020e <main+0x7e>
 800020a:	f836 5f02 	ldrh.w	r5, [r6, #2]!
		if (thinkos_mutex_lock(mutex[i]) < 0) {
 800020e:	b228      	sxth	r0, r5
static inline int __attribute__((always_inline)) thinkos_mutex_free(int mutex) {
	return THINKOS_SVC1(THINKOS_MUTEX_FREE, mutex);
}

static inline int __attribute__((always_inline)) thinkos_mutex_lock(int mutex) {
	return THINKOS_SVC1(THINKOS_MUTEX_LOCK, mutex);
 8000210:	df05      	svc	5
 8000212:	2800      	cmp	r0, #0
 8000214:	f2c0 81b2 	blt.w	800057c <main+0x3ec>
		abort();
	}

	printf(" - %d mutexs: %d..%d \n", n, mutex[0], mutex[n - 1]);

	for (i = 0; i < n; ++i) {
 8000218:	3301      	adds	r3, #1
 800021a:	42a3      	cmp	r3, r4
 800021c:	dbf5      	blt.n	800020a <main+0x7a>
 800021e:	f1ad 0202 	sub.w	r2, sp, #2
 8000222:	4611      	mov	r1, r2
 8000224:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_mutex_unlock(mutex[i]) < 0) {
 8000226:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
	return THINKOS_SVC2(THINKOS_MUTEX_TIMEDLOCK, mutex, ms);
}

static inline int __attribute__((always_inline)) 
thinkos_mutex_unlock(int mutex) {
	return THINKOS_SVC1(THINKOS_MUTEX_UNLOCK, mutex);
 800022a:	df08      	svc	8
 800022c:	2800      	cmp	r0, #0
 800022e:	f2c0 819e 	blt.w	800056e <main+0x3de>
			printf("#ERROR: mutex_lock(%d) failed!\n", mutex[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 8000232:	3301      	adds	r3, #1
 8000234:	42a3      	cmp	r3, r4
 8000236:	dbf6      	blt.n	8000226 <main+0x96>
 8000238:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_mutex_free(mutex[i]) < 0) {
 800023a:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
static inline int __attribute__((always_inline)) thinkos_mutex_alloc(void) {
	return THINKOS_SVC(THINKOS_MUTEX_ALLOC);
}

static inline int __attribute__((always_inline)) thinkos_mutex_free(int mutex) {
	return THINKOS_SVC1(THINKOS_MUTEX_FREE, mutex);
 800023e:	df21      	svc	33	; 0x21
 8000240:	2800      	cmp	r0, #0
 8000242:	f2c0 818d 	blt.w	8000560 <main+0x3d0>
			printf("#ERROR: mutex_unlock(%d) failed!\n", mutex[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 8000246:	3301      	adds	r3, #1
 8000248:	42a3      	cmp	r3, r4
 800024a:	dbf6      	blt.n	800023a <main+0xaa>
	return THINKOS_SVC1(THINKOS_MUTEX_UNLOCK, mutex);
}


static inline int __attribute__((always_inline)) thinkos_cond_alloc(void) {
	return THINKOS_SVC(THINKOS_COND_ALLOC);
 800024c:	df24      	svc	36	; 0x24
	}

	/* -------------------------------------------------------------------
	   Conditional Variables 
	   ------------------------------------------------------------------- */
	for (n = 0; (cond[n] = thinkos_cond_alloc()) > 0; ++n);
 800024e:	b280      	uxth	r0, r0
 8000250:	b203      	sxth	r3, r0
 8000252:	2b00      	cmp	r3, #0
 8000254:	f8ad 0200 	strh.w	r0, [sp, #512]	; 0x200
 8000258:	f340 817d 	ble.w	8000556 <main+0x3c6>
 800025c:	ae80      	add	r6, sp, #512	; 0x200
 800025e:	4632      	mov	r2, r6
 8000260:	2300      	movs	r3, #0
 8000262:	e000      	b.n	8000266 <main+0xd6>
 8000264:	4623      	mov	r3, r4
 8000266:	1c5c      	adds	r4, r3, #1
 8000268:	df24      	svc	36	; 0x24
 800026a:	b280      	uxth	r0, r0
 800026c:	b201      	sxth	r1, r0
 800026e:	2900      	cmp	r1, #0
 8000270:	f822 0f02 	strh.w	r0, [r2, #2]!
 8000274:	dcf6      	bgt.n	8000264 <main+0xd4>
	if (n == 0) {
		printf("#ERROR: thinkos_cond_alloc() failed!\n");
		abort();
	}

	printf(" - %d conditional variables: %d..%d \n", n, cond[0], cond[n - 1]);
 8000276:	f8bd 5200 	ldrh.w	r5, [sp, #512]	; 0x200
 800027a:	4867      	ldr	r0, [pc, #412]	; (8000418 <main+0x288>)
 800027c:	a980      	add	r1, sp, #512	; 0x200
 800027e:	b22a      	sxth	r2, r5
 8000280:	f931 3013 	ldrsh.w	r3, [r1, r3, lsl #1]
 8000284:	4621      	mov	r1, r4
 8000286:	f003 fddf 	bl	8003e48 <printf>

	for (i = 0; i < n; ++i) {
 800028a:	2300      	movs	r3, #0
 800028c:	e001      	b.n	8000292 <main+0x102>
 800028e:	f836 5f02 	ldrh.w	r5, [r6, #2]!
		if (thinkos_cond_signal(cond[i]) < 0) {
 8000292:	b228      	sxth	r0, r5
	return ret;
}

static inline int __attribute__((always_inline)) 
thinkos_cond_signal(int cond) {
	return THINKOS_SVC1(THINKOS_COND_SIGNAL, cond);
 8000294:	df10      	svc	16
 8000296:	2800      	cmp	r0, #0
 8000298:	f2c0 8155 	blt.w	8000546 <main+0x3b6>
		abort();
	}

	printf(" - %d conditional variables: %d..%d \n", n, cond[0], cond[n - 1]);

	for (i = 0; i < n; ++i) {
 800029c:	3301      	adds	r3, #1
 800029e:	429c      	cmp	r4, r3
 80002a0:	dcf5      	bgt.n	800028e <main+0xfe>
 80002a2:	f50d 72ff 	add.w	r2, sp, #510	; 0x1fe
 80002a6:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_cond_free(cond[i]) < 0) {
 80002a8:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
static inline int __attribute__((always_inline)) thinkos_cond_alloc(void) {
	return THINKOS_SVC(THINKOS_COND_ALLOC);
}

static inline int __attribute__((always_inline)) thinkos_cond_free(int cond) {
	return THINKOS_SVC1(THINKOS_COND_FREE, cond);
 80002ac:	df25      	svc	37	; 0x25
 80002ae:	2800      	cmp	r0, #0
 80002b0:	f2c0 8141 	blt.w	8000536 <main+0x3a6>
			printf("#ERROR: cond_lock(%d) failed!\n", cond[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 80002b4:	3301      	adds	r3, #1
 80002b6:	429c      	cmp	r4, r3
 80002b8:	dcf6      	bgt.n	80002a8 <main+0x118>
	return THINKOS_SVC1(THINKOS_COND_BROADCAST, cond);
}

static inline int __attribute__((always_inline)) 
thinkos_sem_alloc(unsigned int value) {
	return THINKOS_SVC1(THINKOS_SEM_ALLOC, value);
 80002ba:	2000      	movs	r0, #0
 80002bc:	df22      	svc	34	; 0x22
	}

	/* -------------------------------------------------------------------
	   Semaphores
	   ------------------------------------------------------------------- */
	for (n = 0; (sem[n] = thinkos_sem_alloc(0)) > 0; ++n);
 80002be:	b280      	uxth	r0, r0
 80002c0:	b203      	sxth	r3, r0
 80002c2:	2b00      	cmp	r3, #0
 80002c4:	f8ad 0300 	strh.w	r0, [sp, #768]	; 0x300
 80002c8:	f340 8130 	ble.w	800052c <main+0x39c>
 80002cc:	aec0      	add	r6, sp, #768	; 0x300
 80002ce:	4633      	mov	r3, r6
 80002d0:	2200      	movs	r2, #0
 80002d2:	e000      	b.n	80002d6 <main+0x146>
 80002d4:	4622      	mov	r2, r4
 80002d6:	1c54      	adds	r4, r2, #1
 80002d8:	2000      	movs	r0, #0
 80002da:	df22      	svc	34	; 0x22
 80002dc:	b280      	uxth	r0, r0
 80002de:	b201      	sxth	r1, r0
 80002e0:	2900      	cmp	r1, #0
 80002e2:	f823 0f02 	strh.w	r0, [r3, #2]!
 80002e6:	dcf5      	bgt.n	80002d4 <main+0x144>
	if (n == 0) {
		printf("#ERROR: thinkos_sem_alloc() failed!\n");
		abort();
	}

	printf(" - %d semaphores: %d..%d \n", n, sem[0], sem[n - 1]);
 80002e8:	f8bd 5300 	ldrh.w	r5, [sp, #768]	; 0x300
 80002ec:	484b      	ldr	r0, [pc, #300]	; (800041c <main+0x28c>)
 80002ee:	a9c0      	add	r1, sp, #768	; 0x300
 80002f0:	f931 3012 	ldrsh.w	r3, [r1, r2, lsl #1]
 80002f4:	4621      	mov	r1, r4
 80002f6:	b22a      	sxth	r2, r5
 80002f8:	f003 fda6 	bl	8003e48 <printf>

	for (i = 0; i < n; ++i) {
 80002fc:	2300      	movs	r3, #0
 80002fe:	e001      	b.n	8000304 <main+0x174>
 8000300:	f836 5f02 	ldrh.w	r5, [r6, #2]!
		if (thinkos_sem_post(sem[i]) < 0) {
 8000304:	b228      	sxth	r0, r5
thinkos_sem_timedwait(int sem, unsigned int ms) {
	return THINKOS_SVC2(THINKOS_SEM_TIMEDWAIT, sem, ms);
}

static inline int __attribute__((always_inline)) thinkos_sem_post(int sem) {
	return THINKOS_SVC1(THINKOS_SEM_POST, sem);
 8000306:	df0d      	svc	13
 8000308:	2800      	cmp	r0, #0
 800030a:	f2c0 8107 	blt.w	800051c <main+0x38c>
		abort();
	}

	printf(" - %d semaphores: %d..%d \n", n, sem[0], sem[n - 1]);

	for (i = 0; i < n; ++i) {
 800030e:	3301      	adds	r3, #1
 8000310:	429c      	cmp	r4, r3
 8000312:	dcf5      	bgt.n	8000300 <main+0x170>
 8000314:	f20d 22fe 	addw	r2, sp, #766	; 0x2fe
 8000318:	4611      	mov	r1, r2
 800031a:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_sem_wait(sem[i]) < 0) {
 800031c:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
	thinkos_sem_init(int sem, unsigned int value) {
	return THINKOS_SVC2(THINKOS_SEM_INIT, sem, value);
}

static inline int __attribute__((always_inline)) thinkos_sem_wait(int sem) {
	return THINKOS_SVC1(THINKOS_SEM_WAIT, sem);
 8000320:	df0a      	svc	10
 8000322:	2800      	cmp	r0, #0
 8000324:	f2c0 80f2 	blt.w	800050c <main+0x37c>
			printf("#ERROR: thinkos_sem_post(%d) failed!\n", sem[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 8000328:	3301      	adds	r3, #1
 800032a:	429c      	cmp	r4, r3
 800032c:	dcf6      	bgt.n	800031c <main+0x18c>
 800032e:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_sem_free(sem[i]) < 0) {
 8000330:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
thinkos_sem_alloc(unsigned int value) {
	return THINKOS_SVC1(THINKOS_SEM_ALLOC, value);
}

static inline int __attribute__((always_inline)) thinkos_sem_free(int sem) {
	return THINKOS_SVC1(THINKOS_SEM_FREE, sem);
 8000334:	df23      	svc	35	; 0x23
 8000336:	2800      	cmp	r0, #0
 8000338:	f2c0 80e0 	blt.w	80004fc <main+0x36c>
			printf("#ERROR: thinkos_sem_wait(%d) failed!\n", sem[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 800033c:	3301      	adds	r3, #1
 800033e:	429c      	cmp	r4, r3
 8000340:	dcf6      	bgt.n	8000330 <main+0x1a0>
/* ---------------------------------------------------------------------------
   Event sets
  ----------------------------------------------------------------------------*/

static inline int __attribute__((always_inline)) thinkos_ev_alloc(void) {
	return THINKOS_SVC(THINKOS_EVENT_ALLOC);
 8000342:	df28      	svc	40	; 0x28
	}

	/* -------------------------------------------------------------------
	   Semaphores
	   ------------------------------------------------------------------- */
	for (n = 0; (ev[n] = thinkos_ev_alloc()) > 0; ++n);
 8000344:	b280      	uxth	r0, r0
 8000346:	b203      	sxth	r3, r0
 8000348:	2b00      	cmp	r3, #0
 800034a:	f8ad 0400 	strh.w	r0, [sp, #1024]	; 0x400
 800034e:	f340 80d0 	ble.w	80004f2 <main+0x362>
 8000352:	f50d 6680 	add.w	r6, sp, #1024	; 0x400
 8000356:	4632      	mov	r2, r6
 8000358:	2300      	movs	r3, #0
 800035a:	e000      	b.n	800035e <main+0x1ce>
 800035c:	4623      	mov	r3, r4
 800035e:	1c5c      	adds	r4, r3, #1
 8000360:	df28      	svc	40	; 0x28
 8000362:	b280      	uxth	r0, r0
 8000364:	b201      	sxth	r1, r0
 8000366:	2900      	cmp	r1, #0
 8000368:	f822 0f02 	strh.w	r0, [r2, #2]!
 800036c:	dcf6      	bgt.n	800035c <main+0x1cc>
	if (n == 0) {
		printf("#ERROR: thinkos_ev_alloc() failed!\n");
		abort();
	}

	printf(" - %d event sets: %d..%d \n", n, ev[0], ev[n - 1]);
 800036e:	f8bd 5400 	ldrh.w	r5, [sp, #1024]	; 0x400
 8000372:	482b      	ldr	r0, [pc, #172]	; (8000420 <main+0x290>)
 8000374:	f50d 6180 	add.w	r1, sp, #1024	; 0x400
 8000378:	b22a      	sxth	r2, r5
 800037a:	f931 3013 	ldrsh.w	r3, [r1, r3, lsl #1]
 800037e:	4621      	mov	r1, r4
 8000380:	f003 fd62 	bl	8003e48 <printf>

	for (i = 0; i < n; ++i) {
 8000384:	2300      	movs	r3, #0
 8000386:	e001      	b.n	800038c <main+0x1fc>
 8000388:	f836 5f02 	ldrh.w	r5, [r6, #2]!
		if (thinkos_ev_raise(ev[i], 1) < 0) {
 800038c:	b228      	sxth	r0, r5
	return THINKOS_SVC2(THINKOS_EVENT_TIMEDWAIT, set, ms);
}

static inline int __attribute__((always_inline)) thinkos_ev_raise(
	int set, int ev) {
	return THINKOS_SVC2(THINKOS_EVENT_RAISE, set, ev);
 800038e:	2101      	movs	r1, #1
 8000390:	df1c      	svc	28
 8000392:	2800      	cmp	r0, #0
 8000394:	f2c0 80a4 	blt.w	80004e0 <main+0x350>
		abort();
	}

	printf(" - %d event sets: %d..%d \n", n, ev[0], ev[n - 1]);

	for (i = 0; i < n; ++i) {
 8000398:	3301      	adds	r3, #1
 800039a:	429c      	cmp	r4, r3
 800039c:	dcf4      	bgt.n	8000388 <main+0x1f8>
 800039e:	f20d 32fe 	addw	r2, sp, #1022	; 0x3fe
 80003a2:	4611      	mov	r1, r2
 80003a4:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_ev_wait(ev[i]) < 0) {
 80003a6:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
static inline int __attribute__((always_inline)) thinkos_ev_free(int set) {
	return THINKOS_SVC1(THINKOS_EVENT_FREE, set);
}

static inline int __attribute__((always_inline)) thinkos_ev_wait(int set) {
	return THINKOS_SVC1(THINKOS_EVENT_WAIT, set);
 80003aa:	df1a      	svc	26
 80003ac:	2800      	cmp	r0, #0
 80003ae:	f2c0 808e 	blt.w	80004ce <main+0x33e>
			printf("#ERROR: thinkos_ev_raise(%d) failed!\n", ev[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 80003b2:	3301      	adds	r3, #1
 80003b4:	429c      	cmp	r4, r3
 80003b6:	dcf6      	bgt.n	80003a6 <main+0x216>
 80003b8:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_ev_free(ev[i]) < 0) {
 80003ba:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
static inline int __attribute__((always_inline)) thinkos_ev_alloc(void) {
	return THINKOS_SVC(THINKOS_EVENT_ALLOC);
}

static inline int __attribute__((always_inline)) thinkos_ev_free(int set) {
	return THINKOS_SVC1(THINKOS_EVENT_FREE, set);
 80003be:	df29      	svc	41	; 0x29
 80003c0:	2800      	cmp	r0, #0
 80003c2:	db7b      	blt.n	80004bc <main+0x32c>
			printf("#ERROR: thinkos_ev_wait(%d) failed!\n", ev[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 80003c4:	3301      	adds	r3, #1
 80003c6:	429c      	cmp	r4, r3
 80003c8:	dcf7      	bgt.n	80003ba <main+0x22a>
/* ---------------------------------------------------------------------------
   Flags
  ----------------------------------------------------------------------------*/

static inline int __attribute__((always_inline)) thinkos_flag_alloc(void) {
	return THINKOS_SVC(THINKOS_FLAG_ALLOC);
 80003ca:	df26      	svc	38	; 0x26


	/* -------------------------------------------------------------------
	   Flags
	   -------------------------------------------------------------------- */
	for (n = 0; (flag[n] = thinkos_flag_alloc()) > 0; ++n);
 80003cc:	b280      	uxth	r0, r0
 80003ce:	b203      	sxth	r3, r0
 80003d0:	2b00      	cmp	r3, #0
 80003d2:	f8ad 0100 	strh.w	r0, [sp, #256]	; 0x100
 80003d6:	dd6c      	ble.n	80004b2 <main+0x322>
 80003d8:	ae40      	add	r6, sp, #256	; 0x100
 80003da:	4632      	mov	r2, r6
 80003dc:	2300      	movs	r3, #0
 80003de:	e000      	b.n	80003e2 <main+0x252>
 80003e0:	4623      	mov	r3, r4
 80003e2:	1c5c      	adds	r4, r3, #1
 80003e4:	df26      	svc	38	; 0x26
 80003e6:	b280      	uxth	r0, r0
 80003e8:	b201      	sxth	r1, r0
 80003ea:	2900      	cmp	r1, #0
 80003ec:	f822 0f02 	strh.w	r0, [r2, #2]!
 80003f0:	dcf6      	bgt.n	80003e0 <main+0x250>
	if (n == 0) {
		printf("#ERROR: thinkos_flag_alloc() failed!\n");
		abort();
	}

	printf(" - %d flags: %d..%d \n", n, flag[0], flag[n - 1]);
 80003f2:	f8bd 5100 	ldrh.w	r5, [sp, #256]	; 0x100
 80003f6:	480b      	ldr	r0, [pc, #44]	; (8000424 <main+0x294>)
 80003f8:	a940      	add	r1, sp, #256	; 0x100
 80003fa:	b22a      	sxth	r2, r5
 80003fc:	f931 3013 	ldrsh.w	r3, [r1, r3, lsl #1]
 8000400:	4621      	mov	r1, r4
 8000402:	f003 fd21 	bl	8003e48 <printf>

	for (i = 0; i < n; ++i) {
 8000406:	2300      	movs	r3, #0
 8000408:	e010      	b.n	800042c <main+0x29c>
 800040a:	bf00      	nop
 800040c:	08004810 	.word	0x08004810
 8000410:	0800484c 	.word	0x0800484c
 8000414:	0800488c 	.word	0x0800488c
 8000418:	08004930 	.word	0x08004930
 800041c:	080049bc 	.word	0x080049bc
 8000420:	08004a74 	.word	0x08004a74
 8000424:	08004b30 	.word	0x08004b30
 8000428:	f836 5f02 	ldrh.w	r5, [r6, #2]!
		if (thinkos_flag_signal(flag[i]) < 0) {
 800042c:	b228      	sxth	r0, r5
	return THINKOS_SVC2(THINKOS_FLAG_TIMEDTAKE, flag, ms);
}

static inline int __attribute__((always_inline)) 
	thinkos_flag_signal(int flag) {
	return THINKOS_SVC1(THINKOS_FLAG_GIVE, flag);
 800042e:	df19      	svc	25
 8000430:	2800      	cmp	r0, #0
 8000432:	db36      	blt.n	80004a2 <main+0x312>
		abort();
	}

	printf(" - %d flags: %d..%d \n", n, flag[0], flag[n - 1]);

	for (i = 0; i < n; ++i) {
 8000434:	3301      	adds	r3, #1
 8000436:	42a3      	cmp	r3, r4
 8000438:	dbf6      	blt.n	8000428 <main+0x298>
 800043a:	f10d 02fe 	add.w	r2, sp, #254	; 0xfe
 800043e:	4611      	mov	r1, r2
 8000440:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_flag_wait(flag[i]) < 0) {
 8000442:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
static inline int __attribute__((always_inline)) thinkos_flag_clr(int flag) {
	return THINKOS_SVC1(THINKOS_FLAG_CLR, flag);
}

static inline int __attribute__((always_inline)) thinkos_flag_wait(int flag) {
	return THINKOS_SVC1(THINKOS_FLAG_WAIT, flag);
 8000446:	df14      	svc	20
 8000448:	2800      	cmp	r0, #0
 800044a:	db22      	blt.n	8000492 <main+0x302>
			printf("#ERROR: flag_signal(%d) failed!\n", flag[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 800044c:	3301      	adds	r3, #1
 800044e:	42a3      	cmp	r3, r4
 8000450:	dbf7      	blt.n	8000442 <main+0x2b2>
 8000452:	2300      	movs	r3, #0
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_flag_free(flag[i]) < 0) {
 8000454:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
static inline int __attribute__((always_inline)) thinkos_flag_alloc(void) {
	return THINKOS_SVC(THINKOS_FLAG_ALLOC);
}

static inline int __attribute__((always_inline)) thinkos_flag_free(int flag) {
	return THINKOS_SVC1(THINKOS_FLAG_FREE, flag);
 8000458:	df27      	svc	39	; 0x27
 800045a:	2800      	cmp	r0, #0
 800045c:	db11      	blt.n	8000482 <main+0x2f2>
			printf("#ERROR: flag_wait(%d) failed!\n", flag[i]);
			abort();
		}
	}

	for (i = 0; i < n; ++i) {
 800045e:	3301      	adds	r3, #1
 8000460:	42a3      	cmp	r3, r4
 8000462:	dbf7      	blt.n	8000454 <main+0x2c4>
			abort();
		}
	}


	printf("\n");
 8000464:	200a      	movs	r0, #10
 8000466:	f003 fd03 	bl	8003e70 <putchar>
	return THINKOS_SVC1(THINKOS_RESUME, id);
}

static inline int
__attribute__((always_inline)) thinkos_sleep(unsigned int ms) {
	return THINKOS_SVC1(THINKOS_SLEEP, ms);
 800046a:	f242 7010 	movw	r0, #10000	; 0x2710
 800046e:	df04      	svc	4

	thinkos_sleep(10000);

	return 0;
}
 8000470:	2000      	movs	r0, #0
 8000472:	f50d 6da0 	add.w	sp, sp, #1280	; 0x500
 8000476:	bd70      	pop	{r4, r5, r6, pc}
	   Mutexes
	   ------------------------------------------------------------------- */
	for (n = 0; (mutex[n] = thinkos_mutex_alloc()) > 0; ++n);

	if (n == 0) {
		printf("#ERROR: thinkos_mutex_alloc() failed!\n");
 8000478:	4844      	ldr	r0, [pc, #272]	; (800058c <main+0x3fc>)
 800047a:	f003 fd01 	bl	8003e80 <puts>
		abort();
 800047e:	f003 feb9 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_flag_free(flag[i]) < 0) {
			printf("#ERROR: flag_free(%d) failed!\n", flag[i]);
 8000482:	aa40      	add	r2, sp, #256	; 0x100
 8000484:	4842      	ldr	r0, [pc, #264]	; (8000590 <main+0x400>)
 8000486:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800048a:	f003 fcdd 	bl	8003e48 <printf>
			abort();
 800048e:	f003 feb1 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_flag_wait(flag[i]) < 0) {
			printf("#ERROR: flag_wait(%d) failed!\n", flag[i]);
 8000492:	aa40      	add	r2, sp, #256	; 0x100
 8000494:	483f      	ldr	r0, [pc, #252]	; (8000594 <main+0x404>)
 8000496:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800049a:	f003 fcd5 	bl	8003e48 <printf>
			abort();
 800049e:	f003 fea9 	bl	80041f4 <abort>

	printf(" - %d flags: %d..%d \n", n, flag[0], flag[n - 1]);

	for (i = 0; i < n; ++i) {
		if (thinkos_flag_signal(flag[i]) < 0) {
			printf("#ERROR: flag_signal(%d) failed!\n", flag[i]);
 80004a2:	aa40      	add	r2, sp, #256	; 0x100
 80004a4:	483c      	ldr	r0, [pc, #240]	; (8000598 <main+0x408>)
 80004a6:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 80004aa:	f003 fccd 	bl	8003e48 <printf>
			abort();
 80004ae:	f003 fea1 	bl	80041f4 <abort>
	   Flags
	   -------------------------------------------------------------------- */
	for (n = 0; (flag[n] = thinkos_flag_alloc()) > 0; ++n);

	if (n == 0) {
		printf("#ERROR: thinkos_flag_alloc() failed!\n");
 80004b2:	483a      	ldr	r0, [pc, #232]	; (800059c <main+0x40c>)
 80004b4:	f003 fce4 	bl	8003e80 <puts>
		abort();
 80004b8:	f003 fe9c 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_ev_free(ev[i]) < 0) {
			printf("#ERROR: thinkos_ev_free(%d) failed!\n", ev[i]);
 80004bc:	f50d 6280 	add.w	r2, sp, #1024	; 0x400
 80004c0:	4837      	ldr	r0, [pc, #220]	; (80005a0 <main+0x410>)
 80004c2:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 80004c6:	f003 fcbf 	bl	8003e48 <printf>
			abort();
 80004ca:	f003 fe93 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_ev_wait(ev[i]) < 0) {
			printf("#ERROR: thinkos_ev_wait(%d) failed!\n", ev[i]);
 80004ce:	f50d 6280 	add.w	r2, sp, #1024	; 0x400
 80004d2:	4834      	ldr	r0, [pc, #208]	; (80005a4 <main+0x414>)
 80004d4:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 80004d8:	f003 fcb6 	bl	8003e48 <printf>
			abort();
 80004dc:	f003 fe8a 	bl	80041f4 <abort>

	printf(" - %d event sets: %d..%d \n", n, ev[0], ev[n - 1]);

	for (i = 0; i < n; ++i) {
		if (thinkos_ev_raise(ev[i], 1) < 0) {
			printf("#ERROR: thinkos_ev_raise(%d) failed!\n", ev[i]);
 80004e0:	f50d 6280 	add.w	r2, sp, #1024	; 0x400
 80004e4:	4830      	ldr	r0, [pc, #192]	; (80005a8 <main+0x418>)
 80004e6:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 80004ea:	f003 fcad 	bl	8003e48 <printf>
			abort();
 80004ee:	f003 fe81 	bl	80041f4 <abort>
	   Semaphores
	   ------------------------------------------------------------------- */
	for (n = 0; (ev[n] = thinkos_ev_alloc()) > 0; ++n);

	if (n == 0) {
		printf("#ERROR: thinkos_ev_alloc() failed!\n");
 80004f2:	482e      	ldr	r0, [pc, #184]	; (80005ac <main+0x41c>)
 80004f4:	f003 fcc4 	bl	8003e80 <puts>
		abort();
 80004f8:	f003 fe7c 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_sem_free(sem[i]) < 0) {
			printf("#ERROR: thinkos_sem_free(%d) failed!\n", sem[i]);
 80004fc:	aac0      	add	r2, sp, #768	; 0x300
 80004fe:	482c      	ldr	r0, [pc, #176]	; (80005b0 <main+0x420>)
 8000500:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 8000504:	f003 fca0 	bl	8003e48 <printf>
			abort();
 8000508:	f003 fe74 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_sem_wait(sem[i]) < 0) {
			printf("#ERROR: thinkos_sem_wait(%d) failed!\n", sem[i]);
 800050c:	aac0      	add	r2, sp, #768	; 0x300
 800050e:	4829      	ldr	r0, [pc, #164]	; (80005b4 <main+0x424>)
 8000510:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 8000514:	f003 fc98 	bl	8003e48 <printf>
			abort();
 8000518:	f003 fe6c 	bl	80041f4 <abort>

	printf(" - %d semaphores: %d..%d \n", n, sem[0], sem[n - 1]);

	for (i = 0; i < n; ++i) {
		if (thinkos_sem_post(sem[i]) < 0) {
			printf("#ERROR: thinkos_sem_post(%d) failed!\n", sem[i]);
 800051c:	aac0      	add	r2, sp, #768	; 0x300
 800051e:	4826      	ldr	r0, [pc, #152]	; (80005b8 <main+0x428>)
 8000520:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 8000524:	f003 fc90 	bl	8003e48 <printf>
			abort();
 8000528:	f003 fe64 	bl	80041f4 <abort>
	   Semaphores
	   ------------------------------------------------------------------- */
	for (n = 0; (sem[n] = thinkos_sem_alloc(0)) > 0; ++n);

	if (n == 0) {
		printf("#ERROR: thinkos_sem_alloc() failed!\n");
 800052c:	4823      	ldr	r0, [pc, #140]	; (80005bc <main+0x42c>)
 800052e:	f003 fca7 	bl	8003e80 <puts>
		abort();
 8000532:	f003 fe5f 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_cond_free(cond[i]) < 0) {
			printf("#ERROR: cond_free(%d) failed!\n", cond[i]);
 8000536:	aa80      	add	r2, sp, #512	; 0x200
 8000538:	4821      	ldr	r0, [pc, #132]	; (80005c0 <main+0x430>)
 800053a:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800053e:	f003 fc83 	bl	8003e48 <printf>
			abort();
 8000542:	f003 fe57 	bl	80041f4 <abort>

	printf(" - %d conditional variables: %d..%d \n", n, cond[0], cond[n - 1]);

	for (i = 0; i < n; ++i) {
		if (thinkos_cond_signal(cond[i]) < 0) {
			printf("#ERROR: cond_lock(%d) failed!\n", cond[i]);
 8000546:	aa80      	add	r2, sp, #512	; 0x200
 8000548:	481e      	ldr	r0, [pc, #120]	; (80005c4 <main+0x434>)
 800054a:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800054e:	f003 fc7b 	bl	8003e48 <printf>
			abort();
 8000552:	f003 fe4f 	bl	80041f4 <abort>
	   Conditional Variables 
	   ------------------------------------------------------------------- */
	for (n = 0; (cond[n] = thinkos_cond_alloc()) > 0; ++n);

	if (n == 0) {
		printf("#ERROR: thinkos_cond_alloc() failed!\n");
 8000556:	481c      	ldr	r0, [pc, #112]	; (80005c8 <main+0x438>)
 8000558:	f003 fc92 	bl	8003e80 <puts>
		abort();
 800055c:	f003 fe4a 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_mutex_free(mutex[i]) < 0) {
			printf("#ERROR: mutex_free(%d) failed!\n", mutex[i]);
 8000560:	f93d 1013 	ldrsh.w	r1, [sp, r3, lsl #1]
 8000564:	4819      	ldr	r0, [pc, #100]	; (80005cc <main+0x43c>)
 8000566:	f003 fc6f 	bl	8003e48 <printf>
			abort();
 800056a:	f003 fe43 	bl	80041f4 <abort>
		}
	}

	for (i = 0; i < n; ++i) {
		if (thinkos_mutex_unlock(mutex[i]) < 0) {
			printf("#ERROR: mutex_unlock(%d) failed!\n", mutex[i]);
 800056e:	f93d 1013 	ldrsh.w	r1, [sp, r3, lsl #1]
 8000572:	4817      	ldr	r0, [pc, #92]	; (80005d0 <main+0x440>)
 8000574:	f003 fc68 	bl	8003e48 <printf>
			abort();
 8000578:	f003 fe3c 	bl	80041f4 <abort>

	printf(" - %d mutexs: %d..%d \n", n, mutex[0], mutex[n - 1]);

	for (i = 0; i < n; ++i) {
		if (thinkos_mutex_lock(mutex[i]) < 0) {
			printf("#ERROR: mutex_lock(%d) failed!\n", mutex[i]);
 800057c:	f93d 1013 	ldrsh.w	r1, [sp, r3, lsl #1]
 8000580:	4814      	ldr	r0, [pc, #80]	; (80005d4 <main+0x444>)
 8000582:	f003 fc61 	bl	8003e48 <printf>
			abort();
 8000586:	f003 fe35 	bl	80041f4 <abort>
 800058a:	bf00      	nop
 800058c:	08004864 	.word	0x08004864
 8000590:	08004b8c 	.word	0x08004b8c
 8000594:	08004b6c 	.word	0x08004b6c
 8000598:	08004b48 	.word	0x08004b48
 800059c:	08004b08 	.word	0x08004b08
 80005a0:	08004ae0 	.word	0x08004ae0
 80005a4:	08004ab8 	.word	0x08004ab8
 80005a8:	08004a90 	.word	0x08004a90
 80005ac:	08004a50 	.word	0x08004a50
 80005b0:	08004a28 	.word	0x08004a28
 80005b4:	08004a00 	.word	0x08004a00
 80005b8:	080049d8 	.word	0x080049d8
 80005bc:	08004998 	.word	0x08004998
 80005c0:	08004978 	.word	0x08004978
 80005c4:	08004958 	.word	0x08004958
 80005c8:	08004908 	.word	0x08004908
 80005cc:	080048e8 	.word	0x080048e8
 80005d0:	080048c4 	.word	0x080048c4
 80005d4:	080048a4 	.word	0x080048a4

080005d8 <stdio_init>:
	.op = &stm32_usart_fops 
};
#endif

void stdio_init(void)
{
 80005d8:	b570      	push	{r4, r5, r6, lr}
	else if (bus == STM32_AHB2)
		rcc->ahb2enr |= 1 << bit;
	else if (bus == STM32_AHB3)
		rcc->ahb3enr |= 1 << bit;
	else
		rcc->ahb1enr |= 1 << bit;
 80005da:	f44f 5460 	mov.w	r4, #14336	; 0x3800
 80005de:	f2c4 0402 	movt	r4, #16386	; 0x4002
#else
	stm32_clk_enable(STM32_RCC, STM32_CLK_GPIOB);
#endif

	/* USART1_TX */
	stm32_gpio_mode(UART_TX, ALT_FUNC, PUSH_PULL | SPEED_LOW);
 80005e2:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80005e6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80005e8:	f043 0304 	orr.w	r3, r3, #4
 80005ec:	6323      	str	r3, [r4, #48]	; 0x30
 80005ee:	6b26      	ldr	r6, [r4, #48]	; 0x30
 80005f0:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80005f4:	f046 0608 	orr.w	r6, r6, #8
 80005f8:	4628      	mov	r0, r5
 80005fa:	210c      	movs	r1, #12
 80005fc:	2202      	movs	r2, #2
 80005fe:	2300      	movs	r3, #0
 8000600:	6326      	str	r6, [r4, #48]	; 0x30
#elif defined(STM32F2X) 
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
	stm32_gpio_af(UART_RX, GPIO_AF7);
	stm32_gpio_af(UART_TX, GPIO_AF7);
#elif defined(STM32F4X)
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
 8000602:	f44f 6440 	mov.w	r4, #3072	; 0xc00
#else
	stm32_clk_enable(STM32_RCC, STM32_CLK_GPIOB);
#endif

	/* USART1_TX */
	stm32_gpio_mode(UART_TX, ALT_FUNC, PUSH_PULL | SPEED_LOW);
 8000606:	f000 f851 	bl	80006ac <stm32_gpio_mode>
#elif defined(STM32F2X) 
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
	stm32_gpio_af(UART_RX, GPIO_AF7);
	stm32_gpio_af(UART_TX, GPIO_AF7);
#elif defined(STM32F4X)
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
 800060a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800060e:	2102      	movs	r1, #2
 8000610:	2320      	movs	r3, #32
 8000612:	460a      	mov	r2, r1
 8000614:	4620      	mov	r0, r4
 8000616:	f000 f849 	bl	80006ac <stm32_gpio_mode>
	stm32_gpio_af(UART_RX, GPIO_AF8);
 800061a:	4620      	mov	r0, r4
 800061c:	2102      	movs	r1, #2
 800061e:	2208      	movs	r2, #8
	stm32_gpio_af(UART_TX, GPIO_AF8);
#endif

	stm32_usart_init(uart);
 8000620:	f44f 44a0 	mov.w	r4, #20480	; 0x5000
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
	stm32_gpio_af(UART_RX, GPIO_AF7);
	stm32_gpio_af(UART_TX, GPIO_AF7);
#elif defined(STM32F4X)
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
	stm32_gpio_af(UART_RX, GPIO_AF8);
 8000624:	f000 f880 	bl	8000728 <stm32_gpio_af>
	stm32_gpio_af(UART_TX, GPIO_AF8);
#endif

	stm32_usart_init(uart);
 8000628:	f2c4 0400 	movt	r4, #16384	; 0x4000
	stm32_gpio_af(UART_RX, GPIO_AF7);
	stm32_gpio_af(UART_TX, GPIO_AF7);
#elif defined(STM32F4X)
	stm32_gpio_mode(UART_RX, ALT_FUNC, PULL_UP);
	stm32_gpio_af(UART_RX, GPIO_AF8);
	stm32_gpio_af(UART_TX, GPIO_AF8);
 800062c:	2208      	movs	r2, #8
 800062e:	210c      	movs	r1, #12
 8000630:	4628      	mov	r0, r5
 8000632:	f000 f879 	bl	8000728 <stm32_gpio_af>
#endif

	stm32_usart_init(uart);
 8000636:	4620      	mov	r0, r4
 8000638:	f000 f894 	bl	8000764 <stm32_usart_init>
	stm32_usart_baudrate_set(uart, 115200);
 800063c:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8000640:	4620      	mov	r0, r4
 8000642:	f000 f8d1 	bl	80007e8 <stm32_usart_baudrate_set>
	stm32_usart_mode_set(uart, SERIAL_8N1);
 8000646:	f44f 7184 	mov.w	r1, #264	; 0x108
 800064a:	4620      	mov	r0, r4
 800064c:	f000 f900 	bl	8000850 <stm32_usart_mode_set>
	stm32_usart_enable(uart);
 8000650:	4620      	mov	r0, r4
 8000652:	f000 f93d 	bl	80008d0 <stm32_usart_enable>

	stderr = &stm32f_uart_file;
 8000656:	f640 60d0 	movw	r0, #3792	; 0xed0
	stdin = stderr;
 800065a:	f640 61c8 	movw	r1, #3784	; 0xec8
	stdout = stdin;
 800065e:	f640 62cc 	movw	r2, #3788	; 0xecc
	stm32_usart_init(uart);
	stm32_usart_baudrate_set(uart, 115200);
	stm32_usart_mode_set(uart, SERIAL_8N1);
	stm32_usart_enable(uart);

	stderr = &stm32f_uart_file;
 8000662:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000666:	f240 0300 	movw	r3, #0
	stdin = stderr;
 800066a:	f2c2 0100 	movt	r1, #8192	; 0x2000
	stdout = stdin;
 800066e:	f2c2 0200 	movt	r2, #8192	; 0x2000
	stm32_usart_init(uart);
	stm32_usart_baudrate_set(uart, 115200);
	stm32_usart_mode_set(uart, SERIAL_8N1);
	stm32_usart_enable(uart);

	stderr = &stm32f_uart_file;
 8000672:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000676:	6003      	str	r3, [r0, #0]
	stdin = stderr;
 8000678:	600b      	str	r3, [r1, #0]
	stdout = stdin;
 800067a:	6013      	str	r3, [r2, #0]
 800067c:	bd70      	pop	{r4, r5, r6, pc}
 800067e:	bf00      	nop

08000680 <stm32_gpio_id>:

int stm32_gpio_id(struct stm32_gpio * gpio)
{
	uint32_t base = (uint32_t)gpio;

	return (base - STM32_BASE_GPIOA) / 0x400;
 8000680:	f100 403f 	add.w	r0, r0, #3204448256	; 0xbf000000
 8000684:	f500 007e 	add.w	r0, r0, #16646144	; 0xfe0000
}
 8000688:	0a80      	lsrs	r0, r0, #10
 800068a:	4770      	bx	lr

0800068c <stm32_gpio_clock_en>:
void stm32_gpio_clock_en(struct stm32_gpio * gpio)
{
	struct stm32_rcc * rcc = STM32_RCC;

#if defined(STM32F2X) || defined(STM32F4X)
	rcc->ahb1enr |= 1 << stm32_gpio_id(gpio);
 800068c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000690:	f2c4 0302 	movt	r3, #16386	; 0x4002

int stm32_gpio_id(struct stm32_gpio * gpio)
{
	uint32_t base = (uint32_t)gpio;

	return (base - STM32_BASE_GPIOA) / 0x400;
 8000694:	f100 403f 	add.w	r0, r0, #3204448256	; 0xbf000000
 8000698:	f500 027e 	add.w	r2, r0, #16646144	; 0xfe0000
void stm32_gpio_clock_en(struct stm32_gpio * gpio)
{
	struct stm32_rcc * rcc = STM32_RCC;

#if defined(STM32F2X) || defined(STM32F4X)
	rcc->ahb1enr |= 1 << stm32_gpio_id(gpio);
 800069c:	6b19      	ldr	r1, [r3, #48]	; 0x30

int stm32_gpio_id(struct stm32_gpio * gpio)
{
	uint32_t base = (uint32_t)gpio;

	return (base - STM32_BASE_GPIOA) / 0x400;
 800069e:	0a92      	lsrs	r2, r2, #10
void stm32_gpio_clock_en(struct stm32_gpio * gpio)
{
	struct stm32_rcc * rcc = STM32_RCC;

#if defined(STM32F2X) || defined(STM32F4X)
	rcc->ahb1enr |= 1 << stm32_gpio_id(gpio);
 80006a0:	2001      	movs	r0, #1
 80006a2:	fa00 f202 	lsl.w	r2, r0, r2
 80006a6:	430a      	orrs	r2, r1
 80006a8:	631a      	str	r2, [r3, #48]	; 0x30
 80006aa:	4770      	bx	lr

080006ac <stm32_gpio_mode>:
}
#endif

void stm32_gpio_mode(struct stm32_gpio * gpio, 
					  unsigned int pin, unsigned int mode, unsigned int opt)
{
 80006ac:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t tmp;
	uint32_t moder; 

	/* set the pin mode */
	moder = gpio->moder;
	moder &= ~GPIO_MODE_MASK(pin);
 80006ae:	004c      	lsls	r4, r1, #1
 80006b0:	2703      	movs	r7, #3

	uint32_t tmp;
	uint32_t moder; 

	/* set the pin mode */
	moder = gpio->moder;
 80006b2:	6806      	ldr	r6, [r0, #0]
	moder &= ~GPIO_MODE_MASK(pin);
 80006b4:	fa07 f704 	lsl.w	r7, r7, r4
	switch (mode & 0x0f) {
 80006b8:	f002 020f 	and.w	r2, r2, #15
	uint32_t tmp;
	uint32_t moder; 

	/* set the pin mode */
	moder = gpio->moder;
	moder &= ~GPIO_MODE_MASK(pin);
 80006bc:	43fd      	mvns	r5, r7
	switch (mode & 0x0f) {
 80006be:	2a02      	cmp	r2, #2
	uint32_t tmp;
	uint32_t moder; 

	/* set the pin mode */
	moder = gpio->moder;
	moder &= ~GPIO_MODE_MASK(pin);
 80006c0:	ea05 0606 	and.w	r6, r5, r6
	switch (mode & 0x0f) {
 80006c4:	d026      	beq.n	8000714 <stm32_gpio_mode+0x68>
 80006c6:	2a03      	cmp	r2, #3
		break;
	case ALT_FUNC:
		moder |= GPIO_MODE_ALT_FUNC(pin);
		break;
	case ANALOG:
		moder |= GPIO_MODE_ANALOG(pin);
 80006c8:	bf08      	it	eq
 80006ca:	433e      	orreq	r6, r7
	uint32_t moder; 

	/* set the pin mode */
	moder = gpio->moder;
	moder &= ~GPIO_MODE_MASK(pin);
	switch (mode & 0x0f) {
 80006cc:	d001      	beq.n	80006d2 <stm32_gpio_mode+0x26>
 80006ce:	2a01      	cmp	r2, #1
 80006d0:	d020      	beq.n	8000714 <stm32_gpio_mode+0x68>
		break;
	case ANALOG:
		moder |= GPIO_MODE_ANALOG(pin);
		break;
	}
	gpio->moder = moder;
 80006d2:	6006      	str	r6, [r0, #0]

	/* set the pin output speed */
	tmp = gpio->ospeedr;
 80006d4:	6886      	ldr	r6, [r0, #8]
	tmp &= ~GPIO_OSPEED_MASK(pin);
	tmp |= OPT_SPEED(opt) << (2 * pin);
 80006d6:	f003 0203 	and.w	r2, r3, #3
	}
	gpio->moder = moder;

	/* set the pin output speed */
	tmp = gpio->ospeedr;
	tmp &= ~GPIO_OSPEED_MASK(pin);
 80006da:	402e      	ands	r6, r5
	tmp |= OPT_SPEED(opt) << (2 * pin);
 80006dc:	fa02 f204 	lsl.w	r2, r2, r4
 80006e0:	4332      	orrs	r2, r6
	gpio->ospeedr = tmp;
 80006e2:	6082      	str	r2, [r0, #8]

	/* set the pin output type */
	tmp = gpio->otyper;
 80006e4:	6842      	ldr	r2, [r0, #4]
	tmp &= ~GPIO_OTYPE_MASK(pin);
 80006e6:	2601      	movs	r6, #1
 80006e8:	fa06 f101 	lsl.w	r1, r6, r1
 80006ec:	ea22 0201 	bic.w	r2, r2, r1
	if (opt & OPEN_DRAIN)
 80006f0:	f013 0f10 	tst.w	r3, #16
		tmp |= GPIO_OPEN_DRAIN(pin);
 80006f4:	bf18      	it	ne
 80006f6:	430a      	orrne	r2, r1
	else
		tmp |= GPIO_PUSH_PULL(pin);
	gpio->otyper = tmp;
 80006f8:	6042      	str	r2, [r0, #4]

	/* set the pin pull up / pull down resistors */
	tmp = gpio->pupdr;
 80006fa:	68c2      	ldr	r2, [r0, #12]
	tmp &= ~GPIO_PULL_MASK(pin);
 80006fc:	4015      	ands	r5, r2
	if (opt & PULL_UP)
 80006fe:	069a      	lsls	r2, r3, #26
 8000700:	d40c      	bmi.n	800071c <stm32_gpio_mode+0x70>
		tmp |= GPIO_PULL_UP(pin);
	else if (opt & PULL_DOWN)
 8000702:	065b      	lsls	r3, r3, #25
 8000704:	d503      	bpl.n	800070e <stm32_gpio_mode+0x62>
		tmp |= GPIO_PULL_DOWN(pin);
 8000706:	2302      	movs	r3, #2
 8000708:	fa03 f404 	lsl.w	r4, r3, r4
 800070c:	4325      	orrs	r5, r4
	gpio->pupdr = tmp;
 800070e:	60c5      	str	r5, [r0, #12]
		gpio->crh |= ((cnf << 2) | mod) << ((pin - 8) * 4);
	}

#endif

}
 8000710:	bcf0      	pop	{r4, r5, r6, r7}
 8000712:	4770      	bx	lr
		break;
	case OUTPUT:
		moder |= GPIO_MODE_OUTPUT(pin);
		break;
	case ALT_FUNC:
		moder |= GPIO_MODE_ALT_FUNC(pin);
 8000714:	fa02 f204 	lsl.w	r2, r2, r4
 8000718:	4316      	orrs	r6, r2
		break;
 800071a:	e7da      	b.n	80006d2 <stm32_gpio_mode+0x26>

	/* set the pin pull up / pull down resistors */
	tmp = gpio->pupdr;
	tmp &= ~GPIO_PULL_MASK(pin);
	if (opt & PULL_UP)
		tmp |= GPIO_PULL_UP(pin);
 800071c:	2301      	movs	r3, #1
 800071e:	fa03 f404 	lsl.w	r4, r3, r4
 8000722:	4325      	orrs	r5, r4
 8000724:	e7f3      	b.n	800070e <stm32_gpio_mode+0x62>
 8000726:	bf00      	nop

08000728 <stm32_gpio_af>:
	defined(STM32L1X)
void stm32_gpio_af(struct stm32_gpio * gpio, int pin, int af)
{
	uint32_t tmp;

	if (pin < 8) {
 8000728:	2907      	cmp	r1, #7
}

#if defined(STM32F2X) || defined(STM32F3X) || defined(STM32F4X) || \
	defined(STM32L1X)
void stm32_gpio_af(struct stm32_gpio * gpio, int pin, int af)
{
 800072a:	b410      	push	{r4}
	uint32_t tmp;

	if (pin < 8) {
 800072c:	dd0e      	ble.n	800074c <stm32_gpio_af+0x24>
		tmp &= ~GPIO_AFRL_MASK(pin);
		tmp |= GPIO_AFRL_SET(pin, af);
		gpio->afrl = tmp;
	} else {
		tmp = gpio->afrh;
		tmp &= ~GPIO_AFRH_MASK(pin);
 800072e:	3908      	subs	r1, #8
 8000730:	0089      	lsls	r1, r1, #2
		tmp = gpio->afrl;
		tmp &= ~GPIO_AFRL_MASK(pin);
		tmp |= GPIO_AFRL_SET(pin, af);
		gpio->afrl = tmp;
	} else {
		tmp = gpio->afrh;
 8000732:	6a44      	ldr	r4, [r0, #36]	; 0x24
		tmp &= ~GPIO_AFRH_MASK(pin);
 8000734:	230f      	movs	r3, #15
 8000736:	fa03 f301 	lsl.w	r3, r3, r1
 800073a:	ea24 0303 	bic.w	r3, r4, r3
		tmp |= GPIO_AFRH_SET(pin, af);
 800073e:	fa02 f201 	lsl.w	r2, r2, r1
 8000742:	ea43 0102 	orr.w	r1, r3, r2
		gpio->afrh = tmp;
 8000746:	6241      	str	r1, [r0, #36]	; 0x24
	}
}
 8000748:	bc10      	pop	{r4}
 800074a:	4770      	bx	lr
void stm32_gpio_af(struct stm32_gpio * gpio, int pin, int af)
{
	uint32_t tmp;

	if (pin < 8) {
		tmp = gpio->afrl;
 800074c:	6a04      	ldr	r4, [r0, #32]
		tmp &= ~GPIO_AFRL_MASK(pin);
 800074e:	0089      	lsls	r1, r1, #2
 8000750:	230f      	movs	r3, #15
 8000752:	fa03 f301 	lsl.w	r3, r3, r1
 8000756:	ea24 0303 	bic.w	r3, r4, r3
		tmp |= GPIO_AFRL_SET(pin, af);
 800075a:	fa02 f101 	lsl.w	r1, r2, r1
 800075e:	4319      	orrs	r1, r3
		gpio->afrl = tmp;
 8000760:	6201      	str	r1, [r0, #32]
 8000762:	e7f1      	b.n	8000748 <stm32_gpio_af+0x20>

08000764 <stm32_usart_init>:
 */

#include "usart-priv.h"

int stm32_usart_init(struct stm32_usart * us)
{
 8000764:	b538      	push	{r3, r4, r5, lr}
 8000766:	4604      	mov	r4, r0
	int id;

	if ((id = stm32_usart_lookup(us)) < 0) {
 8000768:	f000 feda 	bl	8001520 <stm32_usart_lookup>
 800076c:	2800      	cmp	r0, #0
 800076e:	db1d      	blt.n	80007ac <stm32_usart_init+0x48>

	/* disable all interrupts */
	us->cr1 = 0;

	/* Enable peripheral clock */
	stm32_clk_enable(STM32_RCC, stm32_usart_clk_lut[id].bus, 
 8000770:	4b1c      	ldr	r3, [pc, #112]	; (80007e4 <stm32_usart_init+0x80>)
 8000772:	5c1a      	ldrb	r2, [r3, r0]
	}

	DCC_LOG2(LOG_INFO, "USART %d -> 0x%08x.", id + 1, us);

	/* disable all interrupts */
	us->cr1 = 0;
 8000774:	2100      	movs	r1, #0

	/* Enable peripheral clock */
	stm32_clk_enable(STM32_RCC, stm32_usart_clk_lut[id].bus, 
 8000776:	f002 0307 	and.w	r3, r2, #7
	}

	DCC_LOG2(LOG_INFO, "USART %d -> 0x%08x.", id + 1, us);

	/* disable all interrupts */
	us->cr1 = 0;
 800077a:	60e1      	str	r1, [r4, #12]

	/* Enable peripheral clock */
	stm32_clk_enable(STM32_RCC, stm32_usart_clk_lut[id].bus, 
 800077c:	08d2      	lsrs	r2, r2, #3
#endif

static inline void stm32_clk_enable(struct stm32_rcc * rcc, 
									int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr |= 1 << bit;
 800077e:	f44f 5160 	mov.w	r1, #14336	; 0x3800
extern "C" {
#endif

static inline void stm32_clk_enable(struct stm32_rcc * rcc, 
									int bus, int bit) {
	if (bus == STM32_APB2)
 8000782:	2b02      	cmp	r3, #2
		rcc->apb2enr |= 1 << bit;
 8000784:	f2c4 0102 	movt	r1, #16386	; 0x4002
extern "C" {
#endif

static inline void stm32_clk_enable(struct stm32_rcc * rcc, 
									int bus, int bit) {
	if (bus == STM32_APB2)
 8000788:	d017      	beq.n	80007ba <stm32_usart_init+0x56>
		rcc->apb2enr |= 1 << bit;
	else if (bus == STM32_APB1)
 800078a:	2b01      	cmp	r3, #1
 800078c:	d00f      	beq.n	80007ae <stm32_usart_init+0x4a>
		rcc->apb1enr |= 1 << bit;
#if defined(STM32F1X) || defined(STM32F3X)
	else
		rcc->ahbenr |= 1 << bit;
#else
	else if (bus == STM32_AHB2)
 800078e:	2b03      	cmp	r3, #3
 8000790:	d01a      	beq.n	80007c8 <stm32_usart_init+0x64>
		rcc->ahb2enr |= 1 << bit;
	else if (bus == STM32_AHB3)
 8000792:	2b04      	cmp	r3, #4
 8000794:	d01f      	beq.n	80007d6 <stm32_usart_init+0x72>
		rcc->ahb3enr |= 1 << bit;
	else
		rcc->ahb1enr |= 1 << bit;
 8000796:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 8000798:	2301      	movs	r3, #1
 800079a:	fa03 f202 	lsl.w	r2, r3, r2
 800079e:	432a      	orrs	r2, r5
 80007a0:	630a      	str	r2, [r1, #48]	; 0x30
					 stm32_usart_clk_lut[id].bit);

	/* output drain */
//	while (!(us->sr & USART_TXE));

	us->cr1 = 0;
 80007a2:	2300      	movs	r3, #0
 80007a4:	60e3      	str	r3, [r4, #12]
	us->cr2 = 0;
 80007a6:	6123      	str	r3, [r4, #16]
	us->cr3 = 0;
 80007a8:	6163      	str	r3, [r4, #20]
	us->gtpr = 0;
 80007aa:	61a3      	str	r3, [r4, #24]

	DCC_LOG(LOG_INFO, "done.");

	return id;
}
 80007ac:	bd38      	pop	{r3, r4, r5, pc}
static inline void stm32_clk_enable(struct stm32_rcc * rcc, 
									int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr |= 1 << bit;
	else if (bus == STM32_APB1)
		rcc->apb1enr |= 1 << bit;
 80007ae:	6c0d      	ldr	r5, [r1, #64]	; 0x40
 80007b0:	fa03 f202 	lsl.w	r2, r3, r2
 80007b4:	432a      	orrs	r2, r5
 80007b6:	640a      	str	r2, [r1, #64]	; 0x40
 80007b8:	e7f3      	b.n	80007a2 <stm32_usart_init+0x3e>
#endif

static inline void stm32_clk_enable(struct stm32_rcc * rcc, 
									int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr |= 1 << bit;
 80007ba:	6c4d      	ldr	r5, [r1, #68]	; 0x44
 80007bc:	2301      	movs	r3, #1
 80007be:	fa03 f202 	lsl.w	r2, r3, r2
 80007c2:	432a      	orrs	r2, r5
 80007c4:	644a      	str	r2, [r1, #68]	; 0x44
 80007c6:	e7ec      	b.n	80007a2 <stm32_usart_init+0x3e>
#if defined(STM32F1X) || defined(STM32F3X)
	else
		rcc->ahbenr |= 1 << bit;
#else
	else if (bus == STM32_AHB2)
		rcc->ahb2enr |= 1 << bit;
 80007c8:	6b4d      	ldr	r5, [r1, #52]	; 0x34
 80007ca:	2301      	movs	r3, #1
 80007cc:	fa03 f202 	lsl.w	r2, r3, r2
 80007d0:	432a      	orrs	r2, r5
 80007d2:	634a      	str	r2, [r1, #52]	; 0x34
 80007d4:	e7e5      	b.n	80007a2 <stm32_usart_init+0x3e>
	else if (bus == STM32_AHB3)
		rcc->ahb3enr |= 1 << bit;
 80007d6:	6b8d      	ldr	r5, [r1, #56]	; 0x38
 80007d8:	2301      	movs	r3, #1
 80007da:	fa03 f202 	lsl.w	r2, r3, r2
 80007de:	432a      	orrs	r2, r5
 80007e0:	638a      	str	r2, [r1, #56]	; 0x38
 80007e2:	e7de      	b.n	80007a2 <stm32_usart_init+0x3e>
 80007e4:	08004cf8 	.word	0x08004cf8

080007e8 <stm32_usart_baudrate_set>:
 */

#include "usart-priv.h"

int stm32_usart_baudrate_set(struct stm32_usart * us, unsigned int baudrate)
{
 80007e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80007ea:	4604      	mov	r4, r0
 80007ec:	460d      	mov	r5, r1
	uint32_t m;
	uint32_t cr1;
	uint32_t f_pclk;
	int id;

	if ((id = stm32_usart_lookup(us)) < 0) {
 80007ee:	f000 fe97 	bl	8001520 <stm32_usart_lookup>
 80007f2:	2800      	cmp	r0, #0
 80007f4:	db1a      	blt.n	800082c <stm32_usart_baudrate_set+0x44>
		/* invalid UART ??? */
		return id;
	}

	if (baudrate <= 100) {
 80007f6:	2d64      	cmp	r5, #100	; 0x64
 80007f8:	d919      	bls.n	800082e <stm32_usart_baudrate_set+0x46>
	/* disable TX and RX and interrupts */
	cr1 = us->cr1;
	us->cr1 = cr1 & ~(USART_UE | USART_TE | USART_RE | USART_TXEIE | 
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);

	if (stm32_usart_clk_lut[id].bus == STM32_APB2)
 80007fa:	4b10      	ldr	r3, [pc, #64]	; (800083c <stm32_usart_baudrate_set+0x54>)
		DCC_LOG(LOG_WARNING, "invalid baudrate");
		return -1;
	}

	/* disable TX and RX and interrupts */
	cr1 = us->cr1;
 80007fc:	68e6      	ldr	r6, [r4, #12]
	us->cr1 = cr1 & ~(USART_UE | USART_TE | USART_RE | USART_TXEIE | 
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);

	if (stm32_usart_clk_lut[id].bus == STM32_APB2)
 80007fe:	5c1b      	ldrb	r3, [r3, r0]
	else 
		f_pclk = stm32f_apb1_hz;

	div = f_pclk / baudrate;

	DCC_LOG3(LOG_TRACE, "baudrate=%d p_clk=%d div=%d", baudrate, f_pclk, div);
 8000800:	480f      	ldr	r0, [pc, #60]	; (8000840 <stm32_usart_baudrate_set+0x58>)
	/* disable TX and RX and interrupts */
	cr1 = us->cr1;
	us->cr1 = cr1 & ~(USART_UE | USART_TE | USART_RE | USART_TXEIE | 
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);

	if (stm32_usart_clk_lut[id].bus == STM32_APB2)
 8000802:	f003 0307 	and.w	r3, r3, #7
 8000806:	2b02      	cmp	r3, #2
		f_pclk = stm32f_apb2_hz;
 8000808:	bf0c      	ite	eq
 800080a:	4b0e      	ldreq	r3, [pc, #56]	; (8000844 <stm32_usart_baudrate_set+0x5c>)
	else 
		f_pclk = stm32f_apb1_hz;
 800080c:	4b0e      	ldrne	r3, [pc, #56]	; (8000848 <stm32_usart_baudrate_set+0x60>)
		return -1;
	}

	/* disable TX and RX and interrupts */
	cr1 = us->cr1;
	us->cr1 = cr1 & ~(USART_UE | USART_TE | USART_RE | USART_TXEIE | 
 800080e:	f426 5203 	bic.w	r2, r6, #8384	; 0x20c0
 8000812:	f022 023c 	bic.w	r2, r2, #60	; 0x3c
 8000816:	60e2      	str	r2, [r4, #12]
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);

	if (stm32_usart_clk_lut[id].bus == STM32_APB2)
		f_pclk = stm32f_apb2_hz;
	else 
		f_pclk = stm32f_apb1_hz;
 8000818:	681a      	ldr	r2, [r3, #0]

	div = f_pclk / baudrate;
 800081a:	fbb2 f7f5 	udiv	r7, r2, r5

	DCC_LOG3(LOG_TRACE, "baudrate=%d p_clk=%d div=%d", baudrate, f_pclk, div);
 800081e:	4629      	mov	r1, r5
 8000820:	463b      	mov	r3, r7
 8000822:	f003 fe59 	bl	80044d8 <ice_trace3>

	m = div >> 4;
	f = div & 0x0f;
	us->brr = (m << 4) | f;
 8000826:	60a7      	str	r7, [r4, #8]

	/* restore cr1 */
	us->cr1 = cr1;

	return 0;
 8000828:	2000      	movs	r0, #0
	m = div >> 4;
	f = div & 0x0f;
	us->brr = (m << 4) | f;

	/* restore cr1 */
	us->cr1 = cr1;
 800082a:	60e6      	str	r6, [r4, #12]

	return 0;
}
 800082c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		/* invalid UART ??? */
		return id;
	}

	if (baudrate <= 100) {
		DCC_LOG(LOG_WARNING, "invalid baudrate");
 800082e:	4807      	ldr	r0, [pc, #28]	; (800084c <stm32_usart_baudrate_set+0x64>)
 8000830:	f003 fdca 	bl	80043c8 <ice_trace0>
		return -1;
 8000834:	f04f 30ff 	mov.w	r0, #4294967295
 8000838:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800083a:	bf00      	nop
 800083c:	08004cf8 	.word	0x08004cf8
 8000840:	40000010 	.word	0x40000010
 8000844:	08004cd0 	.word	0x08004cd0
 8000848:	08004cd8 	.word	0x08004cd8
 800084c:	40000000 	.word	0x40000000

08000850 <stm32_usart_mode_set>:

#include "usart-priv.h"
#include <sys/serial.h>

int stm32_usart_mode_set(struct stm32_usart * us, unsigned int flags)
{
 8000850:	b538      	push	{r3, r4, r5, lr}
 8000852:	4604      	mov	r4, r0
 8000854:	460d      	mov	r5, r1
	uint32_t cr2;
	uint32_t cr_en;
	int bits;
	int id;

	if ((id = stm32_usart_lookup(us)) < 0) {
 8000856:	f000 fe63 	bl	8001520 <stm32_usart_lookup>
 800085a:	2800      	cmp	r0, #0
 800085c:	db21      	blt.n	80008a2 <stm32_usart_mode_set+0x52>
		/* invalid UART ??? */
		return id;
	}

	/* save bits that should be restored */
	cr_en = us->cr1 & (USART_UE | USART_TE | USART_RE | USART_TXEIE | 
 800085e:	68e3      	ldr	r3, [r4, #12]
 8000860:	f242 02fc 	movw	r2, #8444	; 0x20fc
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);
	if (cr_en & USART_TE) {
 8000864:	0719      	lsls	r1, r3, #28
		/* invalid UART ??? */
		return id;
	}

	/* save bits that should be restored */
	cr_en = us->cr1 & (USART_UE | USART_TE | USART_RE | USART_TXEIE | 
 8000866:	ea03 0202 	and.w	r2, r3, r2
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);
	if (cr_en & USART_TE) {
 800086a:	d41b      	bmi.n	80008a4 <stm32_usart_mode_set+0x54>
		DCC_LOG(LOG_INFO, "8 data bits");
		break;
	}

	/* parity and data bits */
	switch (flags & SERIAL_PARITY_MASK) {
 800086c:	f005 03f0 	and.w	r3, r5, #240	; 0xf0
		/* drain output buffer */
		while (!(us->sr & USART_TXE));
	}

	/* disable TX, RX and all interrupts */
	us->cr1 = 0;
 8000870:	2100      	movs	r1, #0
		DCC_LOG(LOG_INFO, "8 data bits");
		break;
	}

	/* parity and data bits */
	switch (flags & SERIAL_PARITY_MASK) {
 8000872:	2b10      	cmp	r3, #16
		/* drain output buffer */
		while (!(us->sr & USART_TXE));
	}

	/* disable TX, RX and all interrupts */
	us->cr1 = 0;
 8000874:	60e1      	str	r1, [r4, #12]

	cr1 = 0;
	cr2 = 0;

	bits = flags & SERIAL_DATABITS_MASK;
 8000876:	f005 010f 	and.w	r1, r5, #15
		DCC_LOG(LOG_INFO, "8 data bits");
		break;
	}

	/* parity and data bits */
	switch (flags & SERIAL_PARITY_MASK) {
 800087a:	d021      	beq.n	80008c0 <stm32_usart_mode_set+0x70>
 800087c:	2b20      	cmp	r3, #32
 800087e:	d018      	beq.n	80008b2 <stm32_usart_mode_set+0x62>
		cr1 |= (bits == SERIAL_DATABITS_8) ? USART_M9 : USART_M8;
		break;
	case SERIAL_PARITY_NONE:
	default:
		DCC_LOG(LOG_INFO, "parity NONE");
		cr1 |= (bits == SERIAL_DATABITS_9) ? USART_M9 : USART_M8;
 8000880:	2909      	cmp	r1, #9
 8000882:	bf0c      	ite	eq
 8000884:	f44f 5380 	moveq.w	r3, #4096	; 0x1000
 8000888:	2300      	movne	r3, #0
		break;
	}

	/* stop bits */
	switch (flags & SERIAL_STOPBITS_MASK) {
 800088a:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
 800088e:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8000892:	bf0c      	ite	eq
 8000894:	f44f 5500 	moveq.w	r5, #8192	; 0x2000
 8000898:	2500      	movne	r5, #0
		DCC_LOG(LOG_INFO, "1 stop bit");
		cr2 |= USART_STOP_1;
		break;
	}

	us->cr1 = cr1 | cr_en;
 800089a:	431a      	orrs	r2, r3
 800089c:	60e2      	str	r2, [r4, #12]
	us->cr2 = cr2;

	return 0;
 800089e:	2000      	movs	r0, #0
		cr2 |= USART_STOP_1;
		break;
	}

	us->cr1 = cr1 | cr_en;
	us->cr2 = cr2;
 80008a0:	6125      	str	r5, [r4, #16]

	return 0;
}
 80008a2:	bd38      	pop	{r3, r4, r5, pc}
	/* save bits that should be restored */
	cr_en = us->cr1 & (USART_UE | USART_TE | USART_RE | USART_TXEIE | 
					  USART_TCIE | USART_IDLEIE | USART_RXNEIE);
	if (cr_en & USART_TE) {
		/* drain output buffer */
		while (!(us->sr & USART_TXE));
 80008a4:	6823      	ldr	r3, [r4, #0]
 80008a6:	061b      	lsls	r3, r3, #24
 80008a8:	d4e0      	bmi.n	800086c <stm32_usart_mode_set+0x1c>
 80008aa:	6823      	ldr	r3, [r4, #0]
 80008ac:	061b      	lsls	r3, r3, #24
 80008ae:	d5f9      	bpl.n	80008a4 <stm32_usart_mode_set+0x54>
 80008b0:	e7dc      	b.n	800086c <stm32_usart_mode_set+0x1c>
		cr1 |= (bits == SERIAL_DATABITS_8) ? USART_M9 : USART_M8;
		break;
	case SERIAL_PARITY_ODD:
		DCC_LOG(LOG_INFO, "parity ODD");
		cr1 |= USART_PCE | USART_PS_ODD;
		cr1 |= (bits == SERIAL_DATABITS_8) ? USART_M9 : USART_M8;
 80008b2:	2908      	cmp	r1, #8
 80008b4:	bf14      	ite	ne
 80008b6:	f44f 63c0 	movne.w	r3, #1536	; 0x600
 80008ba:	f44f 53b0 	moveq.w	r3, #5632	; 0x1600
 80008be:	e7e4      	b.n	800088a <stm32_usart_mode_set+0x3a>
	/* parity and data bits */
	switch (flags & SERIAL_PARITY_MASK) {
	case SERIAL_PARITY_EVEN:
		DCC_LOG(LOG_INFO, "parity EVEN");
		cr1 |= USART_PCE | USART_PS_EVEN;
		cr1 |= (bits == SERIAL_DATABITS_8) ? USART_M9 : USART_M8;
 80008c0:	2908      	cmp	r1, #8
 80008c2:	bf14      	ite	ne
 80008c4:	f44f 6380 	movne.w	r3, #1024	; 0x400
 80008c8:	f44f 53a0 	moveq.w	r3, #5120	; 0x1400
 80008cc:	e7dd      	b.n	800088a <stm32_usart_mode_set+0x3a>
 80008ce:	bf00      	nop

080008d0 <stm32_usart_enable>:
#include "usart-priv.h"

void stm32_usart_enable(struct stm32_usart * us)
{
	/* enable TX and RX */
	us->cr1 |= USART_UE | USART_TE | USART_RE;
 80008d0:	68c3      	ldr	r3, [r0, #12]
 80008d2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80008d6:	f043 030c 	orr.w	r3, r3, #12
 80008da:	60c3      	str	r3, [r0, #12]
 80008dc:	4770      	bx	lr
 80008de:	bf00      	nop

080008e0 <stm32f_otg_dev_ep_nak>:
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	/* FIXME: select outep/inep ... */
	if (flag)
		otg_fs->outep[ep_id].doepctl |= OTG_FS_SNAK;
 80008e0:	3158      	adds	r1, #88	; 0x58
 80008e2:	0149      	lsls	r1, r1, #5
 80008e4:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
 80008e8:	680b      	ldr	r3, [r1, #0]
void stm32f_otg_dev_ep_nak(struct stm32f_otg_drv * drv, int ep_id, bool flag)
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	/* FIXME: select outep/inep ... */
	if (flag)
 80008ea:	b91a      	cbnz	r2, 80008f4 <stm32f_otg_dev_ep_nak+0x14>
		otg_fs->outep[ep_id].doepctl |= OTG_FS_SNAK;
	else
		otg_fs->outep[ep_id].doepctl |= OTG_FS_CNAK;
 80008ec:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80008f0:	600b      	str	r3, [r1, #0]
 80008f2:	4770      	bx	lr
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	/* FIXME: select outep/inep ... */
	if (flag)
		otg_fs->outep[ep_id].doepctl |= OTG_FS_SNAK;
 80008f4:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80008f8:	600b      	str	r3, [r1, #0]
 80008fa:	4770      	bx	lr

080008fc <stm32f_otg_dev_ep_stall>:
	DCC_LOG1(LOG_INFO, "ep_id=%d", ep_id);
#if 0
	__ep_stall(drv, ep_id);
#endif
	return 0;
}
 80008fc:	2000      	movs	r0, #0
 80008fe:	4770      	bx	lr

08000900 <stm32f_otg_dev_ep_zlp_send>:

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 8000900:	014b      	lsls	r3, r1, #5
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8000902:	3148      	adds	r1, #72	; 0x48

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 8000904:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8000908:	0149      	lsls	r1, r1, #5
 800090a:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 800090e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000912:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8000916:	680b      	ldr	r3, [r1, #0]
 8000918:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800091c:	600b      	str	r3, [r1, #0]
	DCC_LOG1(LOG_INFO, "ep_id=%d", ep_id);

	__ep_zlp_send(otg_fs, ep_id);

	return 0;
}
 800091e:	2000      	movs	r0, #0
 8000920:	4770      	bx	lr
 8000922:	bf00      	nop

08000924 <stm32f_otg_dev_ep_disable>:
	return ep_id;
}

int stm32f_otg_dev_ep_disable(struct stm32f_otg_drv * drv,  int ep_id)
{
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];
 8000924:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8000928:	00c9      	lsls	r1, r1, #3

	DCC_LOG1(LOG_INFO, "ep_id=%d...", ep_id);

//	__ep_stall(drv, 0);
	ep->state = EP_UNCONFIGURED;
 800092a:	2300      	movs	r3, #0
 800092c:	5443      	strb	r3, [r0, r1]

	return 0;
}
 800092e:	4618      	mov	r0, r3
 8000930:	4770      	bx	lr
 8000932:	bf00      	nop

08000934 <stm32f_otg_dev_ep_tx_start>:
}

/* start sending */
int stm32f_otg_dev_ep_tx_start(struct stm32f_otg_drv * drv, int ep_id,
		void * buf, unsigned int len)
{
 8000934:	b570      	push	{r4, r5, r6, lr}
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep;
	int ret;

	ep = &drv->ep[ep_id];
 8000936:	eb01 0441 	add.w	r4, r1, r1, lsl #1
 800093a:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
	ep->xfr_ptr = buf;
	ep->xfr_rem = MIN(len, ep->xfr_max);

	/* prepare fifo to transmit */
	if ((ret = stm32f_otg_fs_txf_setup(otg_fs, ep_id, ep->xfr_rem)) < 0) {
 800093e:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
	struct stm32f_otg_ep * ep;
	int ret;

	ep = &drv->ep[ep_id];
	ep->xfr_ptr = buf;
	ep->xfr_rem = MIN(len, ep->xfr_max);
 8000942:	8866      	ldrh	r6, [r4, #2]
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep;
	int ret;

	ep = &drv->ep[ep_id];
	ep->xfr_ptr = buf;
 8000944:	60e2      	str	r2, [r4, #12]
	ep->xfr_rem = MIN(len, ep->xfr_max);
 8000946:	42b3      	cmp	r3, r6
 8000948:	bf28      	it	cs
 800094a:	4633      	movcs	r3, r6
 800094c:	80a3      	strh	r3, [r4, #4]

	/* prepare fifo to transmit */
	if ((ret = stm32f_otg_fs_txf_setup(otg_fs, ep_id, ep->xfr_rem)) < 0) {
 800094e:	b29a      	uxth	r2, r3
}

/* start sending */
int stm32f_otg_dev_ep_tx_start(struct stm32f_otg_drv * drv, int ep_id,
		void * buf, unsigned int len)
{
 8000950:	460d      	mov	r5, r1
	ep = &drv->ep[ep_id];
	ep->xfr_ptr = buf;
	ep->xfr_rem = MIN(len, ep->xfr_max);

	/* prepare fifo to transmit */
	if ((ret = stm32f_otg_fs_txf_setup(otg_fs, ep_id, ep->xfr_rem)) < 0) {
 8000952:	f000 fedf 	bl	8001714 <stm32f_otg_fs_txf_setup>
 8000956:	1e04      	subs	r4, r0, #0
 8000958:	db0b      	blt.n	8000972 <stm32f_otg_dev_ep_tx_start+0x3e>
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_setup() failed!");
	} else {
		/* umask FIFO empty interrupt */
		otg_fs->diepempmsk |= (1 << ep_id);
 800095a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 800095e:	2101      	movs	r1, #1
 8000960:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8000964:	fa01 f505 	lsl.w	r5, r1, r5
 8000968:	4315      	orrs	r5, r2
 800096a:	f8c3 5834 	str.w	r5, [r3, #2100]	; 0x834

	DCC_LOG4(LOG_INFO, "ep_id=%d len=%d xfr_max=%d ret=%d", 
			 ep_id, len, ep->xfr_max, ret);

	return ret;
}
 800096e:	4620      	mov	r0, r4
 8000970:	bd70      	pop	{r4, r5, r6, pc}
	ep->xfr_ptr = buf;
	ep->xfr_rem = MIN(len, ep->xfr_max);

	/* prepare fifo to transmit */
	if ((ret = stm32f_otg_fs_txf_setup(otg_fs, ep_id, ep->xfr_rem)) < 0) {
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_setup() failed!");
 8000972:	4802      	ldr	r0, [pc, #8]	; (800097c <stm32f_otg_dev_ep_tx_start+0x48>)
 8000974:	f003 fd28 	bl	80043c8 <ice_trace0>
 8000978:	e7f9      	b.n	800096e <stm32f_otg_dev_ep_tx_start+0x3a>
 800097a:	bf00      	nop
 800097c:	40000020 	.word	0x40000020

08000980 <stm32f_otg_dev_ep_pkt_recv>:
	return ret;
}

int stm32f_otg_dev_ep_pkt_recv(struct stm32f_otg_drv * drv, int ep_id,
		void * buf, int len)
{
 8000980:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int cnt;
	int rem;

	DCC_LOG2(LOG_INFO, "ep_id=%d len=%d", ep_id, len);

	ep = &drv->ep[ep_id];
 8000984:	eb01 0a41 	add.w	sl, r1, r1, lsl #1
 8000988:	eb00 0aca 	add.w	sl, r0, sl, lsl #3
	return ret;
}

int stm32f_otg_dev_ep_pkt_recv(struct stm32f_otg_drv * drv, int ep_id,
		void * buf, int len)
{
 800098c:	4689      	mov	r9, r1
	DCC_LOG2(LOG_INFO, "ep_id=%d len=%d", ep_id, len);

	ep = &drv->ep[ep_id];
	
	/* transfer data from fifo */
	cnt = MIN(ep->xfr_rem, len);
 800098e:	f8ba b004 	ldrh.w	fp, [sl, #4]
 8000992:	455b      	cmp	r3, fp
 8000994:	bfb8      	it	lt
 8000996:	469b      	movlt	fp, r3

	rem = cnt;
	while (rem >= 4) {
 8000998:	f1bb 0f03 	cmp.w	fp, #3
 800099c:	dd4e      	ble.n	8000a3c <stm32f_otg_dev_ep_pkt_recv+0xbc>
 800099e:	f101 0101 	add.w	r1, r1, #1
		/* word trasfer */
		data = otg_fs->dfifo[ep_id].pop;
 80009a2:	0309      	lsls	r1, r1, #12
	
	/* transfer data from fifo */
	cnt = MIN(ep->xfr_rem, len);

	rem = cnt;
	while (rem >= 4) {
 80009a4:	465e      	mov	r6, fp
 80009a6:	4614      	mov	r4, r2
		/* word trasfer */
		data = otg_fs->dfifo[ep_id].pop;
 80009a8:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
 80009ac:	680d      	ldr	r5, [r1, #0]
		cp[0] = data;
		cp[1] = data >> 8;
		cp[2] = data >> 16;
		cp[3] = data >> 24;
		cp += 4;
		rem -= 4;
 80009ae:	3e04      	subs	r6, #4
		/* word trasfer */
		data = otg_fs->dfifo[ep_id].pop;
		cp[0] = data;
		cp[1] = data >> 8;
		cp[2] = data >> 16;
		cp[3] = data >> 24;
 80009b0:	0e2f      	lsrs	r7, r5, #24
	rem = cnt;
	while (rem >= 4) {
		/* word trasfer */
		data = otg_fs->dfifo[ep_id].pop;
		cp[0] = data;
		cp[1] = data >> 8;
 80009b2:	ea4f 2815 	mov.w	r8, r5, lsr #8
		cp[2] = data >> 16;
 80009b6:	ea4f 4c15 	mov.w	ip, r5, lsr #16

	rem = cnt;
	while (rem >= 4) {
		/* word trasfer */
		data = otg_fs->dfifo[ep_id].pop;
		cp[0] = data;
 80009ba:	7025      	strb	r5, [r4, #0]
		cp[1] = data >> 8;
 80009bc:	f884 8001 	strb.w	r8, [r4, #1]
		cp[2] = data >> 16;
 80009c0:	f884 c002 	strb.w	ip, [r4, #2]
		cp[3] = data >> 24;
 80009c4:	70e7      	strb	r7, [r4, #3]
		cp += 4;
 80009c6:	3404      	adds	r4, #4
	
	/* transfer data from fifo */
	cnt = MIN(ep->xfr_rem, len);

	rem = cnt;
	while (rem >= 4) {
 80009c8:	2e03      	cmp	r6, #3
 80009ca:	dcef      	bgt.n	80009ac <stm32f_otg_dev_ep_pkt_recv+0x2c>
			 ep_id, len, ep->xfr_max, ret);

	return ret;
}

int stm32f_otg_dev_ep_pkt_recv(struct stm32f_otg_drv * drv, int ep_id,
 80009cc:	f1ab 0004 	sub.w	r0, fp, #4
 80009d0:	0883      	lsrs	r3, r0, #2
 80009d2:	1c59      	adds	r1, r3, #1
 80009d4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80009d8:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
		cp[3] = data >> 24;
		cp += 4;
		rem -= 4;
	}

	if (rem > 0) {
 80009dc:	2800      	cmp	r0, #0
 80009de:	dd0e      	ble.n	80009fe <stm32f_otg_dev_ep_pkt_recv+0x7e>
		/* remaining data */
		data = otg_fs->dfifo[ep_id].pop;
 80009e0:	f109 0101 	add.w	r1, r9, #1
 80009e4:	0309      	lsls	r1, r1, #12
 80009e6:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
		cp[0] = data;
		if (rem > 1)
 80009ea:	2801      	cmp	r0, #1
		rem -= 4;
	}

	if (rem > 0) {
		/* remaining data */
		data = otg_fs->dfifo[ep_id].pop;
 80009ec:	680b      	ldr	r3, [r1, #0]
		cp[0] = data;
 80009ee:	7013      	strb	r3, [r2, #0]
		if (rem > 1)
 80009f0:	d005      	beq.n	80009fe <stm32f_otg_dev_ep_pkt_recv+0x7e>
			cp[1] = data >> 8;
 80009f2:	0a19      	lsrs	r1, r3, #8
		if (rem > 2)
 80009f4:	2803      	cmp	r0, #3
	if (rem > 0) {
		/* remaining data */
		data = otg_fs->dfifo[ep_id].pop;
		cp[0] = data;
		if (rem > 1)
			cp[1] = data >> 8;
 80009f6:	7051      	strb	r1, [r2, #1]
		if (rem > 2)
 80009f8:	d101      	bne.n	80009fe <stm32f_otg_dev_ep_pkt_recv+0x7e>
			cp[2] = data >> 16;
 80009fa:	0c1b      	lsrs	r3, r3, #16
 80009fc:	7093      	strb	r3, [r2, #2]
		rem = 0;
	}

	if ((rem = ep->xfr_rem - cnt) > 0) {
 80009fe:	f8ba 4004 	ldrh.w	r4, [sl, #4]
 8000a02:	ebcb 0404 	rsb	r4, fp, r4
 8000a06:	2c00      	cmp	r4, #0
 8000a08:	dd0c      	ble.n	8000a24 <stm32f_otg_dev_ep_pkt_recv+0xa4>
		DCC_LOG1(LOG_WARNING, "dropping %d bytes...", rem);
 8000a0a:	4621      	mov	r1, r4
 8000a0c:	480c      	ldr	r0, [pc, #48]	; (8000a40 <stm32f_otg_dev_ep_pkt_recv+0xc0>)
 8000a0e:	f003 fd01 	bl	8004414 <ice_trace1>
 8000a12:	f109 0101 	add.w	r1, r9, #1
		/* remove remaining data from fifo */
		do {
			data = otg_fs->dfifo[ep_id].pop;
 8000a16:	030b      	lsls	r3, r1, #12
 8000a18:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
			(void)data;
			rem -= 4;
 8000a1c:	3c04      	subs	r4, #4
		} while (rem > 0);
 8000a1e:	2c00      	cmp	r4, #0

	if ((rem = ep->xfr_rem - cnt) > 0) {
		DCC_LOG1(LOG_WARNING, "dropping %d bytes...", rem);
		/* remove remaining data from fifo */
		do {
			data = otg_fs->dfifo[ep_id].pop;
 8000a20:	681a      	ldr	r2, [r3, #0]
			(void)data;
			rem -= 4;
		} while (rem > 0);
 8000a22:	dcfb      	bgt.n	8000a1c <stm32f_otg_dev_ep_pkt_recv+0x9c>
	/* 5. After the data payload is popped from the receive FIFO, the 
	   RXFLVL interrupt (OTG_FS_GINTSTS) must be unmasked. */
	DCC_LOG1(LOG_INFO, "cnt=%d enabling RXFLVL interrupt", cnt);

	/* Reenable RX fifo interrupts */
	otg_fs->gintmsk |= OTG_FS_RXFLVLM;
 8000a24:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
			rem -= 4;
		} while (rem > 0);
	}

	/* reset transfer pointer */
	ep->xfr_rem = 0;
 8000a28:	2100      	movs	r1, #0
	/* 5. After the data payload is popped from the receive FIFO, the 
	   RXFLVL interrupt (OTG_FS_GINTSTS) must be unmasked. */
	DCC_LOG1(LOG_INFO, "cnt=%d enabling RXFLVL interrupt", cnt);

	/* Reenable RX fifo interrupts */
	otg_fs->gintmsk |= OTG_FS_RXFLVLM;
 8000a2a:	699a      	ldr	r2, [r3, #24]
			rem -= 4;
		} while (rem > 0);
	}

	/* reset transfer pointer */
	ep->xfr_rem = 0;
 8000a2c:	f8aa 1004 	strh.w	r1, [sl, #4]
	/* 5. After the data payload is popped from the receive FIFO, the 
	   RXFLVL interrupt (OTG_FS_GINTSTS) must be unmasked. */
	DCC_LOG1(LOG_INFO, "cnt=%d enabling RXFLVL interrupt", cnt);

	/* Reenable RX fifo interrupts */
	otg_fs->gintmsk |= OTG_FS_RXFLVLM;
 8000a30:	f042 0210 	orr.w	r2, r2, #16
 8000a34:	619a      	str	r2, [r3, #24]

	return cnt;
}
 8000a36:	4658      	mov	r0, fp
 8000a38:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	
	/* transfer data from fifo */
	cnt = MIN(ep->xfr_rem, len);

	rem = cnt;
	while (rem >= 4) {
 8000a3c:	4658      	mov	r0, fp
 8000a3e:	e7cd      	b.n	80009dc <stm32f_otg_dev_ep_pkt_recv+0x5c>
 8000a40:	40000030 	.word	0x40000030

08000a44 <__ep_tx_push.constprop.5>:
		*dst++ = data >> 16;
		*dst++ = data >> 24;
	}
}

static bool __ep_tx_push(struct stm32f_otg_drv * drv, int ep_id)
 8000a44:	b538      	push	{r3, r4, r5, lr}
{
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];
 8000a46:	4b13      	ldr	r3, [pc, #76]	; (8000a94 <__ep_tx_push.constprop.5+0x50>)
 8000a48:	eb00 0440 	add.w	r4, r0, r0, lsl #1
 8000a4c:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		*dst++ = data >> 16;
		*dst++ = data >> 24;
	}
}

static bool __ep_tx_push(struct stm32f_otg_drv * drv, int ep_id)
 8000a50:	4605      	mov	r5, r0
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	int cnt;

	/* push data into transmit fifo */
	cnt = stm32f_otg_fs_txf_push(otg_fs, ep_id, ep->xfr_ptr);
 8000a52:	4629      	mov	r1, r5
 8000a54:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8000a58:	68e2      	ldr	r2, [r4, #12]
 8000a5a:	f000 fea5 	bl	80017a8 <stm32f_otg_fs_txf_push>

	if (cnt < 0) {
 8000a5e:	2800      	cmp	r0, #0
 8000a60:	db07      	blt.n	8000a72 <__ep_tx_push.constprop.5+0x2e>
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_push() failed!");
		otg_fs->diepempmsk &= ~(1 << ep_id);
		return false;
	}

	ep->xfr_ptr += cnt;
 8000a62:	68e3      	ldr	r3, [r4, #12]
	ep->xfr_rem -= cnt;
 8000a64:	88a2      	ldrh	r2, [r4, #4]
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_push() failed!");
		otg_fs->diepempmsk &= ~(1 << ep_id);
		return false;
	}

	ep->xfr_ptr += cnt;
 8000a66:	181b      	adds	r3, r3, r0
	ep->xfr_rem -= cnt;
 8000a68:	1a10      	subs	r0, r2, r0
 8000a6a:	80a0      	strh	r0, [r4, #4]
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_push() failed!");
		otg_fs->diepempmsk &= ~(1 << ep_id);
		return false;
	}

	ep->xfr_ptr += cnt;
 8000a6c:	60e3      	str	r3, [r4, #12]
	ep->xfr_rem -= cnt;

	return true;
 8000a6e:	2001      	movs	r0, #1
}
 8000a70:	bd38      	pop	{r3, r4, r5, pc}

	/* push data into transmit fifo */
	cnt = stm32f_otg_fs_txf_push(otg_fs, ep_id, ep->xfr_ptr);

	if (cnt < 0) {
		DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_push() failed!");
 8000a72:	4809      	ldr	r0, [pc, #36]	; (8000a98 <__ep_tx_push.constprop.5+0x54>)
 8000a74:	f003 fca8 	bl	80043c8 <ice_trace0>
		otg_fs->diepempmsk &= ~(1 << ep_id);
 8000a78:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000a7c:	2101      	movs	r1, #1
 8000a7e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8000a82:	fa01 f505 	lsl.w	r5, r1, r5
 8000a86:	ea22 0505 	bic.w	r5, r2, r5
 8000a8a:	f8c3 5834 	str.w	r5, [r3, #2100]	; 0x834
 8000a8e:	2000      	movs	r0, #0
 8000a90:	bd38      	pop	{r3, r4, r5, pc}
 8000a92:	bf00      	nop
 8000a94:	2000000c 	.word	0x2000000c
 8000a98:	40000040 	.word	0x40000040

08000a9c <__ep_pktbuf_alloc>:

#define OTG_FS_RX_FIFO_SIZE 512

/* EP TX fifo memory allocation */
void __ep_pktbuf_alloc(struct stm32f_otg_drv * drv, int ep_id, int siz)
{
 8000a9c:	b410      	push	{r4}
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	switch (ep_id) {
 8000a9e:	2903      	cmp	r1, #3
 8000aa0:	d811      	bhi.n	8000ac6 <__ep_pktbuf_alloc+0x2a>
 8000aa2:	e8df f001 	tbb	[pc, r1]
 8000aa6:	3702      	.short	0x3702
 8000aa8:	1727      	.short	0x1727
	case 0:
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
			OTG_FS_TX0FSA_SET(drv->fifo_addr / 4);
 8000aaa:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	switch (ep_id) {
	case 0:
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
 8000aae:	1cd1      	adds	r1, r2, #3
 8000ab0:	ea11 0122 	ands.w	r1, r1, r2, asr #32
 8000ab4:	bf38      	it	cc
 8000ab6:	4611      	movcc	r1, r2
			OTG_FS_TX0FSA_SET(drv->fifo_addr / 4);
 8000ab8:	089b      	lsrs	r3, r3, #2
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	switch (ep_id) {
	case 0:
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
 8000aba:	1089      	asrs	r1, r1, #2
 8000abc:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000ac0:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000ac4:	6299      	str	r1, [r3, #40]	; 0x28
 8000ac6:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
		break;
	}

	DCC_LOG2(LOG_INFO, "addr=%d siz=%d", drv->fifo_addr, siz);

	drv->fifo_addr += siz;
 8000aca:	189a      	adds	r2, r3, r2
 8000acc:	f8a0 2070 	strh.w	r2, [r0, #112]	; 0x70
}
 8000ad0:	bc10      	pop	{r4}
 8000ad2:	4770      	bx	lr
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 3:
		otg_fs->dieptxf3 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000ad4:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
	case 2:
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 3:
		otg_fs->dieptxf3 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000ad8:	1cd4      	adds	r4, r2, #3
 8000ada:	ea14 0422 	ands.w	r4, r4, r2, asr #32
 8000ade:	bf38      	it	cc
 8000ae0:	4614      	movcc	r4, r2
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000ae2:	0899      	lsrs	r1, r3, #2
	case 2:
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 3:
		otg_fs->dieptxf3 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000ae4:	10a4      	asrs	r4, r4, #2
 8000ae6:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8000aea:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
 8000aee:	f8c1 410c 	str.w	r4, [r1, #268]	; 0x10c
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
 8000af2:	e7ea      	b.n	8000aca <__ep_pktbuf_alloc+0x2e>
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 2:
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000af4:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
	case 1:
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 2:
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000af8:	1cd4      	adds	r4, r2, #3
 8000afa:	ea14 0422 	ands.w	r4, r4, r2, asr #32
 8000afe:	bf38      	it	cc
 8000b00:	4614      	movcc	r4, r2
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000b02:	0899      	lsrs	r1, r3, #2
	case 1:
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
	case 2:
		otg_fs->dieptxf2 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000b04:	10a4      	asrs	r4, r4, #2
 8000b06:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8000b0a:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
 8000b0e:	f8c1 4108 	str.w	r4, [r1, #264]	; 0x108
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
 8000b12:	e7da      	b.n	8000aca <__ep_pktbuf_alloc+0x2e>
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
			OTG_FS_TX0FSA_SET(drv->fifo_addr / 4);
		break;
	case 1:
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000b14:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
	case 0:
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
			OTG_FS_TX0FSA_SET(drv->fifo_addr / 4);
		break;
	case 1:
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000b18:	1cd4      	adds	r4, r2, #3
 8000b1a:	ea14 0422 	ands.w	r4, r4, r2, asr #32
 8000b1e:	bf38      	it	cc
 8000b20:	4614      	movcc	r4, r2
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
 8000b22:	0899      	lsrs	r1, r3, #2
	case 0:
		otg_fs->dieptxf0 = OTG_FS_TX0FD_SET(siz / 4) | 
			OTG_FS_TX0FSA_SET(drv->fifo_addr / 4);
		break;
	case 1:
		otg_fs->dieptxf1 = OTG_FS_INEPTXFD_SET(siz / 4) | 
 8000b24:	10a4      	asrs	r4, r4, #2
 8000b26:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
 8000b2a:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
 8000b2e:	f8c1 4104 	str.w	r4, [r1, #260]	; 0x104
			OTG_FS_INEPTXSA_SET(drv->fifo_addr / 4);
		break;
 8000b32:	e7ca      	b.n	8000aca <__ep_pktbuf_alloc+0x2e>

08000b34 <stm32f_otg_dev_ep_init>:
}

int stm32f_otg_dev_ep_init(struct stm32f_otg_drv * drv, 
						   const usb_dev_ep_info_t * info, 
						   void * xfr_buf, int buf_len)
{
 8000b34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep;
	int mxpktsz = info->mxpktsz;
	int ep_id;

	if ((ep_id = info->addr & 0x7f) > 3) {
 8000b38:	780c      	ldrb	r4, [r1, #0]
						   const usb_dev_ep_info_t * info, 
						   void * xfr_buf, int buf_len)
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep;
	int mxpktsz = info->mxpktsz;
 8000b3a:	884f      	ldrh	r7, [r1, #2]
	int ep_id;

	if ((ep_id = info->addr & 0x7f) > 3) {
 8000b3c:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 8000b40:	2c03      	cmp	r4, #3
}

int stm32f_otg_dev_ep_init(struct stm32f_otg_drv * drv, 
						   const usb_dev_ep_info_t * info, 
						   void * xfr_buf, int buf_len)
{
 8000b42:	460e      	mov	r6, r1
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep;
	int mxpktsz = info->mxpktsz;
 8000b44:	46b8      	mov	r8, r7
	int ep_id;

	if ((ep_id = info->addr & 0x7f) > 3) {
 8000b46:	f300 80cd 	bgt.w	8000ce4 <stm32f_otg_dev_ep_init+0x1b0>
	}

	DCC_LOG3(LOG_INFO, "ep_id=%d addr=%d mxpktsz=%d", 
			 ep_id, info->addr & 0x7f, mxpktsz);

	ep = &drv->ep[ep_id];
 8000b4a:	eb04 0944 	add.w	r9, r4, r4, lsl #1
 8000b4e:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8000b52:	eb00 0509 	add.w	r5, r0, r9
	ep->xfr_buf = (uint8_t *)xfr_buf;
	ep->xfr_buf_len = buf_len;
	ep->xfr_ptr = NULL;
	ep->xfr_rem = 0;
	ep->state = EP_IDLE;
 8000b56:	2101      	movs	r1, #1
 8000b58:	f800 1009 	strb.w	r1, [r0, r9]
			 ep_id, info->addr & 0x7f, mxpktsz);

	ep = &drv->ep[ep_id];
	ep->xfr_buf = (uint8_t *)xfr_buf;
	ep->xfr_buf_len = buf_len;
	ep->xfr_ptr = NULL;
 8000b5c:	f04f 0c00 	mov.w	ip, #0
	DCC_LOG3(LOG_INFO, "ep_id=%d addr=%d mxpktsz=%d", 
			 ep_id, info->addr & 0x7f, mxpktsz);

	ep = &drv->ep[ep_id];
	ep->xfr_buf = (uint8_t *)xfr_buf;
	ep->xfr_buf_len = buf_len;
 8000b60:	80eb      	strh	r3, [r5, #6]

	DCC_LOG3(LOG_INFO, "ep_id=%d addr=%d mxpktsz=%d", 
			 ep_id, info->addr & 0x7f, mxpktsz);

	ep = &drv->ep[ep_id];
	ep->xfr_buf = (uint8_t *)xfr_buf;
 8000b62:	60aa      	str	r2, [r5, #8]
	ep->xfr_buf_len = buf_len;
	ep->xfr_ptr = NULL;
 8000b64:	f8c5 c00c 	str.w	ip, [r5, #12]
	ep->xfr_rem = 0;
 8000b68:	f8a5 c004 	strh.w	ip, [r5, #4]
	ep->state = EP_IDLE;
	ep->on_ev = info->on_ev;
 8000b6c:	6872      	ldr	r2, [r6, #4]

	/* mask FIFO empty interrupt */
	otg_fs->diepempmsk &= ~(1 << ep_id);
 8000b6e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
	ep->xfr_buf = (uint8_t *)xfr_buf;
	ep->xfr_buf_len = buf_len;
	ep->xfr_ptr = NULL;
	ep->xfr_rem = 0;
	ep->state = EP_IDLE;
	ep->on_ev = info->on_ev;
 8000b72:	616a      	str	r2, [r5, #20]

	/* mask FIFO empty interrupt */
	otg_fs->diepempmsk &= ~(1 << ep_id);
 8000b74:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8000b78:	fa01 f904 	lsl.w	r9, r1, r4
 8000b7c:	ea22 0209 	bic.w	r2, r2, r9
 8000b80:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834

	if (ep_id == 0) {
 8000b84:	2c00      	cmp	r4, #0
 8000b86:	d056      	beq.n	8000c36 <stm32f_otg_dev_ep_init+0x102>
				 OTG_FS_TX0FSA_GET(otg_fs->dieptxf0) * 4,
				 OTG_FS_TX0FD_GET(otg_fs->dieptxf0) * 4);
	} else {
		uint32_t depctl;

		if (info->addr & USB_ENDPOINT_IN) {
 8000b88:	f996 1000 	ldrsb.w	r1, [r6]
 8000b8c:	2900      	cmp	r1, #0
 8000b8e:	db7a      	blt.n	8000c86 <stm32f_otg_dev_ep_init+0x152>

			__ep_pktbuf_alloc(drv, ep_id, ep->xfr_max);
			depctl = otg_fs->inep[ep_id].diepctl;
		} else {
			DCC_LOG(LOG_INFO, "OUT ENDPOINT");
			depctl = otg_fs->outep[ep_id].doepctl;
 8000b90:	f104 0358 	add.w	r3, r4, #88	; 0x58
 8000b94:	015b      	lsls	r3, r3, #5
 8000b96:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
 8000b9a:	681f      	ldr	r7, [r3, #0]
		}

		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);
 8000b9c:	f44f 4378 	mov.w	r3, #63488	; 0xf800

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;

		switch (info->attr & 0x03) {
 8000ba0:	7870      	ldrb	r0, [r6, #1]
		} else {
			DCC_LOG(LOG_INFO, "OUT ENDPOINT");
			depctl = otg_fs->outep[ep_id].doepctl;
		}

		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);
 8000ba2:	f6cf 4333 	movt	r3, #64563	; 0xfc33

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
 8000ba6:	ea4f 5248 	mov.w	r2, r8, lsl #21
 8000baa:	0d52      	lsrs	r2, r2, #21
		} else {
			DCC_LOG(LOG_INFO, "OUT ENDPOINT");
			depctl = otg_fs->outep[ep_id].doepctl;
		}

		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);
 8000bac:	403b      	ands	r3, r7

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;

		switch (info->attr & 0x03) {
 8000bae:	f000 0003 	and.w	r0, r0, #3
			depctl = otg_fs->outep[ep_id].doepctl;
		}

		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
 8000bb2:	4313      	orrs	r3, r2
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_ISOC);
			break;

		case ENDPOINT_TYPE_BULK:
			DCC_LOG(LOG_INFO, "ENDPOINT_TYPE_BULK");
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_BULK);
 8000bb4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;

		switch (info->attr & 0x03) {
 8000bb8:	2802      	cmp	r0, #2
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_ISOC);
			break;

		case ENDPOINT_TYPE_BULK:
			DCC_LOG(LOG_INFO, "ENDPOINT_TYPE_BULK");
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_BULK);
 8000bba:	bf08      	it	eq
 8000bbc:	f443 2308 	orreq.w	r3, r3, #557056	; 0x88000
		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;

		switch (info->attr & 0x03) {
 8000bc0:	d00a      	beq.n	8000bd8 <stm32f_otg_dev_ep_init+0xa4>
 8000bc2:	2803      	cmp	r0, #3
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_BULK);
			break;

		case ENDPOINT_TYPE_INTERRUPT:
			DCC_LOG(LOG_INFO, "ENDPOINT_TYPE_INTERRUPT");
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_INT);
 8000bc4:	bf08      	it	eq
 8000bc6:	f443 2348 	orreq.w	r3, r3, #819200	; 0xc8000
		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;

		switch (info->attr & 0x03) {
 8000bca:	d005      	beq.n	8000bd8 <stm32f_otg_dev_ep_init+0xa4>
 8000bcc:	2801      	cmp	r0, #1
		}

		depctl &= ~(OTG_FS_MPSIZ_MSK | OTG_FS_EPTYP_MSK | OTG_FS_TXFNUM_MSK);

		depctl |= OTG_FS_MPSIZ_SET(mxpktsz);
		depctl |= OTG_FS_SD0PID | OTG_FS_USBAEP;
 8000bce:	bf14      	ite	ne
 8000bd0:	f443 4300 	orrne.w	r3, r3, #32768	; 0x8000
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_CTRL);
			break;

		case ENDPOINT_TYPE_ISOCHRONOUS:
			DCC_LOG(LOG_INFO, "ENDPOINT_TYPE_ISOCHRONOUS");
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_ISOC);
 8000bd4:	f443 2390 	orreq.w	r3, r3, #294912	; 0x48000
			DCC_LOG(LOG_INFO, "ENDPOINT_TYPE_INTERRUPT");
			depctl |= OTG_FS_EPTYP_SET(OTG_FS_EPTYP_INT);
			break;
		}

		if (info->addr & USB_ENDPOINT_IN) {
 8000bd8:	2900      	cmp	r1, #0
 8000bda:	db68      	blt.n	8000cae <stm32f_otg_dev_ep_init+0x17a>
		} else {
			uint32_t rxfsiz;
			uint32_t pktcnt;

			/* get the size of the RX fifio */
			rxfsiz = otg_fs->grxfsiz * 4;
 8000bdc:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000be0:	2100      	movs	r1, #0
		} else {
			uint32_t rxfsiz;
			uint32_t pktcnt;

			/* get the size of the RX fifio */
			rxfsiz = otg_fs->grxfsiz * 4;
 8000be2:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8000be4:	00b6      	lsls	r6, r6, #2

			pktcnt = rxfsiz / mxpktsz;
 8000be6:	fbb6 f6f8 	udiv	r6, r6, r8

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);
 8000bea:	fb08 f806 	mul.w	r8, r8, r6

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;

			/* EP enable */
			otg_fs->outep[ep_id].doepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK;
 8000bee:	f104 0c58 	add.w	ip, r4, #88	; 0x58
			rxfsiz = otg_fs->grxfsiz * 4;

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000bf2:	04f7      	lsls	r7, r6, #19
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);
 8000bf4:	f028 487f 	bic.w	r8, r8, #4278190080	; 0xff000000
			rxfsiz = otg_fs->grxfsiz * 4;

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000bf8:	f6c1 71f8 	movt	r1, #8184	; 0x1ff8
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;
 8000bfc:	0162      	lsls	r2, r4, #5

			/* EP enable */
			otg_fs->outep[ep_id].doepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK;
 8000bfe:	ea4f 164c 	mov.w	r6, ip, lsl #5
			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;
 8000c02:	1812      	adds	r2, r2, r0

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);
 8000c04:	f428 0878 	bic.w	r8, r8, #16252928	; 0xf80000
			rxfsiz = otg_fs->grxfsiz * 4;

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000c08:	4039      	ands	r1, r7

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;

			/* EP enable */
			otg_fs->outep[ep_id].doepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK;
 8000c0a:	1836      	adds	r6, r6, r0
			rxfsiz = otg_fs->grxfsiz * 4;

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000c0c:	ea48 0101 	orr.w	r1, r8, r1

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;

			/* EP enable */
			otg_fs->outep[ep_id].doepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK;
 8000c10:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
			rxfsiz = otg_fs->grxfsiz * 4;

			pktcnt = rxfsiz / mxpktsz;

			/* cache this value to be reused */
			ep->doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8000c14:	6129      	str	r1, [r5, #16]
				OTG_FS_XFRSIZ_SET(pktcnt * mxpktsz);

			/* Prepare EP_OUT to receive */
			otg_fs->outep[ep_id].doeptsiz = ep->doeptsiz;
 8000c16:	f8c2 1b10 	str.w	r1, [r2, #2832]	; 0xb10

			/* EP enable */
			otg_fs->outep[ep_id].doepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK;
 8000c1a:	6033      	str	r3, [r6, #0]

			/* Enable endpoint interrupt */
			otg_fs->daintmsk |= OTG_FS_OEPM(ep_id);
 8000c1c:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 8000c20:	f104 0310 	add.w	r3, r4, #16
 8000c24:	2101      	movs	r1, #1
 8000c26:	fa01 f303 	lsl.w	r3, r1, r3
 8000c2a:	4313      	orrs	r3, r2
 8000c2c:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
	   tokens addressed to that endpoint and sends out a valid
	   handshake for each valid token received for the
	   endpoint. */

	return ep_id;
}
 8000c30:	4620      	mov	r0, r4
 8000c32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (ep_id == 0) {
		ep->xfr_max = mxpktsz;

		/* Initialize EP0 */
		otg_fs->inep[0].diepctl = OTG_FS_TXFNUM_SET(0) |
 8000c36:	2f40      	cmp	r7, #64	; 0x40

	/* mask FIFO empty interrupt */
	otg_fs->diepempmsk &= ~(1 << ep_id);

	if (ep_id == 0) {
		ep->xfr_max = mxpktsz;
 8000c38:	806f      	strh	r7, [r5, #2]

		/* Initialize EP0 */
		otg_fs->inep[0].diepctl = OTG_FS_TXFNUM_SET(0) |
 8000c3a:	bf08      	it	eq
 8000c3c:	4623      	moveq	r3, r4
 8000c3e:	d007      	beq.n	8000c50 <stm32f_otg_dev_ep_init+0x11c>
 8000c40:	2f20      	cmp	r7, #32
 8000c42:	bf08      	it	eq
 8000c44:	460b      	moveq	r3, r1
 8000c46:	d003      	beq.n	8000c50 <stm32f_otg_dev_ep_init+0x11c>
 8000c48:	2f10      	cmp	r7, #16
 8000c4a:	bf14      	ite	ne
 8000c4c:	2303      	movne	r3, #3
 8000c4e:	2302      	moveq	r3, #2
 8000c50:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
		   data packet) + 10 Words (for setup packets).
		   - Program the OTG_FS_TX0FSIZ register (depending on the FIFO number
		   chosen) to be able to transmit control IN data. At a minimum, this
		   must be equal to 1 max packet size of control endpoint 0. */

		__ep_pktbuf_alloc(drv, 0, mxpktsz);
 8000c54:	2100      	movs	r1, #0

	if (ep_id == 0) {
		ep->xfr_max = mxpktsz;

		/* Initialize EP0 */
		otg_fs->inep[0].diepctl = OTG_FS_TXFNUM_SET(0) |
 8000c56:	f8c6 3900 	str.w	r3, [r6, #2304]	; 0x900
		   data packet) + 10 Words (for setup packets).
		   - Program the OTG_FS_TX0FSIZ register (depending on the FIFO number
		   chosen) to be able to transmit control IN data. At a minimum, this
		   must be equal to 1 max packet size of control endpoint 0. */

		__ep_pktbuf_alloc(drv, 0, mxpktsz);
 8000c5a:	463a      	mov	r2, r7
 8000c5c:	f7ff ff1e 	bl	8000a9c <__ep_pktbuf_alloc>
			SETUP packets)
			At this point, all initialization required to receive SETUP packets
			is done. */

		/* cache this value to be reused */
		ep->doeptsiz = OTG_FS_STUPCNT_SET(3) | 
 8000c60:	2328      	movs	r3, #40	; 0x28
 8000c62:	f2c6 0308 	movt	r3, #24584	; 0x6008
 8000c66:	612b      	str	r3, [r5, #16]
			OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(40);

		/* Prepare to receive */
		otg_fs->outep[0].doeptsiz = ep->doeptsiz;
 8000c68:	f8c6 3b10 	str.w	r3, [r6, #2832]	; 0xb10
		/* EP enable */
		otg_fs->outep[0].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8000c6c:	f8d6 3b00 	ldr.w	r3, [r6, #2816]	; 0xb00
 8000c70:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8000c74:	f8c6 3b00 	str.w	r3, [r6, #2816]	; 0xb00

		/* Unmask EP0 interrupts */
		otg_fs->daintmsk = OTG_FS_IEPM0 | OTG_FS_OEPM0;
 8000c78:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8000c7c:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
	   tokens addressed to that endpoint and sends out a valid
	   handshake for each valid token received for the
	   endpoint. */

	return ep_id;
}
 8000c80:	4620      	mov	r0, r4
 8000c82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		uint32_t depctl;

		if (info->addr & USB_ENDPOINT_IN) {
			DCC_LOG(LOG_INFO, "IN ENDPOINT");

			if ((info->attr & 0x03) == ENDPOINT_TYPE_BULK) {
 8000c86:	7873      	ldrb	r3, [r6, #1]
 8000c88:	f003 0303 	and.w	r3, r3, #3
 8000c8c:	2b02      	cmp	r3, #2
				ep->xfr_max = 6 * mxpktsz;
			} else {
				ep->xfr_max = mxpktsz;
 8000c8e:	bf18      	it	ne
 8000c90:	806f      	strhne	r7, [r5, #2]
		uint32_t depctl;

		if (info->addr & USB_ENDPOINT_IN) {
			DCC_LOG(LOG_INFO, "IN ENDPOINT");

			if ((info->attr & 0x03) == ENDPOINT_TYPE_BULK) {
 8000c92:	d021      	beq.n	8000cd8 <stm32f_otg_dev_ep_init+0x1a4>
				ep->xfr_max = 6 * mxpktsz;
			} else {
				ep->xfr_max = mxpktsz;
			}

			__ep_pktbuf_alloc(drv, ep_id, ep->xfr_max);
 8000c94:	4621      	mov	r1, r4
 8000c96:	463a      	mov	r2, r7
 8000c98:	f7ff ff00 	bl	8000a9c <__ep_pktbuf_alloc>
			depctl = otg_fs->inep[ep_id].diepctl;
 8000c9c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8000ca0:	015b      	lsls	r3, r3, #5
 8000ca2:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
 8000ca6:	f996 1000 	ldrsb.w	r1, [r6]
 8000caa:	681f      	ldr	r7, [r3, #0]
 8000cac:	e776      	b.n	8000b9c <stm32f_otg_dev_ep_init+0x68>
			break;
		}

		if (info->addr & USB_ENDPOINT_IN) {
			/* Activate IN endpoint */
			otg_fs->inep[ep_id].diepctl = depctl | OTG_FS_TXFNUM_SET(ep_id);
 8000cae:	f104 0148 	add.w	r1, r4, #72	; 0x48
 8000cb2:	05a0      	lsls	r0, r4, #22
 8000cb4:	0149      	lsls	r1, r1, #5
 8000cb6:	f000 7070 	and.w	r0, r0, #62914560	; 0x3c00000
 8000cba:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
 8000cbe:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000cc2:	4303      	orrs	r3, r0
 8000cc4:	600b      	str	r3, [r1, #0]

			/* Enable endpoint interrupt */
			otg_fs->daintmsk |= OTG_FS_IEPM(ep_id);
 8000cc6:	f8d2 381c 	ldr.w	r3, [r2, #2076]	; 0x81c
 8000cca:	ea49 0303 	orr.w	r3, r9, r3
 8000cce:	f8c2 381c 	str.w	r3, [r2, #2076]	; 0x81c
	   tokens addressed to that endpoint and sends out a valid
	   handshake for each valid token received for the
	   endpoint. */

	return ep_id;
}
 8000cd2:	4620      	mov	r0, r4
 8000cd4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		if (info->addr & USB_ENDPOINT_IN) {
			DCC_LOG(LOG_INFO, "IN ENDPOINT");

			if ((info->attr & 0x03) == ENDPOINT_TYPE_BULK) {
				ep->xfr_max = 6 * mxpktsz;
 8000cd8:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8000cdc:	007f      	lsls	r7, r7, #1
 8000cde:	b2bf      	uxth	r7, r7
 8000ce0:	806f      	strh	r7, [r5, #2]
 8000ce2:	e7d7      	b.n	8000c94 <stm32f_otg_dev_ep_init+0x160>
	struct stm32f_otg_ep * ep;
	int mxpktsz = info->mxpktsz;
	int ep_id;

	if ((ep_id = info->addr & 0x7f) > 3) {
		DCC_LOG1(LOG_ERROR, "invalid address addr=%d", ep_id);
 8000ce4:	4621      	mov	r1, r4
 8000ce6:	4803      	ldr	r0, [pc, #12]	; (8000cf4 <stm32f_otg_dev_ep_init+0x1c0>)
 8000ce8:	f003 fb94 	bl	8004414 <ice_trace1>
		return -1;
 8000cec:	f04f 34ff 	mov.w	r4, #4294967295
 8000cf0:	e79e      	b.n	8000c30 <stm32f_otg_dev_ep_init+0xfc>
 8000cf2:	bf00      	nop
 8000cf4:	40000050 	.word	0x40000050

08000cf8 <otg_fs_vbus_connect>:
	stm32_gpio_mode(OTG_FS_ID, ALT_FUNC, PUSH_PULL | SPEED_HIGH);
}

void otg_fs_vbus_connect(bool connect)
{
	if (connect)
 8000cf8:	4602      	mov	r2, r0
		stm32_gpio_mode(OTG_FS_VBUS, ALT_FUNC, SPEED_LOW);
 8000cfa:	2000      	movs	r0, #0
 8000cfc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000d00:	2109      	movs	r1, #9
	stm32_gpio_mode(OTG_FS_ID, ALT_FUNC, PUSH_PULL | SPEED_HIGH);
}

void otg_fs_vbus_connect(bool connect)
{
	if (connect)
 8000d02:	b912      	cbnz	r2, 8000d0a <otg_fs_vbus_connect+0x12>
		stm32_gpio_mode(OTG_FS_VBUS, ALT_FUNC, SPEED_LOW);
	else
		stm32_gpio_mode(OTG_FS_VBUS, INPUT, 0);
 8000d04:	4613      	mov	r3, r2
 8000d06:	f7ff bcd1 	b.w	80006ac <stm32_gpio_mode>
}

void otg_fs_vbus_connect(bool connect)
{
	if (connect)
		stm32_gpio_mode(OTG_FS_VBUS, ALT_FUNC, SPEED_LOW);
 8000d0a:	2202      	movs	r2, #2
 8000d0c:	2300      	movs	r3, #0
 8000d0e:	f7ff bccd 	b.w	80006ac <stm32_gpio_mode>
 8000d12:	bf00      	nop

08000d14 <otg_fs_connect>:
	else
		stm32_gpio_mode(OTG_FS_VBUS, INPUT, 0);
}

void otg_fs_connect(struct stm32f_otg_fs * otg_fs)
{
 8000d14:	4603      	mov	r3, r0
	/* Connect device */
	otg_fs->dctl &= ~OTG_FS_SDIS;
	udelay(3000);
 8000d16:	f640 30b8 	movw	r0, #3000	; 0xbb8
}

void otg_fs_connect(struct stm32f_otg_fs * otg_fs)
{
	/* Connect device */
	otg_fs->dctl &= ~OTG_FS_SDIS;
 8000d1a:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 8000d1e:	f022 0202 	bic.w	r2, r2, #2
 8000d22:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
	udelay(3000);
 8000d26:	f000 be53 	b.w	80019d0 <udelay>
 8000d2a:	bf00      	nop

08000d2c <otg_fs_disconnect>:
}

void otg_fs_disconnect(struct stm32f_otg_fs * otg_fs)
{
 8000d2c:	4603      	mov	r3, r0
	otg_fs->dctl |= OTG_FS_SDIS;
	udelay(3000);
 8000d2e:	f640 30b8 	movw	r0, #3000	; 0xbb8
	udelay(3000);
}

void otg_fs_disconnect(struct stm32f_otg_fs * otg_fs)
{
	otg_fs->dctl |= OTG_FS_SDIS;
 8000d32:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 8000d36:	f042 0202 	orr.w	r2, r2, #2
 8000d3a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
	udelay(3000);
 8000d3e:	f000 be47 	b.w	80019d0 <udelay>
 8000d42:	bf00      	nop

08000d44 <otg_fs_power_on>:
}

void otg_fs_power_on(struct stm32f_otg_fs * otg_fs)
{
 8000d44:	b510      	push	{r4, lr}
 8000d46:	4604      	mov	r4, r0
	struct stm32_rcc * rcc = STM32_RCC;

	otg_fs_vbus_connect(true);
 8000d48:	2001      	movs	r0, #1
 8000d4a:	f7ff ffd5 	bl	8000cf8 <otg_fs_vbus_connect>

	DCC_LOG(LOG_INFO, "Enabling USB FS clock...");
	rcc->ahb2enr |= RCC_OTGFSEN;
 8000d4e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000d52:	f2c4 0302 	movt	r3, #16386	; 0x4002

	/* Initialize as a device */
	stm32f_otg_fs_device_init(otg_fs);
 8000d56:	4620      	mov	r0, r4
	struct stm32_rcc * rcc = STM32_RCC;

	otg_fs_vbus_connect(true);

	DCC_LOG(LOG_INFO, "Enabling USB FS clock...");
	rcc->ahb2enr |= RCC_OTGFSEN;
 8000d58:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000d5a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000d5e:	635a      	str	r2, [r3, #52]	; 0x34

	/* Initialize as a device */
	stm32f_otg_fs_device_init(otg_fs);
 8000d60:	f000 fd6c 	bl	800183c <stm32f_otg_fs_device_init>

	otg_fs_connect(otg_fs);
 8000d64:	4620      	mov	r0, r4
 8000d66:	f7ff ffd5 	bl	8000d14 <otg_fs_connect>
extern "C" {
#endif

/* Enable Interrupt in NVIC Interrupt Controller */
static inline void __attribute__((always_inline)) cm3_irq_enable(int irq) {
	CM3_NVIC->iser[irq >> 5] = (1 << (irq & 0x1f));
 8000d6a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8000d6e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000d72:	2208      	movs	r2, #8
 8000d74:	609a      	str	r2, [r3, #8]
 8000d76:	bd10      	pop	{r4, pc}

08000d78 <otg_fs_power_off>:
	/* Enable Cortex interrupt */
	cm3_irq_enable(STM32F_IRQ_OTG_FS);
}

void otg_fs_power_off(struct stm32f_otg_fs * otg_fs)
{
 8000d78:	b570      	push	{r4, r5, r6, lr}
	struct stm32_rcc * rcc = STM32_RCC;

//	usb->cntr = USB_FRES;
	/* Removing any spurious pending interrupts */
//	usb->istr = 0;
	otg_fs_disconnect(otg_fs);
 8000d7a:	f7ff ffd7 	bl	8000d2c <otg_fs_disconnect>
//	otg_fs_vbus_connect(false);

//	usb->cntr = USB_FRES | USB_PDWN;

	DCC_LOG(LOG_INFO, "Disabling USB device clock...");
	rcc->ahb2enr &= ~RCC_OTGFSEN;
 8000d7e:	f44f 5060 	mov.w	r0, #14336	; 0x3800
 8000d82:	f2c4 0002 	movt	r0, #16386	; 0x4002

	/* disabling IO pins */
	stm32_gpio_mode(OTG_FS_DP, INPUT, 0);
 8000d86:	2400      	movs	r4, #0
//	otg_fs_vbus_connect(false);

//	usb->cntr = USB_FRES | USB_PDWN;

	DCC_LOG(LOG_INFO, "Disabling USB device clock...");
	rcc->ahb2enr &= ~RCC_OTGFSEN;
 8000d88:	6b45      	ldr	r5, [r0, #52]	; 0x34

	/* disabling IO pins */
	stm32_gpio_mode(OTG_FS_DP, INPUT, 0);
 8000d8a:	4622      	mov	r2, r4
//	otg_fs_vbus_connect(false);

//	usb->cntr = USB_FRES | USB_PDWN;

	DCC_LOG(LOG_INFO, "Disabling USB device clock...");
	rcc->ahb2enr &= ~RCC_OTGFSEN;
 8000d8c:	f025 0580 	bic.w	r5, r5, #128	; 0x80

	/* disabling IO pins */
	stm32_gpio_mode(OTG_FS_DP, INPUT, 0);
 8000d90:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8000d94:	4613      	mov	r3, r2
 8000d96:	210c      	movs	r1, #12
//	otg_fs_vbus_connect(false);

//	usb->cntr = USB_FRES | USB_PDWN;

	DCC_LOG(LOG_INFO, "Disabling USB device clock...");
	rcc->ahb2enr &= ~RCC_OTGFSEN;
 8000d98:	6345      	str	r5, [r0, #52]	; 0x34

	/* disabling IO pins */
	stm32_gpio_mode(OTG_FS_DP, INPUT, 0);
 8000d9a:	4620      	mov	r0, r4
 8000d9c:	f7ff fc86 	bl	80006ac <stm32_gpio_mode>
	stm32_gpio_mode(OTG_FS_DM, INPUT, 0);
 8000da0:	2200      	movs	r2, #0
 8000da2:	4620      	mov	r0, r4
 8000da4:	210b      	movs	r1, #11
 8000da6:	4613      	mov	r3, r2

}
 8000da8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DCC_LOG(LOG_INFO, "Disabling USB device clock...");
	rcc->ahb2enr &= ~RCC_OTGFSEN;

	/* disabling IO pins */
	stm32_gpio_mode(OTG_FS_DP, INPUT, 0);
	stm32_gpio_mode(OTG_FS_DM, INPUT, 0);
 8000dac:	f7ff bc7e 	b.w	80006ac <stm32_gpio_mode>

08000db0 <stm32f_otg_fs_dev_init>:

}

int stm32f_otg_fs_dev_init(struct stm32f_otg_drv * drv, usb_class_t * cl,
		const usb_class_events_t * ev)
{
 8000db0:	b510      	push	{r4, lr}
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	drv->cl = cl;
 8000db2:	6601      	str	r1, [r0, #96]	; 0x60
	drv->ev = ev;
 8000db4:	6642      	str	r2, [r0, #100]	; 0x64
#define OTG_FS_ID STM32_GPIOA, 10

static void otg_fs_io_init(void)
{
	DCC_LOG(LOG_MSG, "Enabling GPIO clock...");
	stm32_gpio_clock_en(STM32_GPIOA);
 8000db6:	2400      	movs	r4, #0
	drv->cl = cl;
	drv->ev = ev;

	DCC_LOG1(LOG_INFO, "ev=0x%08x", drv->ev);

	otg_fs_power_off(otg_fs);
 8000db8:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
#define OTG_FS_ID STM32_GPIOA, 10

static void otg_fs_io_init(void)
{
	DCC_LOG(LOG_MSG, "Enabling GPIO clock...");
	stm32_gpio_clock_en(STM32_GPIOA);
 8000dbc:	f2c4 0402 	movt	r4, #16386	; 0x4002
	drv->cl = cl;
	drv->ev = ev;

	DCC_LOG1(LOG_INFO, "ev=0x%08x", drv->ev);

	otg_fs_power_off(otg_fs);
 8000dc0:	f7ff ffda 	bl	8000d78 <otg_fs_power_off>

	udelay(10000);
 8000dc4:	f242 7010 	movw	r0, #10000	; 0x2710
 8000dc8:	f000 fe02 	bl	80019d0 <udelay>
#define OTG_FS_ID STM32_GPIOA, 10

static void otg_fs_io_init(void)
{
	DCC_LOG(LOG_MSG, "Enabling GPIO clock...");
	stm32_gpio_clock_en(STM32_GPIOA);
 8000dcc:	4620      	mov	r0, r4
 8000dce:	f7ff fc5d 	bl	800068c <stm32_gpio_clock_en>

	DCC_LOG(LOG_MSG, "Configuring GPIO pins...");

	stm32_gpio_af(OTG_FS_DP, GPIO_AF10);
 8000dd2:	4620      	mov	r0, r4
 8000dd4:	210c      	movs	r1, #12
 8000dd6:	220a      	movs	r2, #10
 8000dd8:	f7ff fca6 	bl	8000728 <stm32_gpio_af>
	stm32_gpio_af(OTG_FS_DM, GPIO_AF10);
 8000ddc:	4620      	mov	r0, r4
 8000dde:	210b      	movs	r1, #11
 8000de0:	220a      	movs	r2, #10
 8000de2:	f7ff fca1 	bl	8000728 <stm32_gpio_af>
	stm32_gpio_af(OTG_FS_VBUS, GPIO_AF10);
 8000de6:	4620      	mov	r0, r4
 8000de8:	2109      	movs	r1, #9
 8000dea:	220a      	movs	r2, #10
 8000dec:	f7ff fc9c 	bl	8000728 <stm32_gpio_af>
	stm32_gpio_af(OTG_FS_ID, GPIO_AF10);
 8000df0:	210a      	movs	r1, #10
 8000df2:	4620      	mov	r0, r4
 8000df4:	460a      	mov	r2, r1
 8000df6:	f7ff fc97 	bl	8000728 <stm32_gpio_af>

	stm32_gpio_mode(OTG_FS_DP, ALT_FUNC, PUSH_PULL | SPEED_HIGH);
 8000dfa:	4620      	mov	r0, r4
 8000dfc:	210c      	movs	r1, #12
 8000dfe:	2202      	movs	r2, #2
 8000e00:	2303      	movs	r3, #3
 8000e02:	f7ff fc53 	bl	80006ac <stm32_gpio_mode>
	stm32_gpio_mode(OTG_FS_DM, ALT_FUNC, PUSH_PULL | SPEED_HIGH);
 8000e06:	4620      	mov	r0, r4
 8000e08:	210b      	movs	r1, #11
 8000e0a:	2202      	movs	r2, #2
 8000e0c:	2303      	movs	r3, #3
 8000e0e:	f7ff fc4d 	bl	80006ac <stm32_gpio_mode>
	stm32_gpio_mode(OTG_FS_VBUS, ALT_FUNC, SPEED_LOW);
 8000e12:	4620      	mov	r0, r4
 8000e14:	2109      	movs	r1, #9
 8000e16:	2202      	movs	r2, #2
 8000e18:	2300      	movs	r3, #0
 8000e1a:	f7ff fc47 	bl	80006ac <stm32_gpio_mode>
	stm32_gpio_mode(OTG_FS_ID, ALT_FUNC, PUSH_PULL | SPEED_HIGH);
 8000e1e:	4620      	mov	r0, r4
 8000e20:	210a      	movs	r1, #10
 8000e22:	2202      	movs	r2, #2
 8000e24:	2303      	movs	r3, #3
 8000e26:	f7ff fc41 	bl	80006ac <stm32_gpio_mode>
	udelay(10000);

	/* Initialize IO pins */
	otg_fs_io_init();

	otg_fs_power_on(otg_fs);
 8000e2a:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8000e2e:	f7ff ff89 	bl	8000d44 <otg_fs_power_on>

	DCC_LOG(LOG_INFO, "[ATTACHED]");
	return 0;
}
 8000e32:	2000      	movs	r0, #0
 8000e34:	bd10      	pop	{r4, pc}
 8000e36:	bf00      	nop

08000e38 <stm32f_otg_fs_isr>:
	struct stm32f_otg_drv * drv = &stm32f_otg_fs_drv0;
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	uint32_t gintsts;
	uint32_t ep_intr;

	gintsts = otg_fs->gintsts & otg_fs->gintmsk;
 8000e38:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000

/* Private USB device driver data */
struct stm32f_otg_drv stm32f_otg_fs_drv0;

void stm32f_otg_fs_isr(void)
{
 8000e3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct stm32f_otg_drv * drv = &stm32f_otg_fs_drv0;
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	uint32_t gintsts;
	uint32_t ep_intr;

	gintsts = otg_fs->gintsts & otg_fs->gintmsk;
 8000e40:	695a      	ldr	r2, [r3, #20]
 8000e42:	699c      	ldr	r4, [r3, #24]
 8000e44:	4014      	ands	r4, r2

	DCC_LOG1(LOG_MSG, "GINTSTS=0x%08x", gintsts);

	if (gintsts & OTG_FS_SRQINT) {
 8000e46:	0062      	lsls	r2, r4, #1
		/* Session request/new session detected interrupt */
		DCC_LOG(LOG_INFO, "<SRQINT>  [POWERED]");
		otg_fs->gintmsk |= OTG_FS_WUIM | OTG_FS_USBRSTM | OTG_FS_ENUMDNEM |
 8000e48:	bf41      	itttt	mi
 8000e4a:	699a      	ldrmi	r2, [r3, #24]
 8000e4c:	f042 4200 	orrmi.w	r2, r2, #2147483648	; 0x80000000
 8000e50:	f442 5270 	orrmi.w	r2, r2, #15360	; 0x3c00
 8000e54:	619a      	strmi	r2, [r3, #24]

	if (gintsts & OTG_FS_PTXFE) {
		DCC_LOG(LOG_INFO, "<PTXFE>");
	}

	if (gintsts & OTG_FS_OTGINT) {
 8000e56:	0763      	lsls	r3, r4, #29
 8000e58:	d508      	bpl.n	8000e6c <stm32f_otg_fs_isr+0x34>
		uint32_t gotgint = otg_fs->gotgint;
 8000e5a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000e5e:	6853      	ldr	r3, [r2, #4]
		DCC_LOG(LOG_INFO, "<OTGINT>");
		if (gotgint & OTG_FS_OTGINT) {
 8000e60:	0758      	lsls	r0, r3, #29
 8000e62:	f100 8116 	bmi.w	8001092 <stm32f_otg_fs_isr+0x25a>
			DCC_LOG(LOG_INFO, "<SEDET>  [ATTACHED]");
			otg_fs->gintmsk = OTG_FS_SRQIM | OTG_FS_OTGINT;
		}
		otg_fs->gotgint = gotgint;
 8000e66:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000e6a:	6053      	str	r3, [r2, #4]
	}

	if (gintsts & OTG_FS_GONAKEFF) {
 8000e6c:	0621      	lsls	r1, r4, #24
		DCC_LOG(LOG_INFO, "<GONAKEFF>");
		otg_fs->gintmsk &= ~OTG_FS_GONAKEFFM;
 8000e6e:	bf41      	itttt	mi
 8000e70:	f04f 43a0 	movmi.w	r3, #1342177280	; 0x50000000
 8000e74:	699a      	ldrmi	r2, [r3, #24]
 8000e76:	f022 0280 	bicmi.w	r2, r2, #128	; 0x80
 8000e7a:	619a      	strmi	r2, [r3, #24]
	}

	/* RxFIFO non-empty */
	if (gintsts & OTG_FS_RXFLVL) {
 8000e7c:	06e2      	lsls	r2, r4, #27
 8000e7e:	d532      	bpl.n	8000ee6 <stm32f_otg_fs_isr+0xae>
		int stat;

		/* 1. On catching an RXFLVL interrupt (OTG_FS_GINTSTS register),
		   the application must read the Receive status pop
		   register (OTG_FS_GRXSTSP). */
		grxsts = otg_fs->grxstsp;
 8000e80:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8000e84:	6a03      	ldr	r3, [r0, #32]
		stat = OTG_FS_PKTSTS_GET(grxsts);
		(void)stat;

		DCC_LOG3(LOG_INFO, "[%d] <RXFLVL> len=%d status=%d", epnum, len, stat);

		if (epnum == 0) {
 8000e86:	f013 050f 	ands.w	r5, r3, #15
		   the application must read the Receive status pop
		   register (OTG_FS_GRXSTSP). */
		grxsts = otg_fs->grxstsp;

		epnum = OTG_FS_EPNUM_GET(grxsts);
		len = OTG_FS_BCNT_GET(grxsts);
 8000e8a:	f3c3 180a 	ubfx	r8, r3, #4, #11

			/* 3. If the received packets byte count is not 0, the byte count
			   amount of data is popped from the receive Data FIFO and stored in
			   memory. If the received packet byte count is 0, no data is popped
			   from the receive data FIFO. */
			switch (grxsts & OTG_FS_PKTSTS_MSK) {
 8000e8e:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
		stat = OTG_FS_PKTSTS_GET(grxsts);
		(void)stat;

		DCC_LOG3(LOG_INFO, "[%d] <RXFLVL> len=%d status=%d", epnum, len, stat);

		if (epnum == 0) {
 8000e92:	f040 80ea 	bne.w	800106a <stm32f_otg_fs_isr+0x232>

			/* 3. If the received packets byte count is not 0, the byte count
			   amount of data is popped from the receive Data FIFO and stored in
			   memory. If the received packet byte count is 0, no data is popped
			   from the receive data FIFO. */
			switch (grxsts & OTG_FS_PKTSTS_MSK) {
 8000e96:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8000e9a:	f000 8174 	beq.w	8001186 <stm32f_otg_fs_isr+0x34e>
 8000e9e:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8000ea2:	d120      	bne.n	8000ee6 <stm32f_otg_fs_isr+0xae>
				break;
			case OTG_FS_PKTSTS_SETUP_UPDT:
				/* SETUP data packet received */
				DCC_LOG1(LOG_INFO, "[%d] <RXFLVL> <SETUP_UPDT>", epnum);

				if (len != 8) {
 8000ea4:	f1b8 0f08 	cmp.w	r8, #8
 8000ea8:	d002      	beq.n	8000eb0 <stm32f_otg_fs_isr+0x78>
					DCC_LOG(LOG_ERROR, "setup data len != 8!");
 8000eaa:	48cb      	ldr	r0, [pc, #812]	; (80011d8 <stm32f_otg_fs_isr+0x3a0>)
 8000eac:	f003 fa8c 	bl	80043c8 <ice_trace0>
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* pop data from the fifo and copy to destination buffer */
	for (i = 0; i < (cnt + 3) / 4; i++) {
 8000eb0:	f108 0803 	add.w	r8, r8, #3
 8000eb4:	ea5f 0898 	movs.w	r8, r8, lsr #2
 8000eb8:	d015      	beq.n	8000ee6 <stm32f_otg_fs_isr+0xae>
		data = *pop;
 8000eba:	f44f 5780 	mov.w	r7, #4096	; 0x1000
 8000ebe:	4bc7      	ldr	r3, [pc, #796]	; (80011dc <stm32f_otg_fs_isr+0x3a4>)
}

/* Private USB device driver data */
struct stm32f_otg_drv stm32f_otg_fs_drv0;

void stm32f_otg_fs_isr(void)
 8000ec0:	2100      	movs	r1, #0
	uint32_t data;
	int i;

	/* pop data from the fifo and copy to destination buffer */
	for (i = 0; i < (cnt + 3) / 4; i++) {
		data = *pop;
 8000ec2:	f2c5 0700 	movt	r7, #20480	; 0x5000
 8000ec6:	683a      	ldr	r2, [r7, #0]
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* pop data from the fifo and copy to destination buffer */
	for (i = 0; i < (cnt + 3) / 4; i++) {
 8000ec8:	3101      	adds	r1, #1
		data = *pop;
		*dst++ = data;
		*dst++ = data >> 8;
 8000eca:	0a16      	lsrs	r6, r2, #8
		*dst++ = data >> 16;
 8000ecc:	0c15      	lsrs	r5, r2, #16
		*dst++ = data >> 24;
 8000ece:	0e10      	lsrs	r0, r2, #24
	int i;

	/* pop data from the fifo and copy to destination buffer */
	for (i = 0; i < (cnt + 3) / 4; i++) {
		data = *pop;
		*dst++ = data;
 8000ed0:	f803 2c04 	strb.w	r2, [r3, #-4]
		*dst++ = data >> 8;
 8000ed4:	f803 6c03 	strb.w	r6, [r3, #-3]
		*dst++ = data >> 16;
 8000ed8:	f803 5c02 	strb.w	r5, [r3, #-2]
		*dst++ = data >> 24;
 8000edc:	f803 0c01 	strb.w	r0, [r3, #-1]
 8000ee0:	3304      	adds	r3, #4
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* pop data from the fifo and copy to destination buffer */
	for (i = 0; i < (cnt + 3) / 4; i++) {
 8000ee2:	4541      	cmp	r1, r8
 8000ee4:	d1ef      	bne.n	8000ec6 <stm32f_otg_fs_isr+0x8e>
	if (gintsts & OTG_FS_WKUPINT) {
		DCC_LOG(LOG_INFO, "<WKUPINT>");
		/* disable resume/wakeup interrupts */
	}

	if (gintsts & OTG_FS_USBRST ) {
 8000ee6:	04e3      	lsls	r3, r4, #19
 8000ee8:	f100 80d8 	bmi.w	800109c <stm32f_otg_fs_isr+0x264>
		/* end of bus reset */
		DCC_LOG(LOG_INFO, "<USBRST> --------------- [DEFAULT]");
		stm32f_otg_dev_reset(drv);
	}

	if (gintsts & OTG_FS_ENUMDNE) {
 8000eec:	04a0      	lsls	r0, r4, #18
 8000eee:	d50d      	bpl.n	8000f0c <stm32f_otg_fs_isr+0xd4>
		DCC_LOG(LOG_INFO, "<ENUMDNE>");
		/* Unmask global interrupts */
		otg_fs->gintmsk |=  OTG_FS_IEPINTM | OTG_FS_OEPINTM |
 8000ef0:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000ef4:	699a      	ldr	r2, [r3, #24]
 8000ef6:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
 8000efa:	f042 0210 	orr.w	r2, r2, #16
 8000efe:	619a      	str	r2, [r3, #24]
			OTG_FS_IISOIXFRM | OTG_FS_IISOOXFRM | OTG_FS_RXFLVLM;
		/*  Clear global IN NAK */
		otg_fs->dctl |= OTG_FS_CGINAK;
 8000f00:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 8000f04:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000f08:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

	if (gintsts & OTG_FS_USBSUSP) {
		DCC_LOG(LOG_INFO, "<USBSUSP>");
	}

	if (gintsts & OTG_FS_IEPINT) {
 8000f0c:	0361      	lsls	r1, r4, #13
 8000f0e:	d550      	bpl.n	8000fb2 <stm32f_otg_fs_isr+0x17a>
		uint32_t diepempmsk;
		uint32_t msk;

		DCC_LOG(LOG_INFO, "<IEPINT>");

		ep_intr = (otg_fs->daint & otg_fs->daintmsk);
 8000f10:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
 8000f14:	f8d5 3818 	ldr.w	r3, [r5, #2072]	; 0x818
 8000f18:	f8d5 681c 	ldr.w	r6, [r5, #2076]	; 0x81c
		diepmsk = otg_fs->diepmsk;
 8000f1c:	f8d5 7810 	ldr.w	r7, [r5, #2064]	; 0x810
		diepempmsk = otg_fs->diepempmsk;
 8000f20:	f8d5 8834 	ldr.w	r8, [r5, #2100]	; 0x834
		uint32_t diepempmsk;
		uint32_t msk;

		DCC_LOG(LOG_INFO, "<IEPINT>");

		ep_intr = (otg_fs->daint & otg_fs->daintmsk);
 8000f24:	401e      	ands	r6, r3
		diepmsk = otg_fs->diepmsk;
		diepempmsk = otg_fs->diepempmsk;

		if (ep_intr & OTG_FS_IEPINT0) {
 8000f26:	07f2      	lsls	r2, r6, #31
 8000f28:	d515      	bpl.n	8000f56 <stm32f_otg_fs_isr+0x11e>
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 0) & 0x1) << 7;
 8000f2a:	ea4f 19c8 	mov.w	r9, r8, lsl #7
			diepint = otg_fs->inep[0].diepint & msk;
 8000f2e:	f8d5 3908 	ldr.w	r3, [r5, #2312]	; 0x908
		diepmsk = otg_fs->diepmsk;
		diepempmsk = otg_fs->diepempmsk;

		if (ep_intr & OTG_FS_IEPINT0) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 0) & 0x1) << 7;
 8000f32:	fa5f f989 	uxtb.w	r9, r9
 8000f36:	ea49 0907 	orr.w	r9, r9, r7
			diepint = otg_fs->inep[0].diepint & msk;
 8000f3a:	ea09 0903 	and.w	r9, r9, r3
			if (diepint & OTG_FS_XFRC) {
 8000f3e:	f019 0001 	ands.w	r0, r9, #1
 8000f42:	f040 8166 	bne.w	8001212 <stm32f_otg_fs_isr+0x3da>
				DCC_LOG(LOG_INFO, "[0] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep0_in(drv);
			} else if (diepint & OTG_FS_TXFE) {
 8000f46:	f019 0f80 	tst.w	r9, #128	; 0x80
 8000f4a:	f040 81ba 	bne.w	80012c2 <stm32f_otg_fs_isr+0x48a>
				DCC_LOG(LOG_INFO, "[0] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 0);
			}
			/* clear interrupts */
			otg_fs->inep[0].diepint = diepint;
 8000f4e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000f52:	f8c3 9908 	str.w	r9, [r3, #2312]	; 0x908
		}

		if (ep_intr & OTG_FS_IEPINT1) {
 8000f56:	07b3      	lsls	r3, r6, #30
 8000f58:	d513      	bpl.n	8000f82 <stm32f_otg_fs_isr+0x14a>
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 1) & 0x1) << 7;
 8000f5a:	ea4f 0558 	mov.w	r5, r8, lsr #1
			diepint = otg_fs->inep[1].diepint & msk;
 8000f5e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
			otg_fs->inep[0].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT1) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 1) & 0x1) << 7;
 8000f62:	01ed      	lsls	r5, r5, #7
			diepint = otg_fs->inep[1].diepint & msk;
 8000f64:	f8d3 3928 	ldr.w	r3, [r3, #2344]	; 0x928
			otg_fs->inep[0].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT1) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 1) & 0x1) << 7;
 8000f68:	b2ed      	uxtb	r5, r5
 8000f6a:	433d      	orrs	r5, r7
			diepint = otg_fs->inep[1].diepint & msk;
 8000f6c:	401d      	ands	r5, r3
			if (diepint & OTG_FS_XFRC) {
 8000f6e:	07e8      	lsls	r0, r5, #31
 8000f70:	f100 816e 	bmi.w	8001250 <stm32f_otg_fs_isr+0x418>
				DCC_LOG(LOG_INFO, "[1] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 1);
			}
			if (diepint & OTG_FS_TXFE) {
 8000f74:	0629      	lsls	r1, r5, #24
 8000f76:	f100 817b 	bmi.w	8001270 <stm32f_otg_fs_isr+0x438>
				DCC_LOG(LOG_INFO, "[1] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 1);
			}
			/* clear interrupts */
			otg_fs->inep[1].diepint = diepint;
 8000f7a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000f7e:	f8c3 5928 	str.w	r5, [r3, #2344]	; 0x928
		}

		if (ep_intr & OTG_FS_IEPINT2) {
 8000f82:	0772      	lsls	r2, r6, #29
 8000f84:	d513      	bpl.n	8000fae <stm32f_otg_fs_isr+0x176>
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 2) & 0x1) << 7;
 8000f86:	ea4f 0598 	mov.w	r5, r8, lsr #2
			diepint = otg_fs->inep[2].diepint & msk;
 8000f8a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
			otg_fs->inep[1].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT2) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 2) & 0x1) << 7;
 8000f8e:	01ed      	lsls	r5, r5, #7
			diepint = otg_fs->inep[2].diepint & msk;
 8000f90:	f8d3 3948 	ldr.w	r3, [r3, #2376]	; 0x948
			otg_fs->inep[1].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT2) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 2) & 0x1) << 7;
 8000f94:	b2ed      	uxtb	r5, r5
 8000f96:	433d      	orrs	r5, r7
			diepint = otg_fs->inep[2].diepint & msk;
 8000f98:	401d      	ands	r5, r3
			if (diepint & OTG_FS_XFRC) {
 8000f9a:	07eb      	lsls	r3, r5, #31
 8000f9c:	f100 815e 	bmi.w	800125c <stm32f_otg_fs_isr+0x424>
				DCC_LOG(LOG_INFO, "[2] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 2);
			}
			if (diepint & OTG_FS_TXFE) {
 8000fa0:	0628      	lsls	r0, r5, #24
 8000fa2:	f100 8169 	bmi.w	8001278 <stm32f_otg_fs_isr+0x440>
				DCC_LOG(LOG_INFO, "[2] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 2);
			}
			otg_fs->inep[2].diepint = diepint;
 8000fa6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000faa:	f8c3 5948 	str.w	r5, [r3, #2376]	; 0x948
		}

		if (ep_intr & OTG_FS_IEPINT3) {
 8000fae:	0731      	lsls	r1, r6, #28
 8000fb0:	d443      	bmi.n	800103a <stm32f_otg_fs_isr+0x202>
			}
			otg_fs->inep[3].diepint = diepint;
		}
	}

	if (gintsts & OTG_FS_OEPINT) {
 8000fb2:	0320      	lsls	r0, r4, #12
 8000fb4:	d52c      	bpl.n	8001010 <stm32f_otg_fs_isr+0x1d8>
		ep_intr = (otg_fs->daint & otg_fs->daintmsk);
 8000fb6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000fba:	f8d3 2818 	ldr.w	r2, [r3, #2072]	; 0x818
 8000fbe:	f8d3 581c 	ldr.w	r5, [r3, #2076]	; 0x81c
 8000fc2:	4015      	ands	r5, r2

		DCC_LOG(LOG_INFO, "<OEPINT>");

		if (ep_intr & OTG_FS_OEPINT0) {
 8000fc4:	03e9      	lsls	r1, r5, #15
 8000fc6:	d428      	bmi.n	800101a <stm32f_otg_fs_isr+0x1e2>
			}
			/* clear interrupts */
			otg_fs->outep[0].doepint = doepint;
		}

		if (ep_intr & OTG_FS_OEPINT1) {
 8000fc8:	03a9      	lsls	r1, r5, #14
			uint32_t doepint;

			doepint = otg_fs->outep[1].doepint & otg_fs->doepmsk;
 8000fca:	bf41      	itttt	mi
 8000fcc:	f04f 43a0 	movmi.w	r3, #1342177280	; 0x50000000
 8000fd0:	f8d3 2b28 	ldrmi.w	r2, [r3, #2856]	; 0xb28
 8000fd4:	f8d3 1814 	ldrmi.w	r1, [r3, #2068]	; 0x814
 8000fd8:	400a      	andmi	r2, r1
			}
			if (doepint & OTG_FS_STUP) {
				DCC_LOG(LOG_INFO, "[1] <OEPINT> <STUP>");
			}
			/* clear interrupts */
			otg_fs->outep[1].doepint = doepint;
 8000fda:	bf48      	it	mi
 8000fdc:	f8c3 2b28 	strmi.w	r2, [r3, #2856]	; 0xb28
		}

		if (ep_intr & OTG_FS_OEPINT2) {
 8000fe0:	036a      	lsls	r2, r5, #13
			uint32_t doepint;

			doepint = otg_fs->outep[2].doepint & otg_fs->doepmsk;
 8000fe2:	bf41      	itttt	mi
 8000fe4:	f04f 43a0 	movmi.w	r3, #1342177280	; 0x50000000
 8000fe8:	f8d3 2b48 	ldrmi.w	r2, [r3, #2888]	; 0xb48
 8000fec:	f8d3 1814 	ldrmi.w	r1, [r3, #2068]	; 0x814
 8000ff0:	400a      	andmi	r2, r1
			}
			if (doepint & OTG_FS_STUP) {
				DCC_LOG(LOG_INFO, "[2] <OEPINT> <STUP>");
			}
			/* clear interrupts */
			otg_fs->outep[1].doepint = doepint;
 8000ff2:	bf48      	it	mi
 8000ff4:	f8c3 2b28 	strmi.w	r2, [r3, #2856]	; 0xb28
		}

		if (ep_intr & OTG_FS_OEPINT3) {
 8000ff8:	032b      	lsls	r3, r5, #12
			uint32_t doepint;

			doepint = otg_fs->outep[3].doepint & otg_fs->doepmsk;
 8000ffa:	bf41      	itttt	mi
 8000ffc:	f04f 43a0 	movmi.w	r3, #1342177280	; 0x50000000
 8001000:	f8d3 2b68 	ldrmi.w	r2, [r3, #2920]	; 0xb68
 8001004:	f8d3 1814 	ldrmi.w	r1, [r3, #2068]	; 0x814
 8001008:	400a      	andmi	r2, r1
			if (doepint & OTG_FS_STUP) {
				DCC_LOG(LOG_INFO, "[3] <OEPINT> <STUP>");
			}

			/* clear interrupts */
			otg_fs->outep[1].doepint = doepint;
 800100a:	bf48      	it	mi
 800100c:	f8c3 2b28 	strmi.w	r2, [r3, #2856]	; 0xb28
	if (gintsts & OTG_FS_MMIS) {
		DCC_LOG(LOG_INFO, "<MMIS>");
	}

	/* clear pending interrupts */
	otg_fs->gintsts = gintsts;
 8001010:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8001014:	615c      	str	r4, [r3, #20]
 8001016:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		DCC_LOG(LOG_INFO, "<OEPINT>");

		if (ep_intr & OTG_FS_OEPINT0) {
			uint32_t doepint;

			doepint = otg_fs->outep[0].doepint & otg_fs->doepmsk;
 800101a:	f8d3 2b08 	ldr.w	r2, [r3, #2824]	; 0xb08
 800101e:	f8d3 7814 	ldr.w	r7, [r3, #2068]	; 0x814
 8001022:	4017      	ands	r7, r2

			if (doepint & OTG_FS_XFRC) {
 8001024:	07fa      	lsls	r2, r7, #31
 8001026:	f100 809c 	bmi.w	8001162 <stm32f_otg_fs_isr+0x32a>
				stm32f_otg_dev_ep0_out(drv);
			}
			if (doepint & OTG_FS_EPDISD) {
				DCC_LOG(LOG_INFO, "[0] <OEPINT> <EPDISD>");
			}
			if (doepint & OTG_FS_STUP) {
 800102a:	0738      	lsls	r0, r7, #28
 800102c:	f100 8128 	bmi.w	8001280 <stm32f_otg_fs_isr+0x448>
						stupcnt, pktcnt, xfrsiz);
#endif
				stm32f_otg_dev_ep0_setup(drv);
			}
			/* clear interrupts */
			otg_fs->outep[0].doepint = doepint;
 8001030:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8001034:	f8c3 7b08 	str.w	r7, [r3, #2824]	; 0xb08
 8001038:	e7c6      	b.n	8000fc8 <stm32f_otg_fs_isr+0x190>
			otg_fs->inep[2].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT3) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 3) & 0x1) << 7;
 800103a:	ea4f 08d8 	mov.w	r8, r8, lsr #3
			diepint = otg_fs->inep[3].diepint & msk;
 800103e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
			otg_fs->inep[2].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT3) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 3) & 0x1) << 7;
 8001042:	ea4f 18c8 	mov.w	r8, r8, lsl #7
			diepint = otg_fs->inep[3].diepint & msk;
 8001046:	f8d3 3968 	ldr.w	r3, [r3, #2408]	; 0x968
			otg_fs->inep[2].diepint = diepint;
		}

		if (ep_intr & OTG_FS_IEPINT3) {
			/* add the Transmit FIFO empty bit to the mask */
			msk = diepmsk | ((diepempmsk >> 3) & 0x1) << 7;
 800104a:	fa5f f888 	uxtb.w	r8, r8
 800104e:	ea48 0707 	orr.w	r7, r8, r7
			diepint = otg_fs->inep[3].diepint & msk;
 8001052:	401f      	ands	r7, r3
			if (diepint & OTG_FS_XFRC) {
 8001054:	07fa      	lsls	r2, r7, #31
 8001056:	f100 80d6 	bmi.w	8001206 <stm32f_otg_fs_isr+0x3ce>
				DCC_LOG(LOG_INFO, "[3] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 3);
			}
			if (diepint & OTG_FS_TXFE) {
 800105a:	063b      	lsls	r3, r7, #24
 800105c:	f100 8104 	bmi.w	8001268 <stm32f_otg_fs_isr+0x430>
				DCC_LOG(LOG_INFO, "[3] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 3);
			}
			otg_fs->inep[3].diepint = diepint;
 8001060:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8001064:	f8c3 7968 	str.w	r7, [r3, #2408]	; 0x968
 8001068:	e7a3      	b.n	8000fb2 <stm32f_otg_fs_isr+0x17a>
						drv->req.type, drv->req.request, drv->req.length);

				break;
			}
		} else {
			switch (grxsts & OTG_FS_PKTSTS_MSK) {
 800106a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800106e:	f000 80b9 	beq.w	80011e4 <stm32f_otg_fs_isr+0x3ac>
 8001072:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 8001076:	f47f af36 	bne.w	8000ee6 <stm32f_otg_fs_isr+0xae>
			case OTG_FS_PKTSTS_OUT_XFER_COMP:
				DCC_LOG1(LOG_INFO, "[%d] <RXFLVL> <OUT_XFER_COMP>", epnum);
				DCC_LOG2(LOG_INFO, "[%d] doeptsiz=%08x", epnum, 
						 otg_fs->outep[epnum].doeptsiz);	 
				/* Prepare to receive more */
				otg_fs->outep[epnum].doeptsiz = drv->ep[epnum].doeptsiz;
 800107a:	4e59      	ldr	r6, [pc, #356]	; (80011e0 <stm32f_otg_fs_isr+0x3a8>)
 800107c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8001080:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 8001084:	016d      	lsls	r5, r5, #5
 8001086:	6933      	ldr	r3, [r6, #16]
 8001088:	f105 45a0 	add.w	r5, r5, #1342177280	; 0x50000000
 800108c:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
				   packets and we end up with a deadlock situation */

//				otg_fs->outep[epnum].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
				/* Disable SOF interrupts */
//				otg_fs->gintmsk &= ~OTG_FS_SOFM;
				break;
 8001090:	e729      	b.n	8000ee6 <stm32f_otg_fs_isr+0xae>
	if (gintsts & OTG_FS_OTGINT) {
		uint32_t gotgint = otg_fs->gotgint;
		DCC_LOG(LOG_INFO, "<OTGINT>");
		if (gotgint & OTG_FS_OTGINT) {
			DCC_LOG(LOG_INFO, "<SEDET>  [ATTACHED]");
			otg_fs->gintmsk = OTG_FS_SRQIM | OTG_FS_OTGINT;
 8001092:	2104      	movs	r1, #4
 8001094:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8001098:	6191      	str	r1, [r2, #24]
 800109a:	e6e4      	b.n	8000e66 <stm32f_otg_fs_isr+0x2e>
	int i;

	DCC_LOG(LOG_INFO, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

	/* Clear the Remote Wake-up Signaling */
	otg_fs->dctl &= ~OTG_FS_RWUSIG;
 800109c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
 80010a0:	2500      	movs	r5, #0
	int i;

	DCC_LOG(LOG_INFO, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

	/* Clear the Remote Wake-up Signaling */
	otg_fs->dctl &= ~OTG_FS_RWUSIG;
 80010a2:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 80010a6:	4e4e      	ldr	r6, [pc, #312]	; (80011e0 <stm32f_otg_fs_isr+0x3a8>)
 80010a8:	f023 0301 	bic.w	r3, r3, #1

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
 80010ac:	f04f 3eff 	mov.w	lr, #4294967295
	int i;

	DCC_LOG(LOG_INFO, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

	/* Clear the Remote Wake-up Signaling */
	otg_fs->dctl &= ~OTG_FS_RWUSIG;
 80010b0:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
 80010b4:	4629      	mov	r1, r5

	/* Clear the Remote Wake-up Signaling */
	otg_fs->dctl &= ~OTG_FS_RWUSIG;

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
 80010b6:	f8c2 5810 	str.w	r5, [r2, #2064]	; 0x810
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
 80010ba:	462b      	mov	r3, r5
	/* Clear the Remote Wake-up Signaling */
	otg_fs->dctl &= ~OTG_FS_RWUSIG;

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
 80010bc:	f8c2 5814 	str.w	r5, [r2, #2068]	; 0x814
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
		otg_fs->inep[i].diepint = 0xff;
 80010c0:	27ff      	movs	r7, #255	; 0xff
	otg_fs->dctl &= ~OTG_FS_RWUSIG;

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
 80010c2:	f8c2 e818 	str.w	lr, [r2, #2072]	; 0x818
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
		otg_fs->inep[i].diepint = 0xff;
		otg_fs->outep[i].doepint = 0xff;
		otg_fs->inep[i].dieptsiz = 0;
 80010c6:	4628      	mov	r0, r5

	/* Clear all pending interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
 80010c8:	f8c2 581c 	str.w	r5, [r2, #2076]	; 0x81c
	otg_fs->diepempmsk = 0;
 80010cc:	f8c2 5834 	str.w	r5, [r2, #2100]	; 0x834
	for (i = 0; i < 4; i++) {
		otg_fs->inep[i].diepint = 0xff;
 80010d0:	015a      	lsls	r2, r3, #5
 80010d2:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
}

/* Private USB device driver data */
struct stm32f_otg_drv stm32f_otg_fs_drv0;

void stm32f_otg_fs_isr(void)
 80010d6:	eb06 0e01 	add.w	lr, r6, r1
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
 80010da:	3301      	adds	r3, #1
 80010dc:	3118      	adds	r1, #24
 80010de:	2b04      	cmp	r3, #4
		otg_fs->inep[i].diepint = 0xff;
 80010e0:	f8c2 7908 	str.w	r7, [r2, #2312]	; 0x908
 80010e4:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
		otg_fs->outep[i].doepint = 0xff;
 80010e8:	f8c2 7b08 	str.w	r7, [r2, #2824]	; 0xb08
}

/* Private USB device driver data */
struct stm32f_otg_drv stm32f_otg_fs_drv0;

void stm32f_otg_fs_isr(void)
 80010ec:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 80011e0 <stm32f_otg_fs_isr+0x3a8>
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
		otg_fs->inep[i].diepint = 0xff;
		otg_fs->outep[i].doepint = 0xff;
		otg_fs->inep[i].dieptsiz = 0;
 80010f0:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910

		drv->ep[i].xfr_rem = 0;
 80010f4:	f8ae 0004 	strh.w	r0, [lr, #4]
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	otg_fs->diepempmsk = 0;
	for (i = 0; i < 4; i++) {
 80010f8:	d1ea      	bne.n	80010d0 <stm32f_otg_fs_isr+0x298>

		drv->ep[i].xfr_rem = 0;
	}

	/* Flush the Tx FIFO */
	stm32f_otg_fs_txfifo_flush(otg_fs, TXFIFO_ALL);
 80010fa:	2110      	movs	r1, #16
 80010fc:	4628      	mov	r0, r5
 80010fe:	f000 faab 	bl	8001658 <stm32f_otg_fs_txfifo_flush>
	/* Flush the Rx FIFO */
	stm32f_otg_fs_rxfifo_flush(otg_fs);
 8001102:	4628      	mov	r0, r5
 8001104:	f000 fab4 	bl	8001670 <stm32f_otg_fs_rxfifo_flush>


	/* Reset global interrupts mask */
	otg_fs->gintmsk =  OTG_FS_SRQIM | OTG_FS_OTGINT | OTG_FS_WUIM |
 8001108:	f643 4304 	movw	r3, #15364	; 0x3c04
 800110c:	f2cc 0300 	movt	r3, #49152	; 0xc000
 8001110:	61ab      	str	r3, [r5, #24]
			OTG_FS_USBRSTM | OTG_FS_ENUMDNEM |
			OTG_FS_ESUSPM | OTG_FS_USBSUSPM;

	/* Reset Device Address */
	otg_fs->dcfg &= ~OTG_FS_DAD_MSK;
 8001112:	f8d5 2800 	ldr.w	r2, [r5, #2048]	; 0x800
	drv->fifo_addr += siz;

	DCC_LOG2(LOG_INFO, "   RX: addr=%04x size=%d",
			 0, otg_fs->grxfsiz * 4);

	drv->ev->on_reset(drv->cl);
 8001116:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 800111a:	f8d8 0060 	ldr.w	r0, [r8, #96]	; 0x60
 800111e:	6819      	ldr	r1, [r3, #0]
	otg_fs->gintmsk =  OTG_FS_SRQIM | OTG_FS_OTGINT | OTG_FS_WUIM |
			OTG_FS_USBRSTM | OTG_FS_ENUMDNEM |
			OTG_FS_ESUSPM | OTG_FS_USBSUSPM;

	/* Reset Device Address */
	otg_fs->dcfg &= ~OTG_FS_DAD_MSK;
 8001120:	f422 63fe 	bic.w	r3, r2, #2032	; 0x7f0
 8001124:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

	/*  Set global IN NAK */
	otg_fs->dctl |= OTG_FS_SGINAK;
 8001128:	f8d5 6804 	ldr.w	r6, [r5, #2052]	; 0x804
 800112c:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 8001130:	f8c5 6804 	str.w	r6, [r5, #2052]	; 0x804
	/* Endpoint initialization on USB reset */

	/* 1. Set the NAK bit for all OUT endpoints
	    SNAK = 1 in OTG_FS_DOEPCTLx (for all OUT endpoints) */
	for (i = 0; i < 4; i++) {
		otg_fs->outep[i].doepctl = OTG_FS_SNAK;
 8001134:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
	drv->fifo_addr = 0;
	/* initialize RX fifo size */
	siz = OTG_FS_RX_FIFO_SIZE;
	otg_fs->grxfsiz = siz / 4;
	/* update fifo memory allocation pointer */
	drv->fifo_addr += siz;
 8001138:	f44f 7600 	mov.w	r6, #512	; 0x200
 800113c:	f8a8 6070 	strh.w	r6, [r8, #112]	; 0x70
	    OUTEP0 = 1 in OTG_FS_DAINTMSK (control 0 OUT endpoint)
	    STUP = 1 in DOEPMSK
	    XFRC = 1 in DOEPMSK
	    XFRC = 1 in DIEPMSK
	    TOC = 1 in DIEPMSK */
	otg_fs->doepmsk = OTG_FS_STUPM | OTG_FS_XFRCM | OTG_FS_EPDM;
 8001140:	220b      	movs	r2, #11
	/* Endpoint initialization on USB reset */

	/* 1. Set the NAK bit for all OUT endpoints
	    SNAK = 1 in OTG_FS_DOEPCTLx (for all OUT endpoints) */
	for (i = 0; i < 4; i++) {
		otg_fs->outep[i].doepctl = OTG_FS_SNAK;
 8001142:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
 8001146:	f8c5 3b20 	str.w	r3, [r5, #2848]	; 0xb20
 800114a:	f8c5 3b40 	str.w	r3, [r5, #2880]	; 0xb40
 800114e:	f8c5 3b60 	str.w	r3, [r5, #2912]	; 0xb60

	/* reset fifo memory (packet buffer) allocation pointer */
	drv->fifo_addr = 0;
	/* initialize RX fifo size */
	siz = OTG_FS_RX_FIFO_SIZE;
	otg_fs->grxfsiz = siz / 4;
 8001152:	2380      	movs	r3, #128	; 0x80
	    OUTEP0 = 1 in OTG_FS_DAINTMSK (control 0 OUT endpoint)
	    STUP = 1 in DOEPMSK
	    XFRC = 1 in DOEPMSK
	    XFRC = 1 in DIEPMSK
	    TOC = 1 in DIEPMSK */
	otg_fs->doepmsk = OTG_FS_STUPM | OTG_FS_XFRCM | OTG_FS_EPDM;
 8001154:	f8c5 2814 	str.w	r2, [r5, #2068]	; 0x814
	otg_fs->diepmsk = OTG_FS_TOM | OTG_FS_EPDM | OTG_FS_XFRCM;
 8001158:	f8c5 2810 	str.w	r2, [r5, #2064]	; 0x810

	/* reset fifo memory (packet buffer) allocation pointer */
	drv->fifo_addr = 0;
	/* initialize RX fifo size */
	siz = OTG_FS_RX_FIFO_SIZE;
	otg_fs->grxfsiz = siz / 4;
 800115c:	626b      	str	r3, [r5, #36]	; 0x24
	drv->fifo_addr += siz;

	DCC_LOG2(LOG_INFO, "   RX: addr=%04x size=%d",
			 0, otg_fs->grxfsiz * 4);

	drv->ev->on_reset(drv->cl);
 800115e:	4788      	blx	r1
 8001160:	e6c4      	b.n	8000eec <stm32f_otg_fs_isr+0xb4>
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep = &drv->ep[0];

	/* last and only transfer */
	if (ep->state == EP_OUT_DATA_LAST) {
 8001162:	4a1f      	ldr	r2, [pc, #124]	; (80011e0 <stm32f_otg_fs_isr+0x3a8>)
 8001164:	7811      	ldrb	r1, [r2, #0]
 8001166:	2909      	cmp	r1, #9
 8001168:	f47f af5f 	bne.w	800102a <stm32f_otg_fs_isr+0x1f2>

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 800116c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 8001170:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8001174:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep = &drv->ep[0];

	/* last and only transfer */
	if (ep->state == EP_OUT_DATA_LAST) {
		ep->state = EP_WAIT_STATUS_IN;
 8001178:	2006      	movs	r0, #6
static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 800117a:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep = &drv->ep[0];

	/* last and only transfer */
	if (ep->state == EP_OUT_DATA_LAST) {
		ep->state = EP_WAIT_STATUS_IN;
 800117e:	7010      	strb	r0, [r2, #0]
static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8001180:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 8001184:	e751      	b.n	800102a <stm32f_otg_fs_isr+0x1f2>

	/* Number of words in the receive fifo */
	wcnt = (len + 3) / 4;
	DCC_LOG1(LOG_INFO, "poping %d words from FIFO.", wcnt);

	if (ep->xfr_rem >= len) {
 8001186:	4e16      	ldr	r6, [pc, #88]	; (80011e0 <stm32f_otg_fs_isr+0x3a8>)
 8001188:	88b2      	ldrh	r2, [r6, #4]
	uint32_t data;
	int wcnt;
	int i;

	/* Number of words in the receive fifo */
	wcnt = (len + 3) / 4;
 800118a:	f108 0903 	add.w	r9, r8, #3
	DCC_LOG1(LOG_INFO, "poping %d words from FIFO.", wcnt);

	if (ep->xfr_rem >= len) {
 800118e:	4590      	cmp	r8, r2
	uint32_t data;
	int wcnt;
	int i;

	/* Number of words in the receive fifo */
	wcnt = (len + 3) / 4;
 8001190:	ea4f 09a9 	mov.w	r9, r9, asr #2
	DCC_LOG1(LOG_INFO, "poping %d words from FIFO.", wcnt);

	if (ep->xfr_rem >= len) {
 8001194:	f300 80c2 	bgt.w	800131c <stm32f_otg_fs_isr+0x4e4>
		/* If we have enough room in the destination buffer
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
 8001198:	68f3      	ldr	r3, [r6, #12]
		for (i = 0; i < wcnt; ++i) {
 800119a:	f1b9 0f00 	cmp.w	r9, #0
 800119e:	d014      	beq.n	80011ca <stm32f_otg_fs_isr+0x392>
			data = *pop;
 80011a0:	f44f 5280 	mov.w	r2, #4096	; 0x1000

	if (ep->xfr_rem >= len) {
		/* If we have enough room in the destination buffer
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
		for (i = 0; i < wcnt; ++i) {
 80011a4:	4629      	mov	r1, r5
			data = *pop;
 80011a6:	f2c5 0200 	movt	r2, #20480	; 0x5000
 80011aa:	6810      	ldr	r0, [r2, #0]

	if (ep->xfr_rem >= len) {
		/* If we have enough room in the destination buffer
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
		for (i = 0; i < wcnt; ++i) {
 80011ac:	3101      	adds	r1, #1
			data = *pop;
			*dst++ = data;
			*dst++ = data >> 8;
			*dst++ = data >> 16;
 80011ae:	0c07      	lsrs	r7, r0, #16
			*dst++ = data >> 24;
 80011b0:	0e05      	lsrs	r5, r0, #24
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
		for (i = 0; i < wcnt; ++i) {
			data = *pop;
			*dst++ = data;
			*dst++ = data >> 8;
 80011b2:	ea4f 2c10 	mov.w	ip, r0, lsr #8
		/* If we have enough room in the destination buffer
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
		for (i = 0; i < wcnt; ++i) {
			data = *pop;
			*dst++ = data;
 80011b6:	7018      	strb	r0, [r3, #0]
			*dst++ = data >> 8;
 80011b8:	f883 c001 	strb.w	ip, [r3, #1]
			*dst++ = data >> 16;
 80011bc:	709f      	strb	r7, [r3, #2]
			*dst++ = data >> 24;
 80011be:	70dd      	strb	r5, [r3, #3]
}

/* Private USB device driver data */
struct stm32f_otg_drv stm32f_otg_fs_drv0;

void stm32f_otg_fs_isr(void)
 80011c0:	3304      	adds	r3, #4

	if (ep->xfr_rem >= len) {
		/* If we have enough room in the destination buffer
		 * pop data from the fifo and copy to destination buffer */
		dst = ep->xfr_ptr;
		for (i = 0; i < wcnt; ++i) {
 80011c2:	4549      	cmp	r1, r9
 80011c4:	d1f1      	bne.n	80011aa <stm32f_otg_fs_isr+0x372>
 80011c6:	68f3      	ldr	r3, [r6, #12]
 80011c8:	88b2      	ldrh	r2, [r6, #4]
			*dst++ = data;
			*dst++ = data >> 8;
			*dst++ = data >> 16;
			*dst++ = data >> 24;
		}
		ep->xfr_ptr += len;
 80011ca:	4443      	add	r3, r8
		ep->xfr_rem -= len;
 80011cc:	ebc8 0202 	rsb	r2, r8, r2
			*dst++ = data;
			*dst++ = data >> 8;
			*dst++ = data >> 16;
			*dst++ = data >> 24;
		}
		ep->xfr_ptr += len;
 80011d0:	60f3      	str	r3, [r6, #12]
		ep->xfr_rem -= len;
 80011d2:	80b2      	strh	r2, [r6, #4]
 80011d4:	e687      	b.n	8000ee6 <stm32f_otg_fs_isr+0xae>
 80011d6:	bf00      	nop
 80011d8:	40000070 	.word	0x40000070
 80011dc:	20000078 	.word	0x20000078
 80011e0:	2000000c 	.word	0x2000000c
				DCC_LOG1(LOG_INFO, "[%d] <RXFLVL> <OUT_DATA_UPDT>", epnum);
				/* 2. The application can mask the RXFLVL interrupt (in
				   OTG_FS_GINTSTS) by writing to RXFLVL = 0 (in
				   OTG_FS_GINTMSK), until it has read the packet from
				   the receive FIFO. */
				otg_fs->gintmsk &= ~OTG_FS_RXFLVLM;
 80011e4:	6982      	ldr	r2, [r0, #24]
 */

static void stm32f_otg_dev_ep_out(struct stm32f_otg_drv * drv, 
								  int ep_id, int len)
{
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];
 80011e6:	4e78      	ldr	r6, [pc, #480]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 80011e8:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 80011ec:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
				DCC_LOG1(LOG_INFO, "[%d] <RXFLVL> <OUT_DATA_UPDT>", epnum);
				/* 2. The application can mask the RXFLVL interrupt (in
				   OTG_FS_GINTSTS) by writing to RXFLVL = 0 (in
				   OTG_FS_GINTMSK), until it has read the packet from
				   the receive FIFO. */
				otg_fs->gintmsk &= ~OTG_FS_RXFLVLM;
 80011f0:	f022 0210 	bic.w	r2, r2, #16
 80011f4:	6182      	str	r2, [r0, #24]
	   packet. Either the upper layer garantees the removal or
	   buffering at this layer should be implemented.
	 */

	/* call class endpoint callback */
	ep->on_out(drv->cl, ep_id, len);
 80011f6:	695f      	ldr	r7, [r3, #20]
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];
//	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;

	DCC_LOG1(LOG_INFO, "ep_id=%d", ep_id);

	ep->xfr_rem = len;
 80011f8:	f8a3 8004 	strh.w	r8, [r3, #4]
	   packet. Either the upper layer garantees the removal or
	   buffering at this layer should be implemented.
	 */

	/* call class endpoint callback */
	ep->on_out(drv->cl, ep_id, len);
 80011fc:	6e30      	ldr	r0, [r6, #96]	; 0x60
 80011fe:	4629      	mov	r1, r5
 8001200:	4642      	mov	r2, r8
 8001202:	47b8      	blx	r7
 8001204:	e66f      	b.n	8000ee6 <stm32f_otg_fs_isr+0xae>
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];

	DCC_LOG1(LOG_INFO, "ep_id=%d", ep_id);

	/* call class endpoint callback */
	ep->on_in(drv->cl, ep_id);
 8001206:	4b70      	ldr	r3, [pc, #448]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 8001208:	2103      	movs	r1, #3
 800120a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800120c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800120e:	4790      	blx	r2
 8001210:	e723      	b.n	800105a <stm32f_otg_fs_isr+0x222>
static void stm32f_otg_dev_ep0_in(struct stm32f_otg_drv * drv)
{
	struct stm32f_otg_fs * otg_fs = STM32F_OTG_FS;
	struct stm32f_otg_ep * ep = &drv->ep[0];

	if (ep->state == EP_WAIT_STATUS_IN) {
 8001212:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 80013c8 <stm32f_otg_fs_isr+0x590>
 8001216:	f89a 3000 	ldrb.w	r3, [sl]
 800121a:	2b06      	cmp	r3, #6
 800121c:	f000 809e 	beq.w	800135c <stm32f_otg_fs_isr+0x524>
		DCC_LOG(LOG_INFO, "EP0 [IDLE]");
		return;
	}


	if (ep->xfr_rem == 0) {
 8001220:	f8ba 2004 	ldrh.w	r2, [sl, #4]
 8001224:	2a00      	cmp	r2, #0
 8001226:	d16c      	bne.n	8001302 <stm32f_otg_fs_isr+0x4ca>
		otg_fs->diepempmsk &= ~(1 << 0);
 8001228:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
		/* Prepare to receive */
		otg_fs->outep[0].doeptsiz = ep->doeptsiz;
 800122c:	f8da 3010 	ldr.w	r3, [sl, #16]
		return;
	}


	if (ep->xfr_rem == 0) {
		otg_fs->diepempmsk &= ~(1 << 0);
 8001230:	f022 0201 	bic.w	r2, r2, #1
 8001234:	f8c5 2834 	str.w	r2, [r5, #2100]	; 0x834
		/* Prepare to receive */
		otg_fs->outep[0].doeptsiz = ep->doeptsiz;
 8001238:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
		/* EP enable */
		otg_fs->outep[0].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 800123c:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8001240:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8001244:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
		ep->state = EP_IN_DATA;
 8001248:	2304      	movs	r3, #4
 800124a:	f88a 3000 	strb.w	r3, [sl]
 800124e:	e67e      	b.n	8000f4e <stm32f_otg_fs_isr+0x116>
	struct stm32f_otg_ep * ep = &drv->ep[ep_id];

	DCC_LOG1(LOG_INFO, "ep_id=%d", ep_id);

	/* call class endpoint callback */
	ep->on_in(drv->cl, ep_id);
 8001250:	4b5d      	ldr	r3, [pc, #372]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 8001252:	2101      	movs	r1, #1
 8001254:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001256:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8001258:	4790      	blx	r2
 800125a:	e68b      	b.n	8000f74 <stm32f_otg_fs_isr+0x13c>
 800125c:	4b5a      	ldr	r3, [pc, #360]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 800125e:	2102      	movs	r1, #2
 8001260:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001262:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8001264:	4790      	blx	r2
 8001266:	e69b      	b.n	8000fa0 <stm32f_otg_fs_isr+0x168>
				DCC_LOG(LOG_INFO, "[3] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 3);
			}
			if (diepint & OTG_FS_TXFE) {
				DCC_LOG(LOG_INFO, "[3] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 3);
 8001268:	2003      	movs	r0, #3
 800126a:	f7ff fbeb 	bl	8000a44 <__ep_tx_push.constprop.5>
 800126e:	e6f7      	b.n	8001060 <stm32f_otg_fs_isr+0x228>
				DCC_LOG(LOG_INFO, "[1] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 1);
			}
			if (diepint & OTG_FS_TXFE) {
				DCC_LOG(LOG_INFO, "[1] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 1);
 8001270:	2001      	movs	r0, #1
 8001272:	f7ff fbe7 	bl	8000a44 <__ep_tx_push.constprop.5>
 8001276:	e680      	b.n	8000f7a <stm32f_otg_fs_isr+0x142>
				DCC_LOG(LOG_INFO, "[2] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep_in(drv, 2);
			}
			if (diepint & OTG_FS_TXFE) {
				DCC_LOG(LOG_INFO, "[2] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 2);
 8001278:	2002      	movs	r0, #2
 800127a:	f7ff fbe3 	bl	8000a44 <__ep_tx_push.constprop.5>
 800127e:	e692      	b.n	8000fa6 <stm32f_otg_fs_isr+0x16e>

	DCC_LOG3(LOG_INFO, "type=0x%02x request=0x%02x len=%d ",
			req->type, req->request, req->length);

	/* No-Data control SETUP transaction */
	if (req->length == 0) {
 8001280:	4e51      	ldr	r6, [pc, #324]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 8001282:	f8b6 306e 	ldrh.w	r3, [r6, #110]	; 0x6e
 8001286:	b1fb      	cbz	r3, 80012c8 <stm32f_otg_fs_isr+0x490>
		ep->state = EP_IDLE;
		__ep_zlp_send(otg_fs, 0);
		return;
	}

	if (req->type & 0x80) {
 8001288:	f996 2068 	ldrsb.w	r2, [r6, #104]	; 0x68
 800128c:	2a00      	cmp	r2, #0
 800128e:	db71      	blt.n	8001374 <stm32f_otg_fs_isr+0x53c>
		ep->xfr_ptr = ep->xfr_buf;
		ep->xfr_rem = req->length;

		DCC_LOG1(LOG_INFO, "xfr_ptr=0x%08x", ep->xfr_ptr);

		if (ep->xfr_rem > ep->xfr_buf_len) {
 8001290:	88f2      	ldrh	r2, [r6, #6]
			/* umask FIFO empty interrupt */
			otg_fs->diepempmsk |= (1 << 0);
		}
	} else {
		/* Control Write SETUP transaction (OUT Data Phase) */
		ep->xfr_ptr = ep->xfr_buf;
 8001292:	68b1      	ldr	r1, [r6, #8]
		ep->xfr_rem = req->length;
 8001294:	80b3      	strh	r3, [r6, #4]

		DCC_LOG1(LOG_INFO, "xfr_ptr=0x%08x", ep->xfr_ptr);

		if (ep->xfr_rem > ep->xfr_buf_len) {
 8001296:	4293      	cmp	r3, r2
			/* umask FIFO empty interrupt */
			otg_fs->diepempmsk |= (1 << 0);
		}
	} else {
		/* Control Write SETUP transaction (OUT Data Phase) */
		ep->xfr_ptr = ep->xfr_buf;
 8001298:	60f1      	str	r1, [r6, #12]
		ep->xfr_rem = req->length;

		DCC_LOG1(LOG_INFO, "xfr_ptr=0x%08x", ep->xfr_ptr);

		if (ep->xfr_rem > ep->xfr_buf_len) {
 800129a:	d852      	bhi.n	8001342 <stm32f_otg_fs_isr+0x50a>
			ep->xfr_rem = ep->xfr_buf_len;
			DCC_LOG(LOG_ERROR, "transfer to large to fit in the buffer!");
		}

		if (ep->xfr_rem < ep->xfr_max) {
 800129c:	8872      	ldrh	r2, [r6, #2]
 800129e:	494a      	ldr	r1, [pc, #296]	; (80013c8 <stm32f_otg_fs_isr+0x590>)
 80012a0:	4293      	cmp	r3, r2
 80012a2:	d24b      	bcs.n	800133c <stm32f_otg_fs_isr+0x504>
			/* last and only transfer */
			ep->state = EP_OUT_DATA_LAST;
 80012a4:	2309      	movs	r3, #9
 80012a6:	700b      	strb	r3, [r1, #0]
		}

		DCC_LOG(LOG_INFO, "Prepare to receive");

		/* Prepare to receive */
		otg_fs->outep[0].doeptsiz = OTG_FS_STUPCNT_SET(0) |
 80012a8:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
			OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(ep->xfr_max);
 80012ac:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
		}

		DCC_LOG(LOG_INFO, "Prepare to receive");

		/* Prepare to receive */
		otg_fs->outep[0].doeptsiz = OTG_FS_STUPCNT_SET(0) |
 80012b0:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
			OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(ep->xfr_max);

		/* EP enable */
		otg_fs->outep[0].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 80012b4:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80012b8:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80012bc:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80012c0:	e6b6      	b.n	8001030 <stm32f_otg_fs_isr+0x1f8>
			if (diepint & OTG_FS_XFRC) {
				DCC_LOG(LOG_INFO, "[0] <IEPINT> <XFRC>");
				stm32f_otg_dev_ep0_in(drv);
			} else if (diepint & OTG_FS_TXFE) {
				DCC_LOG(LOG_INFO, "[0] <IEPINT> <TXFE>");
				__ep_tx_push(drv, 0);
 80012c2:	f7ff fbbf 	bl	8000a44 <__ep_tx_push.constprop.5>
 80012c6:	e642      	b.n	8000f4e <stm32f_otg_fs_isr+0x116>
	/* No-Data control SETUP transaction */
	if (req->length == 0) {
		struct usb_request * req = &drv->req;
		void * dummy = NULL;

		if (((req->request << 8) | req->type) == STD_SET_ADDRESS) {
 80012c8:	f896 2069 	ldrb.w	r2, [r6, #105]	; 0x69
 80012cc:	f896 3068 	ldrb.w	r3, [r6, #104]	; 0x68
 80012d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80012d4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80012d8:	d039      	beq.n	800134e <stm32f_otg_fs_isr+0x516>
			DCC_LOG(LOG_INFO, "address set!");
			stm32f_otg_fs_addr_set(otg_fs, req->value);
		}
		ep->on_setup(drv->cl, req, dummy);
 80012da:	6973      	ldr	r3, [r6, #20]
 80012dc:	6e30      	ldr	r0, [r6, #96]	; 0x60
 80012de:	493b      	ldr	r1, [pc, #236]	; (80013cc <stm32f_otg_fs_isr+0x594>)
 80012e0:	2200      	movs	r2, #0
 80012e2:	4798      	blx	r3

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 80012e4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
		if (((req->request << 8) | req->type) == STD_SET_ADDRESS) {
			DCC_LOG(LOG_INFO, "address set!");
			stm32f_otg_fs_addr_set(otg_fs, req->value);
		}
		ep->on_setup(drv->cl, req, dummy);
		ep->state = EP_IDLE;
 80012e8:	2201      	movs	r2, #1
 80012ea:	7032      	strb	r2, [r6, #0]

static void __ep_zlp_send(struct stm32f_otg_fs * otg_fs, int epnum)
{
	DCC_LOG(LOG_INFO, "Send: ZLP");

	otg_fs->inep[epnum].dieptsiz = OTG_FS_PKTCNT_SET(1) | OTG_FS_XFRSIZ_SET(0);
 80012ec:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80012f0:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
	otg_fs->inep[epnum].diepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 80012f4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80012f8:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80012fc:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8001300:	e696      	b.n	8001030 <stm32f_otg_fs_isr+0x1f8>
		ep->state = EP_IN_DATA;
		DCC_LOG(LOG_INFO, "EP0 [IN_DATA]");
		return;
	} 
	
	if (stm32f_otg_fs_txf_setup(otg_fs, 0, ep->xfr_rem) < 0) {
 8001302:	2100      	movs	r1, #0
 8001304:	4628      	mov	r0, r5
 8001306:	f000 fa05 	bl	8001714 <stm32f_otg_fs_txf_setup>
 800130a:	2800      	cmp	r0, #0
 800130c:	db54      	blt.n	80013b8 <stm32f_otg_fs_isr+0x580>
		DCC_LOG(LOG_ERROR, "stm32f_otg_fs_txf_setup() failed!");
	} else {
		/* umask FIFO empty interrupt */
		otg_fs->diepempmsk |= (1 << 0);
 800130e:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 8001312:	f043 0301 	orr.w	r3, r3, #1
 8001316:	f8c5 3834 	str.w	r3, [r5, #2100]	; 0x834
 800131a:	e618      	b.n	8000f4e <stm32f_otg_fs_isr+0x116>
			*dst++ = data >> 24;
		}
		ep->xfr_ptr += len;
		ep->xfr_rem -= len;
	} else {
		DCC_LOG(LOG_WARNING, "not room to copy the whole packet, discarding!");
 800131c:	482c      	ldr	r0, [pc, #176]	; (80013d0 <stm32f_otg_fs_isr+0x598>)
 800131e:	f003 f853 	bl	80043c8 <ice_trace0>
		for (i = 0; i < wcnt; ++i) {
 8001322:	f1b9 0f00 	cmp.w	r9, #0
 8001326:	f43f adde 	beq.w	8000ee6 <stm32f_otg_fs_isr+0xae>
			data = *pop;
 800132a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800132e:	f2c5 0300 	movt	r3, #20480	; 0x5000
		}
		ep->xfr_ptr += len;
		ep->xfr_rem -= len;
	} else {
		DCC_LOG(LOG_WARNING, "not room to copy the whole packet, discarding!");
		for (i = 0; i < wcnt; ++i) {
 8001332:	3501      	adds	r5, #1
 8001334:	454d      	cmp	r5, r9
			data = *pop;
 8001336:	681a      	ldr	r2, [r3, #0]
		}
		ep->xfr_ptr += len;
		ep->xfr_rem -= len;
	} else {
		DCC_LOG(LOG_WARNING, "not room to copy the whole packet, discarding!");
		for (i = 0; i < wcnt; ++i) {
 8001338:	d1fb      	bne.n	8001332 <stm32f_otg_fs_isr+0x4fa>
 800133a:	e5d4      	b.n	8000ee6 <stm32f_otg_fs_isr+0xae>
		if (ep->xfr_rem < ep->xfr_max) {
			/* last and only transfer */
			ep->state = EP_OUT_DATA_LAST;
			DCC_LOG(LOG_INFO, "EP0 [OUT_DATA_LAST] OUT Host->Dev!!!!");
		} else {
			ep->state = EP_OUT_DATA;
 800133c:	2308      	movs	r3, #8
 800133e:	700b      	strb	r3, [r1, #0]
 8001340:	e7b2      	b.n	80012a8 <stm32f_otg_fs_isr+0x470>

		DCC_LOG1(LOG_INFO, "xfr_ptr=0x%08x", ep->xfr_ptr);

		if (ep->xfr_rem > ep->xfr_buf_len) {
			ep->xfr_rem = ep->xfr_buf_len;
			DCC_LOG(LOG_ERROR, "transfer to large to fit in the buffer!");
 8001342:	4824      	ldr	r0, [pc, #144]	; (80013d4 <stm32f_otg_fs_isr+0x59c>)
		ep->xfr_rem = req->length;

		DCC_LOG1(LOG_INFO, "xfr_ptr=0x%08x", ep->xfr_ptr);

		if (ep->xfr_rem > ep->xfr_buf_len) {
			ep->xfr_rem = ep->xfr_buf_len;
 8001344:	80b2      	strh	r2, [r6, #4]
			DCC_LOG(LOG_ERROR, "transfer to large to fit in the buffer!");
 8001346:	f003 f83f 	bl	80043c8 <ice_trace0>
 800134a:	88b3      	ldrh	r3, [r6, #4]
 800134c:	e7a6      	b.n	800129c <stm32f_otg_fs_isr+0x464>
		struct usb_request * req = &drv->req;
		void * dummy = NULL;

		if (((req->request << 8) | req->type) == STD_SET_ADDRESS) {
			DCC_LOG(LOG_INFO, "address set!");
			stm32f_otg_fs_addr_set(otg_fs, req->value);
 800134e:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8001352:	f8b6 106a 	ldrh.w	r1, [r6, #106]	; 0x6a
 8001356:	f000 f993 	bl	8001680 <stm32f_otg_fs_addr_set>
 800135a:	e7be      	b.n	80012da <stm32f_otg_fs_isr+0x4a2>

	if (ep->state == EP_WAIT_STATUS_IN) {
		struct usb_request * req = &drv->req;
		void * dummy = NULL;

		ep->on_setup(drv->cl, req, dummy);
 800135c:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001360:	f8da 0060 	ldr.w	r0, [sl, #96]	; 0x60
 8001364:	f10a 0168 	add.w	r1, sl, #104	; 0x68
 8001368:	2200      	movs	r2, #0
 800136a:	4798      	blx	r3
		ep->state = EP_IDLE;
 800136c:	2301      	movs	r3, #1
 800136e:	f88a 3000 	strb.w	r3, [sl]
 8001372:	e5ec      	b.n	8000f4e <stm32f_otg_fs_isr+0x116>
	}

	if (req->type & 0x80) {
		/* Control Read SETUP transaction (IN Data Phase) */
		DCC_LOG(LOG_INFO, "EP0 [SETUP] IN Dev->Host");
		ep->xfr_ptr = NULL;
 8001374:	f04f 0800 	mov.w	r8, #0
		len = ep->on_setup(drv->cl, req, (void *)&ep->xfr_ptr);
 8001378:	f106 0168 	add.w	r1, r6, #104	; 0x68
 800137c:	f106 020c 	add.w	r2, r6, #12
 8001380:	6973      	ldr	r3, [r6, #20]
	}

	if (req->type & 0x80) {
		/* Control Read SETUP transaction (IN Data Phase) */
		DCC_LOG(LOG_INFO, "EP0 [SETUP] IN Dev->Host");
		ep->xfr_ptr = NULL;
 8001382:	f8c6 800c 	str.w	r8, [r6, #12]
		len = ep->on_setup(drv->cl, req, (void *)&ep->xfr_ptr);
 8001386:	6e30      	ldr	r0, [r6, #96]	; 0x60
 8001388:	4798      	blx	r3
		ep->xfr_rem = MIN(req->length, len);
 800138a:	f8b6 306e 	ldrh.w	r3, [r6, #110]	; 0x6e
 800138e:	4298      	cmp	r0, r3
 8001390:	bfb8      	it	lt
 8001392:	4603      	movlt	r3, r0
		DCC_LOG1(LOG_INFO, "EP0 data lenght = %d", ep->xfr_rem);
		/* prepare fifo to transmit */
		if (stm32f_otg_fs_txf_setup(otg_fs, 0, ep->xfr_rem) < 0) {
 8001394:	4641      	mov	r1, r8
 8001396:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 800139a:	b29a      	uxth	r2, r3
	if (req->type & 0x80) {
		/* Control Read SETUP transaction (IN Data Phase) */
		DCC_LOG(LOG_INFO, "EP0 [SETUP] IN Dev->Host");
		ep->xfr_ptr = NULL;
		len = ep->on_setup(drv->cl, req, (void *)&ep->xfr_ptr);
		ep->xfr_rem = MIN(req->length, len);
 800139c:	80b3      	strh	r3, [r6, #4]
		DCC_LOG1(LOG_INFO, "EP0 data lenght = %d", ep->xfr_rem);
		/* prepare fifo to transmit */
		if (stm32f_otg_fs_txf_setup(otg_fs, 0, ep->xfr_rem) < 0) {
 800139e:	f000 f9b9 	bl	8001714 <stm32f_otg_fs_txf_setup>
 80013a2:	4540      	cmp	r0, r8
 80013a4:	db0c      	blt.n	80013c0 <stm32f_otg_fs_isr+0x588>
			DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_setup() failed!");
		} else {
			/* umask FIFO empty interrupt */
			otg_fs->diepempmsk |= (1 << 0);
 80013a6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 80013aa:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80013ae:	f042 0201 	orr.w	r2, r2, #1
 80013b2:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 80013b6:	e63b      	b.n	8001030 <stm32f_otg_fs_isr+0x1f8>
		DCC_LOG(LOG_INFO, "EP0 [IN_DATA]");
		return;
	} 
	
	if (stm32f_otg_fs_txf_setup(otg_fs, 0, ep->xfr_rem) < 0) {
		DCC_LOG(LOG_ERROR, "stm32f_otg_fs_txf_setup() failed!");
 80013b8:	4807      	ldr	r0, [pc, #28]	; (80013d8 <stm32f_otg_fs_isr+0x5a0>)
 80013ba:	f003 f805 	bl	80043c8 <ice_trace0>
 80013be:	e5c6      	b.n	8000f4e <stm32f_otg_fs_isr+0x116>
		len = ep->on_setup(drv->cl, req, (void *)&ep->xfr_ptr);
		ep->xfr_rem = MIN(req->length, len);
		DCC_LOG1(LOG_INFO, "EP0 data lenght = %d", ep->xfr_rem);
		/* prepare fifo to transmit */
		if (stm32f_otg_fs_txf_setup(otg_fs, 0, ep->xfr_rem) < 0) {
			DCC_LOG(LOG_WARNING, "stm32f_otg_fs_txf_setup() failed!");
 80013c0:	4806      	ldr	r0, [pc, #24]	; (80013dc <stm32f_otg_fs_isr+0x5a4>)
 80013c2:	f003 f801 	bl	80043c8 <ice_trace0>
 80013c6:	e633      	b.n	8001030 <stm32f_otg_fs_isr+0x1f8>
 80013c8:	2000000c 	.word	0x2000000c
 80013cc:	20000074 	.word	0x20000074
 80013d0:	40000060 	.word	0x40000060
 80013d4:	400000a0 	.word	0x400000a0
 80013d8:	40000080 	.word	0x40000080
 80013dc:	40000090 	.word	0x40000090

080013e0 <_halt>:
 80013e0:	f7ff bffe 	b.w	80013e0 <_halt>

080013e4 <_isr>:
 80013e4:	f3ef 8005 	mrs	r0, IPSR
 80013e8:	3810      	subs	r0, #16
 80013ea:	f000 be59 	b.w	80020a0 <cm3_default_isr>
 80013ee:	bf00      	nop

080013f0 <_void>:
 80013f0:	4770      	bx	lr
 80013f2:	bf00      	nop

080013f4 <_reset>:
 80013f4:	b672      	cpsid	i
 80013f6:	f000 f833 	bl	8001460 <_init>
 80013fa:	f8df 2048 	ldr.w	r2, [pc, #72]	; 8001444 <_reset+0x50>
 80013fe:	4b12      	ldr	r3, [pc, #72]	; (8001448 <_reset+0x54>)
 8001400:	4c0f      	ldr	r4, [pc, #60]	; (8001440 <_reset+0x4c>)
 8001402:	429a      	cmp	r2, r3
 8001404:	bf3e      	ittt	cc
 8001406:	f854 7b04 	ldrcc.w	r7, [r4], #4
 800140a:	f842 7b04 	strcc.w	r7, [r2], #4
 800140e:	e7f8      	bcc.n	8001402 <_reset+0xe>
 8001410:	4a0e      	ldr	r2, [pc, #56]	; (800144c <_reset+0x58>)
 8001412:	4b0f      	ldr	r3, [pc, #60]	; (8001450 <_reset+0x5c>)
 8001414:	f04f 0700 	mov.w	r7, #0
 8001418:	429a      	cmp	r2, r3
 800141a:	bf3c      	itt	cc
 800141c:	f842 7b04 	strcc.w	r7, [r2], #4
 8001420:	e7fa      	bcc.n	8001418 <_reset+0x24>
 8001422:	4d0d      	ldr	r5, [pc, #52]	; (8001458 <_reset+0x64>)
 8001424:	4e0d      	ldr	r6, [pc, #52]	; (800145c <_reset+0x68>)
 8001426:	42b5      	cmp	r5, r6
 8001428:	d003      	beq.n	8001432 <_reset+0x3e>
 800142a:	f855 4b04 	ldr.w	r4, [r5], #4
 800142e:	47a0      	blx	r4
 8001430:	e7f9      	b.n	8001426 <_reset+0x32>
 8001432:	f04f 0000 	mov.w	r0, #0
 8001436:	4601      	mov	r1, r0
 8001438:	f7fe feaa 	bl	8000190 <main>
 800143c:	f7ff bfda 	b.w	80013f4 <_reset>
 8001440:	08005518 	.word	0x08005518
 8001444:	20000000 	.word	0x20000000
 8001448:	20000008 	.word	0x20000008
 800144c:	20000008 	.word	0x20000008
 8001450:	20000f24 	.word	0x20000f24
 8001454:	20000f24 	.word	0x20000f24
 8001458:	08005518 	.word	0x08005518
 800145c:	08005518 	.word	0x08005518

08001460 <_init>:
	/* remap the SRAM to 0x00000000  */
	syscfg->memrmp = SYSCFG_MEM_MODE_SRAM;
#endif

	/* Make sure we are using the internal oscillator */
	rcc->cfgr = RCC_PPRE2_1 | RCC_PPRE1_1 | RCC_HPRE_1 | RCC_SW_HSI;
 8001460:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8001464:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8001468:	2300      	movs	r3, #0
 800146a:	608b      	str	r3, [r1, #8]

	/* Enable external oscillator */
	cr = rcc->cr;
 800146c:	680b      	ldr	r3, [r1, #0]
	cr |= RCC_HSEON;
 800146e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
	rcc->cr = cr;;
 8001472:	600b      	str	r3, [r1, #0]

	for (again = 8192; ; again--) {
		cr = rcc->cr;
 8001474:	680a      	ldr	r2, [r1, #0]
		if (cr & RCC_HSERDY)
 8001476:	0393      	lsls	r3, r2, #14
 8001478:	d407      	bmi.n	800148a <_init+0x2a>
 800147a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800147e:	e001      	b.n	8001484 <_init+0x24>
			break;
		if (again == 0) {
 8001480:	3b01      	subs	r3, #1
 8001482:	d041      	beq.n	8001508 <_init+0xa8>
	cr = rcc->cr;
	cr |= RCC_HSEON;
	rcc->cr = cr;;

	for (again = 8192; ; again--) {
		cr = rcc->cr;
 8001484:	680a      	ldr	r2, [r1, #0]
		if (cr & RCC_HSERDY)
 8001486:	0390      	lsls	r0, r2, #14
 8001488:	d5fa      	bpl.n	8001480 <_init+0x20>
//#error "HSE_HZ invalid!"
#endif

#endif

	rcc->pllcfgr = pll;
 800148a:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 800148e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8001492:	f641 4004 	movw	r0, #7172	; 0x1c04
		| RCC_PPRE2_2 /* APB high speed prescaler : 60|84MHz */
		| RCC_PPRE1_4 /* APB low speed prescaler : 30|42MHz */
		| RCC_HPRE_1 /* AHB prescaler : 120|168MHz */ 
		| RCC_SW_HSE;
	
	rcc->cfgr = cfg;
 8001496:	f249 4301 	movw	r3, #37889	; 0x9401
 800149a:	f2c2 0300 	movt	r3, #8192	; 0x2000
//#error "HSE_HZ invalid!"
#endif

#endif

	rcc->pllcfgr = pll;
 800149e:	f2c0 7040 	movt	r0, #1856	; 0x740
		| RCC_SW_HSE;
	
	rcc->cfgr = cfg;

	/* enable PLL */
	cr |= RCC_PLLON;
 80014a2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
//#error "HSE_HZ invalid!"
#endif

#endif

	rcc->pllcfgr = pll;
 80014a6:	6048      	str	r0, [r1, #4]
		| RCC_PPRE2_2 /* APB high speed prescaler : 60|84MHz */
		| RCC_PPRE1_4 /* APB low speed prescaler : 30|42MHz */
		| RCC_HPRE_1 /* AHB prescaler : 120|168MHz */ 
		| RCC_SW_HSE;
	
	rcc->cfgr = cfg;
 80014a8:	608b      	str	r3, [r1, #8]

	/* enable PLL */
	cr |= RCC_PLLON;
	rcc->cr = cr;;
 80014aa:	600a      	str	r2, [r1, #0]

	for (again = 8192; ; again--) {
		cr = rcc->cr;
 80014ac:	680b      	ldr	r3, [r1, #0]
		if (cr & RCC_PLLRDY)
 80014ae:	019b      	lsls	r3, r3, #6
 80014b0:	d407      	bmi.n	80014c2 <_init+0x62>
 80014b2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80014b6:	e001      	b.n	80014bc <_init+0x5c>
			break;
		if (again == 0) {
 80014b8:	3b01      	subs	r3, #1
 80014ba:	d025      	beq.n	8001508 <_init+0xa8>
	/* enable PLL */
	cr |= RCC_PLLON;
	rcc->cr = cr;;

	for (again = 8192; ; again--) {
		cr = rcc->cr;
 80014bc:	680a      	ldr	r2, [r1, #0]
		if (cr & RCC_PLLRDY)
 80014be:	0190      	lsls	r0, r2, #6
 80014c0:	d5fa      	bpl.n	80014b8 <_init+0x58>
			return;
		}
	}

	for (again = 4096; ; again--) {
		sr = flash->sr;
 80014c2:	f44f 5170 	mov.w	r1, #15360	; 0x3c00
 80014c6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80014ca:	68cb      	ldr	r3, [r1, #12]
		if ((sr & FLASH_BSY) == 0)
 80014cc:	03db      	lsls	r3, r3, #15
 80014ce:	d507      	bpl.n	80014e0 <_init+0x80>
 80014d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80014d4:	e001      	b.n	80014da <_init+0x7a>
			break;
		if (again == 0) {
 80014d6:	3b01      	subs	r3, #1
 80014d8:	d016      	beq.n	8001508 <_init+0xa8>
			return;
		}
	}

	for (again = 4096; ; again--) {
		sr = flash->sr;
 80014da:	68ca      	ldr	r2, [r1, #12]
		if ((sr & FLASH_BSY) == 0)
 80014dc:	03d2      	lsls	r2, r2, #15
 80014de:	d4fa      	bmi.n	80014d6 <_init+0x76>
	}

	ws = HCLK_HZ / 30000000;

	/* adjust flash wait states and enable caches */
	flash->acr = FLASH_DCEN | FLASH_ICEN | FLASH_PRFTEN | FLASH_LATENCY(ws);
 80014e0:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80014e4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80014e8:	f240 7205 	movw	r2, #1797	; 0x705
 80014ec:	601a      	str	r2, [r3, #0]

	if (flash->cr & FLASH_LOCK) {
 80014ee:	691a      	ldr	r2, [r3, #16]
 80014f0:	2a00      	cmp	r2, #0
 80014f2:	db0a      	blt.n	800150a <_init+0xaa>
		flash->keyr = FLASH_KEY1;
		flash->keyr = FLASH_KEY2;
	}

	/* switch to pll oscillator */
	rcc->cfgr = (cfg & ~RCC_SW) | RCC_SW_PLL;
 80014f4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80014f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80014fc:	f249 4202 	movw	r2, #37890	; 0x9402
 8001500:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001504:	609a      	str	r2, [r3, #8]
 8001506:	4770      	bx	lr
 8001508:	4770      	bx	lr
	/* adjust flash wait states and enable caches */
	flash->acr = FLASH_DCEN | FLASH_ICEN | FLASH_PRFTEN | FLASH_LATENCY(ws);

	if (flash->cr & FLASH_LOCK) {
		/* unlock flash write */
		flash->keyr = FLASH_KEY1;
 800150a:	f240 1123 	movw	r1, #291	; 0x123
		flash->keyr = FLASH_KEY2;
 800150e:	f648 12ab 	movw	r2, #35243	; 0x89ab
	/* adjust flash wait states and enable caches */
	flash->acr = FLASH_DCEN | FLASH_ICEN | FLASH_PRFTEN | FLASH_LATENCY(ws);

	if (flash->cr & FLASH_LOCK) {
		/* unlock flash write */
		flash->keyr = FLASH_KEY1;
 8001512:	f2c4 5167 	movt	r1, #17767	; 0x4567
		flash->keyr = FLASH_KEY2;
 8001516:	f6cc 52ef 	movt	r2, #52719	; 0xcdef
	/* adjust flash wait states and enable caches */
	flash->acr = FLASH_DCEN | FLASH_ICEN | FLASH_PRFTEN | FLASH_LATENCY(ws);

	if (flash->cr & FLASH_LOCK) {
		/* unlock flash write */
		flash->keyr = FLASH_KEY1;
 800151a:	6059      	str	r1, [r3, #4]
		flash->keyr = FLASH_KEY2;
 800151c:	605a      	str	r2, [r3, #4]
 800151e:	e7e9      	b.n	80014f4 <_init+0x94>

08001520 <stm32_usart_lookup>:
	{ STM32_CLK_UART5 }
};
#endif

int stm32_usart_lookup(struct stm32_usart * usart)
{
 8001520:	4905      	ldr	r1, [pc, #20]	; (8001538 <stm32_usart_lookup+0x18>)
	int id = sizeof(stm32_usart_lut) / sizeof(struct stm32_usart *);

	while ((--id >= 0) && (usart != stm32_usart_lut[id]));
 8001522:	2304      	movs	r3, #4
 8001524:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 8001528:	4282      	cmp	r2, r0
 800152a:	d002      	beq.n	8001532 <stm32_usart_lookup+0x12>
 800152c:	f113 33ff 	adds.w	r3, r3, #4294967295
 8001530:	d2f8      	bcs.n	8001524 <stm32_usart_lookup+0x4>

	return id;
}
 8001532:	4618      	mov	r0, r3
 8001534:	4770      	bx	lr
 8001536:	bf00      	nop
 8001538:	08004ce4 	.word	0x08004ce4

0800153c <stm32_usart_power_off>:
 */

#include "usart-priv.h"

int stm32_usart_power_off(struct stm32_usart * us)
{
 800153c:	b510      	push	{r4, lr}
 800153e:	4604      	mov	r4, r0
	int id;

	if ((id = stm32_usart_lookup(us)) < 0) {
 8001540:	f7ff ffee 	bl	8001520 <stm32_usart_lookup>
 8001544:	2800      	cmp	r0, #0
 8001546:	db1a      	blt.n	800157e <stm32_usart_power_off+0x42>

	/* disable TX, RX and all interrupts */
	us->cr1 = 0;

	/* Disable peripheral clock */
	stm32_clk_disable(STM32_RCC, stm32_usart_clk_lut[id].bus,
 8001548:	4b1f      	ldr	r3, [pc, #124]	; (80015c8 <stm32_usart_power_off+0x8c>)
 800154a:	5c1a      	ldrb	r2, [r3, r0]
 800154c:	f002 0307 	and.w	r3, r2, #7
		/* invalid UART ??? */
		return id;
	}

	/* disable TX, RX and all interrupts */
	us->cr1 = 0;
 8001550:	2100      	movs	r1, #0

	/* Disable peripheral clock */
	stm32_clk_disable(STM32_RCC, stm32_usart_clk_lut[id].bus,
 8001552:	08d2      	lsrs	r2, r2, #3
}

static inline void stm32_clk_disable(struct stm32_rcc * rcc, 
									 int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr &= ~(1 << bit);
 8001554:	f44f 5060 	mov.w	r0, #14336	; 0x3800
#endif
}

static inline void stm32_clk_disable(struct stm32_rcc * rcc, 
									 int bus, int bit) {
	if (bus == STM32_APB2)
 8001558:	2b02      	cmp	r3, #2
		/* invalid UART ??? */
		return id;
	}

	/* disable TX, RX and all interrupts */
	us->cr1 = 0;
 800155a:	60e1      	str	r1, [r4, #12]
		rcc->apb2enr &= ~(1 << bit);
 800155c:	f2c4 0002 	movt	r0, #16386	; 0x4002
#endif
}

static inline void stm32_clk_disable(struct stm32_rcc * rcc, 
									 int bus, int bit) {
	if (bus == STM32_APB2)
 8001560:	d016      	beq.n	8001590 <stm32_usart_power_off+0x54>
		rcc->apb2enr &= ~(1 << bit);
	else if (bus == STM32_APB1)
 8001562:	2b01      	cmp	r3, #1
 8001564:	d00c      	beq.n	8001580 <stm32_usart_power_off+0x44>
		rcc->apb1enr &= ~(1 << bit);
#if defined(STM32F1X) || defined(STM32F3X)
	else
		rcc->ahbenr &= ~(1 << bit);
#else
	else if (bus == STM32_AHB2)
 8001566:	2b03      	cmp	r3, #3
 8001568:	d01b      	beq.n	80015a2 <stm32_usart_power_off+0x66>
		rcc->ahb2enr &= ~(1 << bit);
	else if (bus == STM32_AHB3)
 800156a:	2b04      	cmp	r3, #4
 800156c:	d022      	beq.n	80015b4 <stm32_usart_power_off+0x78>
		rcc->ahb3enr &= ~(1 << bit);
	else
		rcc->ahb1enr &= ~(1 << bit);
 800156e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8001570:	2301      	movs	r3, #1
 8001572:	fa03 f202 	lsl.w	r2, r3, r2
 8001576:	ea24 0202 	bic.w	r2, r4, r2
 800157a:	6302      	str	r2, [r0, #48]	; 0x30

	/* Disable peripheral clock */
	stm32_clk_disable(STM32_RCC, stm32_usart_clk_lut[id].bus,
					  stm32_usart_clk_lut[id].bit);

	return 0;
 800157c:	4608      	mov	r0, r1
}
 800157e:	bd10      	pop	{r4, pc}
static inline void stm32_clk_disable(struct stm32_rcc * rcc, 
									 int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr &= ~(1 << bit);
	else if (bus == STM32_APB1)
		rcc->apb1enr &= ~(1 << bit);
 8001580:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8001582:	fa03 f202 	lsl.w	r2, r3, r2
 8001586:	ea24 0202 	bic.w	r2, r4, r2
 800158a:	6402      	str	r2, [r0, #64]	; 0x40

	/* Disable peripheral clock */
	stm32_clk_disable(STM32_RCC, stm32_usart_clk_lut[id].bus,
					  stm32_usart_clk_lut[id].bit);

	return 0;
 800158c:	4608      	mov	r0, r1
 800158e:	bd10      	pop	{r4, pc}
}

static inline void stm32_clk_disable(struct stm32_rcc * rcc, 
									 int bus, int bit) {
	if (bus == STM32_APB2)
		rcc->apb2enr &= ~(1 << bit);
 8001590:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8001592:	2301      	movs	r3, #1
 8001594:	fa03 f202 	lsl.w	r2, r3, r2
 8001598:	ea24 0202 	bic.w	r2, r4, r2
 800159c:	6442      	str	r2, [r0, #68]	; 0x44
 800159e:	4608      	mov	r0, r1
 80015a0:	bd10      	pop	{r4, pc}
#if defined(STM32F1X) || defined(STM32F3X)
	else
		rcc->ahbenr &= ~(1 << bit);
#else
	else if (bus == STM32_AHB2)
		rcc->ahb2enr &= ~(1 << bit);
 80015a2:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80015a4:	2301      	movs	r3, #1
 80015a6:	fa03 f202 	lsl.w	r2, r3, r2
 80015aa:	ea24 0202 	bic.w	r2, r4, r2
 80015ae:	6342      	str	r2, [r0, #52]	; 0x34
 80015b0:	4608      	mov	r0, r1
 80015b2:	bd10      	pop	{r4, pc}
	else if (bus == STM32_AHB3)
		rcc->ahb3enr &= ~(1 << bit);
 80015b4:	6b84      	ldr	r4, [r0, #56]	; 0x38
 80015b6:	2301      	movs	r3, #1
 80015b8:	fa03 f202 	lsl.w	r2, r3, r2
 80015bc:	ea24 0202 	bic.w	r2, r4, r2
 80015c0:	6382      	str	r2, [r0, #56]	; 0x38
 80015c2:	4608      	mov	r0, r1
 80015c4:	bd10      	pop	{r4, pc}
 80015c6:	bf00      	nop
 80015c8:	08004cf8 	.word	0x08004cf8

080015cc <stm32_usart_flush>:

int stm32_usart_flush(struct stm32_usart * usart)
{
	int c;

	while (!(usart->isr & USART_TC));
 80015cc:	6803      	ldr	r3, [r0, #0]
 80015ce:	065b      	lsls	r3, r3, #25
 80015d0:	d5fc      	bpl.n	80015cc <stm32_usart_flush>

	/* clear buffered chars */
	c = usart->rdr;
 80015d2:	6843      	ldr	r3, [r0, #4]
	(void)c;

	return 0;
}
 80015d4:	2000      	movs	r0, #0
 80015d6:	4770      	bx	lr

080015d8 <stm32_usart_read>:

#include "usart-priv.h"

int stm32_usart_read(struct stm32_usart * usart, char * buf, 
					  unsigned int len, unsigned int msec)
{
 80015d8:	b510      	push	{r4, lr}
 80015da:	460c      	mov	r4, r1
	char * cp = (char *)buf;
	int c;

	DCC_LOG1(LOG_MSG, "msec=%d", msec);

	c = stm32_usart_getc(usart, msec);
 80015dc:	4619      	mov	r1, r3
 80015de:	f000 f9b7 	bl	8001950 <stm32_usart_getc>

	if (c < 0)
 80015e2:	2800      	cmp	r0, #0
		return c;

	*cp = c;
 80015e4:	bfa4      	itt	ge
 80015e6:	7020      	strbge	r0, [r4, #0]
		
	return 1;
 80015e8:	2001      	movge	r0, #1
}
 80015ea:	bd10      	pop	{r4, pc}

080015ec <stm32_usart_canon_write>:

#include "usart-priv.h"

int stm32_usart_canon_write(struct stm32_usart * usart, const void * buf,
							 unsigned int len)
{
 80015ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char * cp = (char *)buf;
	int c;
	int n;

	for (n = 0; n < len; n++) {
 80015f0:	4617      	mov	r7, r2

#include "usart-priv.h"

int stm32_usart_canon_write(struct stm32_usart * usart, const void * buf,
							 unsigned int len)
{
 80015f2:	4606      	mov	r6, r0
 80015f4:	4688      	mov	r8, r1
	char * cp = (char *)buf;
	int c;
	int n;

	for (n = 0; n < len; n++) {
 80015f6:	b19a      	cbz	r2, 8001620 <stm32_usart_canon_write+0x34>
 80015f8:	2300      	movs	r3, #0
 80015fa:	461c      	mov	r4, r3
 80015fc:	e006      	b.n	800160c <stm32_usart_canon_write+0x20>
		c = cp[n];
		if (c == '\n')
			stm32_usart_putc(usart, '\r');
		stm32_usart_putc(usart, c);
 80015fe:	4630      	mov	r0, r6
 8001600:	4629      	mov	r1, r5
 8001602:	f000 f9bb 	bl	800197c <stm32_usart_putc>
{
	char * cp = (char *)buf;
	int c;
	int n;

	for (n = 0; n < len; n++) {
 8001606:	42bc      	cmp	r4, r7
 8001608:	4623      	mov	r3, r4
 800160a:	d00a      	beq.n	8001622 <stm32_usart_canon_write+0x36>
		c = cp[n];
 800160c:	f818 5003 	ldrb.w	r5, [r8, r3]
{
	char * cp = (char *)buf;
	int c;
	int n;

	for (n = 0; n < len; n++) {
 8001610:	3401      	adds	r4, #1
		c = cp[n];
		if (c == '\n')
 8001612:	2d0a      	cmp	r5, #10
 8001614:	d1f3      	bne.n	80015fe <stm32_usart_canon_write+0x12>
			stm32_usart_putc(usart, '\r');
 8001616:	210d      	movs	r1, #13
 8001618:	4630      	mov	r0, r6
 800161a:	f000 f9af 	bl	800197c <stm32_usart_putc>
 800161e:	e7ee      	b.n	80015fe <stm32_usart_canon_write+0x12>
{
	char * cp = (char *)buf;
	int c;
	int n;

	for (n = 0; n < len; n++) {
 8001620:	4614      	mov	r4, r2
			stm32_usart_putc(usart, '\r');
		stm32_usart_putc(usart, c);
	}

	return n;
}
 8001622:	4620      	mov	r0, r4
 8001624:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001628 <stm32f_otg_fs_core_reset>:
void stm32f_otg_fs_core_reset(struct stm32f_otg_fs * otg_fs)
{
	DCC_LOG(LOG_INFO, "...");

	/* Wait for AHB master IDLE state. */
	while (!(otg_fs->grstctl & OTG_FS_AHBIDL)) {
 8001628:	6903      	ldr	r3, [r0, #16]
 800162a:	2b00      	cmp	r3, #0
#include <sys/delay.h>

#ifdef STM32F_OTG_FS

void stm32f_otg_fs_core_reset(struct stm32f_otg_fs * otg_fs)
{
 800162c:	b510      	push	{r4, lr}
 800162e:	4604      	mov	r4, r0
	DCC_LOG(LOG_INFO, "...");

	/* Wait for AHB master IDLE state. */
	while (!(otg_fs->grstctl & OTG_FS_AHBIDL)) {
 8001630:	db05      	blt.n	800163e <stm32f_otg_fs_core_reset+0x16>
		udelay(3);
 8001632:	2003      	movs	r0, #3
 8001634:	f000 f9cc 	bl	80019d0 <udelay>
void stm32f_otg_fs_core_reset(struct stm32f_otg_fs * otg_fs)
{
	DCC_LOG(LOG_INFO, "...");

	/* Wait for AHB master IDLE state. */
	while (!(otg_fs->grstctl & OTG_FS_AHBIDL)) {
 8001638:	6923      	ldr	r3, [r4, #16]
 800163a:	2b00      	cmp	r3, #0
 800163c:	daf9      	bge.n	8001632 <stm32f_otg_fs_core_reset+0xa>
		udelay(3);
	}

	/* Core Soft Reset */
	otg_fs->grstctl = OTG_FS_CSRST;
 800163e:	2301      	movs	r3, #1
 8001640:	6123      	str	r3, [r4, #16]
	do {
		udelay(3);
 8001642:	2003      	movs	r0, #3
 8001644:	f000 f9c4 	bl	80019d0 <udelay>
	} while (otg_fs->grstctl & OTG_FS_CSRST);
 8001648:	6923      	ldr	r3, [r4, #16]
 800164a:	07db      	lsls	r3, r3, #31
 800164c:	d4f9      	bmi.n	8001642 <stm32f_otg_fs_core_reset+0x1a>

	/* Wait for 3 PHY Clocks*/
	udelay(3);
 800164e:	2003      	movs	r0, #3
}
 8001650:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	do {
		udelay(3);
	} while (otg_fs->grstctl & OTG_FS_CSRST);

	/* Wait for 3 PHY Clocks*/
	udelay(3);
 8001654:	f000 b9bc 	b.w	80019d0 <udelay>

08001658 <stm32f_otg_fs_txfifo_flush>:
void stm32f_otg_fs_txfifo_flush(struct stm32f_otg_fs * otg_fs, 
								unsigned int num)
{
	DCC_LOG1(LOG_INFO, "%02x", num);

	otg_fs->grstctl = OTG_FS_TXFFLSH | OTG_FS_TXFIFO_SET(num);
 8001658:	0189      	lsls	r1, r1, #6
 800165a:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
 800165e:	f041 0120 	orr.w	r1, r1, #32
 8001662:	6101      	str	r1, [r0, #16]
	do {
	} while (otg_fs->grstctl & OTG_FS_TXFFLSH);
 8001664:	6903      	ldr	r3, [r0, #16]
 8001666:	069a      	lsls	r2, r3, #26
 8001668:	d4fc      	bmi.n	8001664 <stm32f_otg_fs_txfifo_flush+0xc>
	/* Wait for 3 PHY Clocks ?? */
	udelay(3);
 800166a:	2003      	movs	r0, #3
 800166c:	f000 b9b0 	b.w	80019d0 <udelay>

08001670 <stm32f_otg_fs_rxfifo_flush>:

void stm32f_otg_fs_rxfifo_flush(struct stm32f_otg_fs * otg_fs)
{
	DCC_LOG(LOG_INFO, "...");

	otg_fs->grstctl = OTG_FS_RXFFLSH;
 8001670:	2310      	movs	r3, #16
 8001672:	6103      	str	r3, [r0, #16]
	do {
	} while (otg_fs->grstctl & OTG_FS_RXFFLSH);
 8001674:	6903      	ldr	r3, [r0, #16]
 8001676:	06d9      	lsls	r1, r3, #27
 8001678:	d4fc      	bmi.n	8001674 <stm32f_otg_fs_rxfifo_flush+0x4>
	/* Wait for 3 PHY Clocks ?? */
	udelay(3);
 800167a:	2003      	movs	r0, #3
 800167c:	f000 b9a8 	b.w	80019d0 <udelay>

08001680 <stm32f_otg_fs_addr_set>:

	/* This section describes what the application must do when it 
	   receives a SetAddress command in a SETUP packet.
	   1. Program the OTG_FS_DCFG register with the device address 
	   received in the SetAddress command */
	dcfg = otg_fs->dcfg; 
 8001680:	f8d0 2800 	ldr.w	r2, [r0, #2048]	; 0x800
	dcfg &= ~OTG_FS_DAD_MSK;
	dcfg |= OTG_FS_DAD_SET(addr);
 8001684:	0109      	lsls	r1, r1, #4
 8001686:	f401 63fe 	and.w	r3, r1, #2032	; 0x7f0
	/* This section describes what the application must do when it 
	   receives a SetAddress command in a SETUP packet.
	   1. Program the OTG_FS_DCFG register with the device address 
	   received in the SetAddress command */
	dcfg = otg_fs->dcfg; 
	dcfg &= ~OTG_FS_DAD_MSK;
 800168a:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
	dcfg |= OTG_FS_DAD_SET(addr);
 800168e:	4313      	orrs	r3, r2
	otg_fs->dcfg = dcfg;
 8001690:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
 8001694:	4770      	bx	lr
 8001696:	bf00      	nop

08001698 <stm32f_otg_fs_ep_disable>:
	int input = addr & 0x80;

	DCC_LOG2(LOG_INFO, "ep_id=%d %s", ep_id, input ? "IN" : "OUT");

	/* Diable endpoint interrupt */
	otg_fs->daintmsk &= ~OTG_FS_IEPM(ep_id);
 8001698:	2201      	movs	r2, #1

	/* 2. Program the core to send out a status IN packet */
}

void stm32f_otg_fs_ep_disable(struct stm32f_otg_fs * otg_fs, unsigned int addr)
{
 800169a:	b410      	push	{r4}
	int ep_id = addr & 0x7f;
 800169c:	f001 037f 	and.w	r3, r1, #127	; 0x7f
	int input = addr & 0x80;

	DCC_LOG2(LOG_INFO, "ep_id=%d %s", ep_id, input ? "IN" : "OUT");

	/* Diable endpoint interrupt */
	otg_fs->daintmsk &= ~OTG_FS_IEPM(ep_id);
 80016a0:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 80016a4:	fa02 f203 	lsl.w	r2, r2, r3
 80016a8:	ea24 0202 	bic.w	r2, r4, r2
 80016ac:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c

	/* Disable endpoint */
	if (input) {
 80016b0:	060a      	lsls	r2, r1, #24
 80016b2:	d407      	bmi.n	80016c4 <stm32f_otg_fs_ep_disable+0x2c>
		otg_fs->inep[ep_id].diepctl &= ~OTG_FS_USBAEP;
	} else {
		otg_fs->outep[ep_id].doepctl &= ~OTG_FS_USBAEP;
 80016b4:	3358      	adds	r3, #88	; 0x58
 80016b6:	015b      	lsls	r3, r3, #5
 80016b8:	58c2      	ldr	r2, [r0, r3]
 80016ba:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80016be:	50c2      	str	r2, [r0, r3]
	}
}
 80016c0:	bc10      	pop	{r4}
 80016c2:	4770      	bx	lr
	/* Diable endpoint interrupt */
	otg_fs->daintmsk &= ~OTG_FS_IEPM(ep_id);

	/* Disable endpoint */
	if (input) {
		otg_fs->inep[ep_id].diepctl &= ~OTG_FS_USBAEP;
 80016c4:	3348      	adds	r3, #72	; 0x48
 80016c6:	015b      	lsls	r3, r3, #5
 80016c8:	58c2      	ldr	r2, [r0, r3]
 80016ca:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80016ce:	50c2      	str	r2, [r0, r3]
 80016d0:	e7f6      	b.n	80016c0 <stm32f_otg_fs_ep_disable+0x28>
 80016d2:	bf00      	nop

080016d4 <stm32f_otg_fs_ep_out_start>:
	}
}

void stm32f_otg_fs_ep_out_start(struct stm32f_otg_fs * otg_fs,
								unsigned int addr, unsigned int mpsiz)
{
 80016d4:	b430      	push	{r4, r5}
	int ep_id = addr & 0x7f;
	uint32_t rxfsiz;
	uint32_t pktcnt;

	rxfsiz = otg_fs->grxfsiz * 4;
 80016d6:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80016d8:	00a4      	lsls	r4, r4, #2
	pktcnt = rxfsiz / mpsiz;
 80016da:	fbb4 f4f2 	udiv	r4, r4, r2

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
		OTG_FS_XFRSIZ_SET(pktcnt * mpsiz);
 80016de:	fb02 f204 	mul.w	r2, r2, r4

	rxfsiz = otg_fs->grxfsiz * 4;
	pktcnt = rxfsiz / mpsiz;

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 80016e2:	2300      	movs	r3, #0
}

void stm32f_otg_fs_ep_out_start(struct stm32f_otg_fs * otg_fs,
								unsigned int addr, unsigned int mpsiz)
{
	int ep_id = addr & 0x7f;
 80016e4:	f001 017f 	and.w	r1, r1, #127	; 0x7f

	rxfsiz = otg_fs->grxfsiz * 4;
	pktcnt = rxfsiz / mpsiz;

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 80016e8:	f6c1 73f8 	movt	r3, #8184	; 0x1ff8
		OTG_FS_XFRSIZ_SET(pktcnt * mpsiz);
 80016ec:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000

	rxfsiz = otg_fs->grxfsiz * 4;
	pktcnt = rxfsiz / mpsiz;

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 80016f0:	eb00 1541 	add.w	r5, r0, r1, lsl #5
		OTG_FS_XFRSIZ_SET(pktcnt * mpsiz);
 80016f4:	f422 0278 	bic.w	r2, r2, #16252928	; 0xf80000

	rxfsiz = otg_fs->grxfsiz * 4;
	pktcnt = rxfsiz / mpsiz;

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 80016f8:	ea03 44c4 	and.w	r4, r3, r4, lsl #19
		OTG_FS_XFRSIZ_SET(pktcnt * mpsiz);
	/* EP enable */
	otg_fs->outep[ep_id].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 80016fc:	3158      	adds	r1, #88	; 0x58
 80016fe:	0149      	lsls	r1, r1, #5

	rxfsiz = otg_fs->grxfsiz * 4;
	pktcnt = rxfsiz / mpsiz;

	/* Prepare EP_OUT to receive */
	otg_fs->outep[ep_id].doeptsiz = OTG_FS_PKTCNT_SET(pktcnt) |
 8001700:	ea42 0304 	orr.w	r3, r2, r4
 8001704:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
		OTG_FS_XFRSIZ_SET(pktcnt * mpsiz);
	/* EP enable */
	otg_fs->outep[ep_id].doepctl |= OTG_FS_EPENA | OTG_FS_CNAK;
 8001708:	5843      	ldr	r3, [r0, r1]
 800170a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800170e:	5043      	str	r3, [r0, r1]
}
 8001710:	bc30      	pop	{r4, r5}
 8001712:	4770      	bx	lr

08001714 <stm32f_otg_fs_txf_setup>:
	64, 32, 16, 8
};

int stm32f_otg_fs_txf_setup(struct stm32f_otg_fs * otg_fs, 
							unsigned int ep_id, unsigned int len)
{
 8001714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t depctl;
	uint32_t mpsiz;
	uint32_t xfrsiz;
	uint32_t pktcnt;

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
 8001716:	014f      	lsls	r7, r1, #5
 8001718:	19c3      	adds	r3, r0, r7
	64, 32, 16, 8
};

int stm32f_otg_fs_txf_setup(struct stm32f_otg_fs * otg_fs, 
							unsigned int ep_id, unsigned int len)
{
 800171a:	4604      	mov	r4, r0
	uint32_t depctl;
	uint32_t mpsiz;
	uint32_t xfrsiz;
	uint32_t pktcnt;

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
 800171c:	f8d3 6910 	ldr.w	r6, [r3, #2320]	; 0x910
	xfrsiz = OTG_FS_XFRSIZ_GET(deptsiz);
	pktcnt = OTG_FS_PKTCNT_GET(deptsiz);
 8001720:	f3c6 43c9 	ubfx	r3, r6, #19, #10
	uint32_t mpsiz;
	uint32_t xfrsiz;
	uint32_t pktcnt;

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
	xfrsiz = OTG_FS_XFRSIZ_GET(deptsiz);
 8001724:	f3c6 0c12 	ubfx	ip, r6, #0, #19
	pktcnt = OTG_FS_PKTCNT_GET(deptsiz);
	if ((xfrsiz == 0) && (pktcnt)) {
 8001728:	1c1e      	adds	r6, r3, #0
 800172a:	bf18      	it	ne
 800172c:	2601      	movne	r6, #1
 800172e:	f1bc 0f00 	cmp.w	ip, #0
 8001732:	bf18      	it	ne
 8001734:	2600      	movne	r6, #0
	64, 32, 16, 8
};

int stm32f_otg_fs_txf_setup(struct stm32f_otg_fs * otg_fs, 
							unsigned int ep_id, unsigned int len)
{
 8001736:	460d      	mov	r5, r1
 8001738:	4610      	mov	r0, r2
	uint32_t pktcnt;

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
	xfrsiz = OTG_FS_XFRSIZ_GET(deptsiz);
	pktcnt = OTG_FS_PKTCNT_GET(deptsiz);
	if ((xfrsiz == 0) && (pktcnt)) {
 800173a:	bb56      	cbnz	r6, 8001792 <stm32f_otg_fs_txf_setup+0x7e>
		DCC_LOG3(LOG_WARNING, "ep_id=%d len=%d %d outstanding packets in FIFO", 
				 ep_id, len, pktcnt);
		return -1;
	}

	depctl = otg_fs->inep[ep_id].diepctl;
 800173c:	f101 0248 	add.w	r2, r1, #72	; 0x48
 8001740:	0153      	lsls	r3, r2, #5
 8001742:	58e1      	ldr	r1, [r4, r3]
	if (ep_id == 0)
		mpsiz = OTGFS_EP0_MPSIZ_GET(depctl);
 8001744:	054b      	lsls	r3, r1, #21
 8001746:	0d5b      	lsrs	r3, r3, #21
				 ep_id, len, pktcnt);
		return -1;
	}

	depctl = otg_fs->inep[ep_id].diepctl;
	if (ep_id == 0)
 8001748:	b90d      	cbnz	r5, 800174e <stm32f_otg_fs_txf_setup+0x3a>
		mpsiz = OTGFS_EP0_MPSIZ_GET(depctl);
 800174a:	4d15      	ldr	r5, [pc, #84]	; (80017a0 <stm32f_otg_fs_txf_setup+0x8c>)
 800174c:	5ceb      	ldrb	r3, [r5, r3]
	else
		mpsiz = OTG_FS_MPSIZ_GET(depctl);

	if (len > 0) {
 800174e:	f44f 2500 	mov.w	r5, #524288	; 0x80000
 8001752:	b1a0      	cbz	r0, 800177e <stm32f_otg_fs_txf_setup+0x6a>
		/* XXX: check whether to get rid of this division or not,
		 if the CM3 div is used it is not necessary.... */
		pktcnt = (len + (mpsiz - 1)) / mpsiz;
 8001754:	1e46      	subs	r6, r0, #1
 8001756:	18f6      	adds	r6, r6, r3
 8001758:	fbb6 f6f3 	udiv	r6, r6, r3
		if (pktcnt > 7) {
 800175c:	2e07      	cmp	r6, #7
			pktcnt = 7;
			xfrsiz = 7 * mpsiz;
 800175e:	bf84      	itt	hi
 8001760:	ebc3 00c3 	rsbhi	r0, r3, r3, lsl #3
 8001764:	f440 1560 	orrhi.w	r5, r0, #3670016	; 0x380000

	if (len > 0) {
		/* XXX: check whether to get rid of this division or not,
		 if the CM3 div is used it is not necessary.... */
		pktcnt = (len + (mpsiz - 1)) / mpsiz;
		if (pktcnt > 7) {
 8001768:	d809      	bhi.n	800177e <stm32f_otg_fs_txf_setup+0x6a>
 800176a:	2300      	movs	r3, #0
 800176c:	04f6      	lsls	r6, r6, #19
 800176e:	f6c1 73f8 	movt	r3, #8184	; 0x1ff8
 8001772:	f020 457f 	bic.w	r5, r0, #4278190080	; 0xff000000
 8001776:	4033      	ands	r3, r6
 8001778:	f425 0578 	bic.w	r5, r5, #16252928	; 0xf80000
 800177c:	431d      	orrs	r5, r3
		xfrsiz = 0;
	}

	DCC_LOG3(LOG_INFO, "ep_id=%d pktcnt=%d xfrsiz=%d", ep_id, pktcnt, xfrsiz);

	otg_fs->inep[ep_id].dieptsiz = OTG_FS_PKTCNT_SET(pktcnt) | 
 800177e:	19e7      	adds	r7, r4, r7
		OTG_FS_XFRSIZ_SET(xfrsiz); 
	/* enable end point, clear NACK */
	otg_fs->inep[ep_id].diepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK; 
 8001780:	0152      	lsls	r2, r2, #5
 8001782:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
		xfrsiz = 0;
	}

	DCC_LOG3(LOG_INFO, "ep_id=%d pktcnt=%d xfrsiz=%d", ep_id, pktcnt, xfrsiz);

	otg_fs->inep[ep_id].dieptsiz = OTG_FS_PKTCNT_SET(pktcnt) | 
 8001786:	f8c7 5910 	str.w	r5, [r7, #2320]	; 0x910
		OTG_FS_XFRSIZ_SET(xfrsiz); 
	/* enable end point, clear NACK */
	otg_fs->inep[ep_id].diepctl = depctl | OTG_FS_EPENA | OTG_FS_CNAK; 
 800178a:	50a1      	str	r1, [r4, r2]

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
 800178c:	f8d7 3910 	ldr.w	r3, [r7, #2320]	; 0x910

	DCC_LOG2(LOG_INFO, "PKTCNT=%d XFRSIZ=%d", OTG_FS_PKTCNT_GET(deptsiz), 
			 OTG_FS_XFRSIZ_GET(deptsiz));

	return xfrsiz;
}
 8001790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	deptsiz = otg_fs->inep[ep_id].dieptsiz;
	xfrsiz = OTG_FS_XFRSIZ_GET(deptsiz);
	pktcnt = OTG_FS_PKTCNT_GET(deptsiz);
	if ((xfrsiz == 0) && (pktcnt)) {
		DCC_LOG3(LOG_WARNING, "ep_id=%d len=%d %d outstanding packets in FIFO", 
 8001792:	4804      	ldr	r0, [pc, #16]	; (80017a4 <stm32f_otg_fs_txf_setup+0x90>)
 8001794:	f002 fea0 	bl	80044d8 <ice_trace3>
				 ep_id, len, pktcnt);
		return -1;
 8001798:	f04f 30ff 	mov.w	r0, #4294967295
 800179c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800179e:	bf00      	nop
 80017a0:	08004d08 	.word	0x08004d08
 80017a4:	400000b0 	.word	0x400000b0

080017a8 <stm32f_otg_fs_txf_push>:
	return xfrsiz;
}

int stm32f_otg_fs_txf_push(struct stm32f_otg_fs * otg_fs, unsigned int ep_id,
						   void * buf)
{
 80017a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t * cp;
	int cnt;
	int i;

	free = otg_fs->inep[ep_id].dtxfsts * 4;
	depctl = otg_fs->inep[ep_id].diepctl;
 80017aa:	f101 0348 	add.w	r3, r1, #72	; 0x48
	uint32_t data;
	uint8_t * cp;
	int cnt;
	int i;

	free = otg_fs->inep[ep_id].dtxfsts * 4;
 80017ae:	eb00 1441 	add.w	r4, r0, r1, lsl #5
	depctl = otg_fs->inep[ep_id].diepctl;
 80017b2:	015b      	lsls	r3, r3, #5
	uint32_t data;
	uint8_t * cp;
	int cnt;
	int i;

	free = otg_fs->inep[ep_id].dtxfsts * 4;
 80017b4:	f8d4 5918 	ldr.w	r5, [r4, #2328]	; 0x918
	depctl = otg_fs->inep[ep_id].diepctl;
 80017b8:	58c3      	ldr	r3, [r0, r3]
	deptsiz = otg_fs->inep[ep_id].dieptsiz;
 80017ba:	f8d4 7910 	ldr.w	r7, [r4, #2320]	; 0x910

	if (ep_id == 0)
		mpsiz = OTGFS_EP0_MPSIZ_GET(depctl);
 80017be:	055b      	lsls	r3, r3, #21
	uint32_t data;
	uint8_t * cp;
	int cnt;
	int i;

	free = otg_fs->inep[ep_id].dtxfsts * 4;
 80017c0:	00ac      	lsls	r4, r5, #2
	depctl = otg_fs->inep[ep_id].diepctl;
	deptsiz = otg_fs->inep[ep_id].dieptsiz;

	if (ep_id == 0)
		mpsiz = OTGFS_EP0_MPSIZ_GET(depctl);
 80017c2:	0d5b      	lsrs	r3, r3, #21

	free = otg_fs->inep[ep_id].dtxfsts * 4;
	depctl = otg_fs->inep[ep_id].diepctl;
	deptsiz = otg_fs->inep[ep_id].dieptsiz;

	if (ep_id == 0)
 80017c4:	b909      	cbnz	r1, 80017ca <stm32f_otg_fs_txf_push+0x22>
		mpsiz = OTGFS_EP0_MPSIZ_GET(depctl);
 80017c6:	4d1a      	ldr	r5, [pc, #104]	; (8001830 <stm32f_otg_fs_txf_push+0x88>)
 80017c8:	5ceb      	ldrb	r3, [r5, r3]
	else
		mpsiz = OTG_FS_MPSIZ_GET(depctl);

	xfrsiz = OTG_FS_XFRSIZ_GET(deptsiz);
 80017ca:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
 80017ce:	f427 0778 	bic.w	r7, r7, #16252928	; 0xf80000
	(void)pktcnt;

	DCC_LOG5(LOG_INFO, "ep_id=%d mpsiz=%d pktcnt=%d xfrsiz=%d free=%d", 
			 ep_id, mpsiz, pktcnt, xfrsiz, free);

	if (xfrsiz < mpsiz) {
 80017d2:	42bb      	cmp	r3, r7
 80017d4:	d917      	bls.n	8001806 <stm32f_otg_fs_txf_push+0x5e>
		if (free < xfrsiz) {
 80017d6:	42bc      	cmp	r4, r7
 80017d8:	d324      	bcc.n	8001824 <stm32f_otg_fs_txf_push+0x7c>
//		cnt = mpsiz;
	}

	/* push into fifo */
	cp = (uint8_t *)buf;
	for (i = 0; i < cnt; i += 4) {
 80017da:	b197      	cbz	r7, 8001802 <stm32f_otg_fs_txf_push+0x5a>
 80017dc:	3101      	adds	r1, #1
 80017de:	4613      	mov	r3, r2
		data = cp[0] + (cp[1] << 8) + (cp[2] << 16) + (cp[3] << 24);
		otg_fs->dfifo[ep_id].push = data;
 80017e0:	eb00 3001 	add.w	r0, r0, r1, lsl #12
	}

	/* push into fifo */
	cp = (uint8_t *)buf;
	for (i = 0; i < cnt; i += 4) {
		data = cp[0] + (cp[1] << 8) + (cp[2] << 16) + (cp[3] << 24);
 80017e4:	781c      	ldrb	r4, [r3, #0]
 80017e6:	785e      	ldrb	r6, [r3, #1]
 80017e8:	789d      	ldrb	r5, [r3, #2]
 80017ea:	78d9      	ldrb	r1, [r3, #3]
 80017ec:	eb04 2406 	add.w	r4, r4, r6, lsl #8
		otg_fs->dfifo[ep_id].push = data;
		cp += 4;
 80017f0:	3304      	adds	r3, #4
	}

	/* push into fifo */
	cp = (uint8_t *)buf;
	for (i = 0; i < cnt; i += 4) {
		data = cp[0] + (cp[1] << 8) + (cp[2] << 16) + (cp[3] << 24);
 80017f2:	eb04 4405 	add.w	r4, r4, r5, lsl #16
 80017f6:	eb04 6401 	add.w	r4, r4, r1, lsl #24
			 OTG_FS_XFRSIZ_GET(deptsiz));

	return xfrsiz;
}

int stm32f_otg_fs_txf_push(struct stm32f_otg_fs * otg_fs, unsigned int ep_id,
 80017fa:	1a99      	subs	r1, r3, r2
//		cnt = mpsiz;
	}

	/* push into fifo */
	cp = (uint8_t *)buf;
	for (i = 0; i < cnt; i += 4) {
 80017fc:	428f      	cmp	r7, r1
		data = cp[0] + (cp[1] << 8) + (cp[2] << 16) + (cp[3] << 24);
		otg_fs->dfifo[ep_id].push = data;
 80017fe:	6004      	str	r4, [r0, #0]
//		cnt = mpsiz;
	}

	/* push into fifo */
	cp = (uint8_t *)buf;
	for (i = 0; i < cnt; i += 4) {
 8001800:	dcf0      	bgt.n	80017e4 <stm32f_otg_fs_txf_push+0x3c>
		cp += 4;
	}	

	DCC_LOG1(LOG_INFO, "Tx: (%d)", cnt);
	return cnt;
}
 8001802:	4638      	mov	r0, r7
 8001804:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -1;
		}
		/* Transfer the last partial packet */
		cnt = xfrsiz;
	} else {
		if (free < mpsiz) {
 8001806:	42a3      	cmp	r3, r4
 8001808:	d806      	bhi.n	8001818 <stm32f_otg_fs_txf_push+0x70>
			DCC_LOG(LOG_PANIC, "free < mpsiz !!!");
			return -1;
		}
		if (free < xfrsiz) {
 800180a:	42bc      	cmp	r4, r7
			/* Transfer only full packets */
			cnt = (free / mpsiz) * mpsiz;
 800180c:	bf3c      	itt	cc
 800180e:	fbb4 f4f3 	udivcc	r4, r4, r3
 8001812:	fb03 f704 	mulcc.w	r7, r3, r4
 8001816:	e7e0      	b.n	80017da <stm32f_otg_fs_txf_push+0x32>
		}
		/* Transfer the last partial packet */
		cnt = xfrsiz;
	} else {
		if (free < mpsiz) {
			DCC_LOG(LOG_PANIC, "free < mpsiz !!!");
 8001818:	4806      	ldr	r0, [pc, #24]	; (8001834 <stm32f_otg_fs_txf_push+0x8c>)
 800181a:	f002 fdd5 	bl	80043c8 <ice_trace0>
			return -1;
 800181e:	f04f 37ff 	mov.w	r7, #4294967295
 8001822:	e7ee      	b.n	8001802 <stm32f_otg_fs_txf_push+0x5a>
	DCC_LOG5(LOG_INFO, "ep_id=%d mpsiz=%d pktcnt=%d xfrsiz=%d free=%d", 
			 ep_id, mpsiz, pktcnt, xfrsiz, free);

	if (xfrsiz < mpsiz) {
		if (free < xfrsiz) {
			DCC_LOG(LOG_PANIC, "free < xfrsiz !!!");
 8001824:	4804      	ldr	r0, [pc, #16]	; (8001838 <stm32f_otg_fs_txf_push+0x90>)
 8001826:	f002 fdcf 	bl	80043c8 <ice_trace0>
			return -1;
 800182a:	f04f 37ff 	mov.w	r7, #4294967295
 800182e:	e7e8      	b.n	8001802 <stm32f_otg_fs_txf_push+0x5a>
 8001830:	08004d08 	.word	0x08004d08
 8001834:	400000d0 	.word	0x400000d0
 8001838:	400000c0 	.word	0x400000c0

0800183c <stm32f_otg_fs_device_init>:
	int i;

	DCC_LOG(LOG_INFO, "1.");

	/* Disable global interrupts */
	otg_fs->gahbcfg &= ~OTG_FS_GINTMSK; 
 800183c:	6882      	ldr	r2, [r0, #8]
}



void stm32f_otg_fs_device_init(struct stm32f_otg_fs * otg_fs)
{
 800183e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Disable global interrupts */
	otg_fs->gahbcfg &= ~OTG_FS_GINTMSK; 

	/* - Force device mode 
	   - Full Speed serial transceiver select */
	otg_fs->gusbcfg = OTG_FS_FDMOD | OTG_FS_TRDT_SET(5) | 
 8001840:	f241 5381 	movw	r3, #5505	; 0x1581
}



void stm32f_otg_fs_device_init(struct stm32f_otg_fs * otg_fs)
{
 8001844:	4604      	mov	r4, r0
	/* Disable global interrupts */
	otg_fs->gahbcfg &= ~OTG_FS_GINTMSK; 

	/* - Force device mode 
	   - Full Speed serial transceiver select */
	otg_fs->gusbcfg = OTG_FS_FDMOD | OTG_FS_TRDT_SET(5) | 
 8001846:	f2c4 0300 	movt	r3, #16384	; 0x4000
	int i;

	DCC_LOG(LOG_INFO, "1.");

	/* Disable global interrupts */
	otg_fs->gahbcfg &= ~OTG_FS_GINTMSK; 
 800184a:	f022 0201 	bic.w	r2, r2, #1
	stm32f_otg_fs_core_reset(otg_fs);

	DCC_LOG(LOG_INFO, "2.");

	/* Restart the Phy Clock */
	otg_fs->pcgcctl = 0;
 800184e:	2500      	movs	r5, #0
	int i;

	DCC_LOG(LOG_INFO, "1.");

	/* Disable global interrupts */
	otg_fs->gahbcfg &= ~OTG_FS_GINTMSK; 
 8001850:	6082      	str	r2, [r0, #8]

	/* - Force device mode 
	   - Full Speed serial transceiver select */
	otg_fs->gusbcfg = OTG_FS_FDMOD | OTG_FS_TRDT_SET(5) | 
 8001852:	60c3      	str	r3, [r0, #12]
		OTG_FS_PHYSEL | OTG_FS_SRPCAP | OTG_FS_TOCAL_SET(1);

	/* Reset after a PHY select and set Device mode */
	stm32f_otg_fs_core_reset(otg_fs);
 8001854:	f7ff fee8 	bl	8001628 <stm32f_otg_fs_core_reset>

	/* Restart the Phy Clock */
	otg_fs->pcgcctl = 0;

	/* Flush the FIFOs */
	stm32f_otg_fs_txfifo_flush(otg_fs, 0x10);
 8001858:	2110      	movs	r1, #16
 800185a:	4620      	mov	r0, r4
	stm32f_otg_fs_core_reset(otg_fs);

	DCC_LOG(LOG_INFO, "2.");

	/* Restart the Phy Clock */
	otg_fs->pcgcctl = 0;
 800185c:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

	/* Flush the FIFOs */
	stm32f_otg_fs_txfifo_flush(otg_fs, 0x10);
 8001860:	f7ff fefa 	bl	8001658 <stm32f_otg_fs_txfifo_flush>
	stm32f_otg_fs_rxfifo_flush(otg_fs);
 8001864:	4620      	mov	r0, r4
 8001866:	f7ff ff03 	bl	8001670 <stm32f_otg_fs_rxfifo_flush>

	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
 800186a:	f04f 32ff 	mov.w	r2, #4294967295
	/* Flush the FIFOs */
	stm32f_otg_fs_txfifo_flush(otg_fs, 0x10);
	stm32f_otg_fs_rxfifo_flush(otg_fs);

	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
 800186e:	f8c4 5810 	str.w	r5, [r4, #2064]	; 0x810
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
 8001872:	462b      	mov	r3, r5
	stm32f_otg_fs_txfifo_flush(otg_fs, 0x10);
	stm32f_otg_fs_rxfifo_flush(otg_fs);

	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
 8001874:	f8c4 5814 	str.w	r5, [r4, #2068]	; 0x814
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->inep[i].diepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
 8001878:	462f      	mov	r7, r5
	stm32f_otg_fs_rxfifo_flush(otg_fs);

	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
 800187a:	f8c4 2818 	str.w	r2, [r4, #2072]	; 0x818
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->inep[i].diepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
 800187e:	26ff      	movs	r6, #255	; 0xff

	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
 8001880:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->inep[i].diepctl;
 8001884:	f103 0148 	add.w	r1, r3, #72	; 0x48
 8001888:	0149      	lsls	r1, r1, #5
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
 800188a:	eb04 1243 	add.w	r2, r4, r3, lsl #5
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->inep[i].diepctl;
 800188e:	5860      	ldr	r0, [r4, r1]
	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
 8001890:	3301      	adds	r3, #1
		depctl = otg_fs->inep[i].diepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
 8001892:	2800      	cmp	r0, #0
 8001894:	bfb4      	ite	lt
 8001896:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
 800189a:	2000      	movge	r0, #0
	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
 800189c:	2b04      	cmp	r3, #4
		depctl = otg_fs->inep[i].diepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
 800189e:	5060      	str	r0, [r4, r1]
		otg_fs->inep[i].dieptsiz = 0;
 80018a0:	f8c2 7910 	str.w	r7, [r2, #2320]	; 0x910
		otg_fs->inep[i].diepint = 0xff;
 80018a4:	f8c2 6908 	str.w	r6, [r2, #2312]	; 0x908
	/* Clear all pending Device Interrupts */
	otg_fs->diepmsk = 0;
	otg_fs->doepmsk = 0;
	otg_fs->daint = 0xffffffff;
	otg_fs->daintmsk = 0;
	for (i = 0; i < 4; i++) {
 80018a8:	d1ec      	bne.n	8001884 <stm32f_otg_fs_device_init+0x48>
 80018aa:	2300      	movs	r3, #0
	}
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->outep[i].doepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->outep[i].doepctl = depctl;
		otg_fs->outep[i].doeptsiz = 0;
 80018ac:	461e      	mov	r6, r3
		otg_fs->outep[i].doepint = 0xff;
 80018ae:	25ff      	movs	r5, #255	; 0xff
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
	}
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->outep[i].doepctl;
 80018b0:	f103 0158 	add.w	r1, r3, #88	; 0x58
 80018b4:	0149      	lsls	r1, r1, #5
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->outep[i].doepctl = depctl;
		otg_fs->outep[i].doeptsiz = 0;
 80018b6:	eb04 1243 	add.w	r2, r4, r3, lsl #5
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
	}
	for (i = 0; i < 4; i++) {
		depctl = otg_fs->outep[i].doepctl;
 80018ba:	5860      	ldr	r0, [r4, r1]
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
	}
	for (i = 0; i < 4; i++) {
 80018bc:	3301      	adds	r3, #1
		depctl = otg_fs->outep[i].doepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
 80018be:	2800      	cmp	r0, #0
 80018c0:	bfb4      	ite	lt
 80018c2:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
 80018c6:	2000      	movge	r0, #0
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
	}
	for (i = 0; i < 4; i++) {
 80018c8:	2b04      	cmp	r3, #4
		depctl = otg_fs->outep[i].doepctl;
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->outep[i].doepctl = depctl;
 80018ca:	5060      	str	r0, [r4, r1]
		otg_fs->outep[i].doeptsiz = 0;
 80018cc:	f8c2 6b10 	str.w	r6, [r2, #2832]	; 0xb10
		otg_fs->outep[i].doepint = 0xff;
 80018d0:	f8c2 5b08 	str.w	r5, [r2, #2824]	; 0xb08
		depctl = (depctl & OTG_FS_EPENA) ? OTG_FS_EPDIS | OTG_FS_SNAK : 0;
		otg_fs->inep[i].diepctl = depctl;
		otg_fs->inep[i].dieptsiz = 0;
		otg_fs->inep[i].diepint = 0xff;
	}
	for (i = 0; i < 4; i++) {
 80018d4:	d1ec      	bne.n	80018b0 <stm32f_otg_fs_device_init+0x74>
	    USB reset
	    Enumeration done
	    Early suspend
	    USB suspend
	    SOF */
	otg_fs->gintmsk = OTG_FS_SRQIM | OTG_FS_OTGINT;
 80018d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
	/* The application must perform the following steps to initialize the 
	   core as a device on power-up or after a mode change from host to device.
	1. Program the following fields in the OTG_FS_DCFG register:
	 Device speed
	- Non-zero-length status OUT handshake */
	otg_fs->dcfg = OTG_FS_PFIVL_80 | OTG_FS_DSPD_FULL;
 80018da:	2203      	movs	r2, #3
 80018dc:	f8c4 2800 	str.w	r2, [r4, #2048]	; 0x800
	    USB reset
	    Enumeration done
	    Early suspend
	    USB suspend
	    SOF */
	otg_fs->gintmsk = OTG_FS_SRQIM | OTG_FS_OTGINT;
 80018e0:	61a3      	str	r3, [r4, #24]


	/* 3. Program the VBUSBSEN bit in the OTG_FS_GCCFG register to enable VBUS 
	   sensing in B device mode and supply the 5 volts across the pull-up 
	   resistor on the DP line. */
	otg_fs->gccfg = OTG_FS_VBUSBSEN | OTG_FS_PWRDWN;
 80018e2:	f44f 2310 	mov.w	r3, #589824	; 0x90000
 80018e6:	63a3      	str	r3, [r4, #56]	; 0x38
	   At this point, the device is ready to accept SOF packets and perform 
	   control transfers on control endpoint 0. */

	/* AHB configuration */
	/* Enable global interrupts */
	otg_fs->gahbcfg |= OTG_FS_PTXFELVL | OTG_FS_TXFELVL | OTG_FS_GINTMSK; 
 80018e8:	68a3      	ldr	r3, [r4, #8]
 80018ea:	f443 73c0 	orr.w	r3, r3, #384	; 0x180
 80018ee:	f043 0301 	orr.w	r3, r3, #1
 80018f2:	60a3      	str	r3, [r4, #8]
 80018f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80018f6:	bf00      	nop

080018f8 <stm32f_otg_fs_ep_dump>:
	"INT"
};

void stm32f_otg_fs_ep_dump(struct stm32f_otg_fs * otg_fs, unsigned int addr) 
{
	int ep_id = addr & 0x7f;
 80018f8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	uint32_t depctl;
	uint32_t eptsiz;
	uint32_t eptfsav;
	uint32_t mpsiz;

	depctl = otg_fs->inep[ep_id].diepctl;
 80018fc:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8001900:	015b      	lsls	r3, r3, #5
 8001902:	58c3      	ldr	r3, [r0, r3]
	if (depctl & OTG_FS_USBAEP) {
 8001904:	041a      	lsls	r2, r3, #16
 8001906:	d40d      	bmi.n	8001924 <stm32f_otg_fs_ep_dump+0x2c>

		DCC_LOG3(LOG_INFO, "PKTCNT=%d XFRSIZ=%d FSAVAIL=%d",
				 OTG_FS_PKTCNT_GET(eptsiz), OTG_FS_XFRSIZ_GET(eptsiz), 
				 eptfsav);
	} else {
		depctl = otg_fs->outep[ep_id].doepctl;
 8001908:	f101 0358 	add.w	r3, r1, #88	; 0x58
 800190c:	015b      	lsls	r3, r3, #5
 800190e:	58c3      	ldr	r3, [r0, r3]
		if (depctl & OTG_FS_USBAEP) {
 8001910:	041b      	lsls	r3, r3, #16
 8001912:	d504      	bpl.n	800191e <stm32f_otg_fs_ep_dump+0x26>
			eptsiz = otg_fs->outep[ep_id].doeptsiz;
 8001914:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8001918:	f8d1 3b10 	ldr.w	r3, [r1, #2832]	; 0xb10
 800191c:	4770      	bx	lr
			(void)eptsiz;
		} else {
			DCC_LOG1(LOG_WARNING, "EP%d not active!", ep_id);
 800191e:	4805      	ldr	r0, [pc, #20]	; (8001934 <stm32f_otg_fs_ep_dump+0x3c>)
 8001920:	f002 bd78 	b.w	8004414 <ice_trace1>
	uint32_t eptfsav;
	uint32_t mpsiz;

	depctl = otg_fs->inep[ep_id].diepctl;
	if (depctl & OTG_FS_USBAEP) {
		eptfsav = otg_fs->inep[ep_id].dtxfsts;
 8001924:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8001928:	f8d1 3918 	ldr.w	r3, [r1, #2328]	; 0x918
		eptsiz = otg_fs->inep[ep_id].dieptsiz;
 800192c:	f8d1 3910 	ldr.w	r3, [r1, #2320]	; 0x910
 8001930:	4770      	bx	lr
 8001932:	bf00      	nop
 8001934:	400000e0 	.word	0x400000e0

08001938 <otg_fs_fifo>:
	unsigned int r;
	unsigned int n;
	unsigned int i;

	i = ((addr >> 2) / 4) * 4;
	n = (addr + len + 3) >> 2;
 8001938:	1ccb      	adds	r3, r1, #3
 800193a:	189a      	adds	r2, r3, r2
	unsigned int q;
	unsigned int r;
	unsigned int n;
	unsigned int i;

	i = ((addr >> 2) / 4) * 4;
 800193c:	0909      	lsrs	r1, r1, #4
	n = (addr + len + 3) >> 2;
	q = (n / 4) * 4;
 800193e:	0912      	lsrs	r2, r2, #4
	unsigned int q;
	unsigned int r;
	unsigned int n;
	unsigned int i;

	i = ((addr >> 2) / 4) * 4;
 8001940:	008b      	lsls	r3, r1, #2
	n = (addr + len + 3) >> 2;
	q = (n / 4) * 4;
 8001942:	0092      	lsls	r2, r2, #2
	r = n - q;

	for (; i < q; i += 4) {
 8001944:	4293      	cmp	r3, r2
 8001946:	d202      	bcs.n	800194e <otg_fs_fifo+0x16>
 8001948:	3304      	adds	r3, #4
 800194a:	429a      	cmp	r2, r3
 800194c:	d8fc      	bhi.n	8001948 <otg_fs_fifo+0x10>
 800194e:	4770      	bx	lr

08001950 <stm32_usart_getc>:

#include "usart-priv.h"
#include <sys/delay.h>

int stm32_usart_getc(struct stm32_usart * usart, unsigned int msec)
{
 8001950:	b538      	push	{r3, r4, r5, lr}
	tm = msec * 20;

	DCC_LOG1(LOG_INFO, "msec=%d", msec);

	for (;;) {		
		if (usart->isr & USART_RXNE) {
 8001952:	6803      	ldr	r3, [r0, #0]

int stm32_usart_getc(struct stm32_usart * usart, unsigned int msec)
{
	int tm;

	tm = msec * 20;
 8001954:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8001958:	008c      	lsls	r4, r1, #2

	DCC_LOG1(LOG_INFO, "msec=%d", msec);

	for (;;) {		
		if (usart->isr & USART_RXNE) {
 800195a:	069a      	lsls	r2, r3, #26

#include "usart-priv.h"
#include <sys/delay.h>

int stm32_usart_getc(struct stm32_usart * usart, unsigned int msec)
{
 800195c:	4605      	mov	r5, r0
	tm = msec * 20;

	DCC_LOG1(LOG_INFO, "msec=%d", msec);

	for (;;) {		
		if (usart->isr & USART_RXNE) {
 800195e:	d407      	bmi.n	8001970 <stm32_usart_getc+0x20>
			return usart->rdr;
		}
		if (tm == 0) {
 8001960:	b144      	cbz	r4, 8001974 <stm32_usart_getc+0x24>
			return -2;
		}
		udelay(50);
 8001962:	2032      	movs	r0, #50	; 0x32
 8001964:	f000 f834 	bl	80019d0 <udelay>
	tm = msec * 20;

	DCC_LOG1(LOG_INFO, "msec=%d", msec);

	for (;;) {		
		if (usart->isr & USART_RXNE) {
 8001968:	682b      	ldr	r3, [r5, #0]
		}
		if (tm == 0) {
			return -2;
		}
		udelay(50);
		tm--;
 800196a:	3c01      	subs	r4, #1
	tm = msec * 20;

	DCC_LOG1(LOG_INFO, "msec=%d", msec);

	for (;;) {		
		if (usart->isr & USART_RXNE) {
 800196c:	069b      	lsls	r3, r3, #26
 800196e:	d5f7      	bpl.n	8001960 <stm32_usart_getc+0x10>
			return usart->rdr;
 8001970:	6868      	ldr	r0, [r5, #4]
 8001972:	bd38      	pop	{r3, r4, r5, pc}
		}
		if (tm == 0) {
			return -2;
 8001974:	f06f 0001 	mvn.w	r0, #1
		}
		udelay(50);
		tm--;
	}
}
 8001978:	bd38      	pop	{r3, r4, r5, pc}
 800197a:	bf00      	nop

0800197c <stm32_usart_putc>:

#include "usart-priv.h"

int stm32_usart_putc(struct stm32_usart * usart, int c)
{
	while (!(usart->isr & USART_TXE));
 800197c:	6803      	ldr	r3, [r0, #0]
 800197e:	061b      	lsls	r3, r3, #24
 8001980:	d5fc      	bpl.n	800197c <stm32_usart_putc>

	usart->tdr = c;
 8001982:	6041      	str	r1, [r0, #4]

	return 0;
}
 8001984:	2000      	movs	r0, #0
 8001986:	4770      	bx	lr

08001988 <cm3_get_ticks>:
#include <stdint.h>
#include <arch/cortex-m3.h>

static unsigned int cm3_get_ticks(void)
{
	return 0xffffffff - (CM3_SYSTICK->val << 8);
 8001988:	f24e 0310 	movw	r3, #57360	; 0xe010
 800198c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001990:	6898      	ldr	r0, [r3, #8]
}
 8001992:	ea6f 2000 	mvn.w	r0, r0, lsl #8
 8001996:	4770      	bx	lr

08001998 <cm3_udelay_calibrate>:
	load = systick->load;
	ctrl = systick->ctrl;

	systick->load = 0xffffff;
	systick->ctrl = SYSTICK_CTRL_ENABLE;
	ticks1ms = cm3_systick_load_1ms << 8;
 8001998:	f644 43e0 	movw	r3, #19680	; 0x4ce0
{
	return 0xffffffff - (CM3_SYSTICK->val << 8);
}

void cm3_udelay_calibrate(void)
{
 800199c:	b570      	push	{r4, r5, r6, lr}
	load = systick->load;
	ctrl = systick->ctrl;

	systick->load = 0xffffff;
	systick->ctrl = SYSTICK_CTRL_ENABLE;
	ticks1ms = cm3_systick_load_1ms << 8;
 800199e:	f6c0 0300 	movt	r3, #2048	; 0x800
	struct cm3_systick * systick = CM3_SYSTICK;
	uint32_t ticks1ms;
	uint32_t load;
	uint32_t ctrl;

	load = systick->load;
 80019a2:	f24e 0410 	movw	r4, #57360	; 0xe010
 80019a6:	f2ce 0400 	movt	r4, #57344	; 0xe000
	ctrl = systick->ctrl;

	systick->load = 0xffffff;
	systick->ctrl = SYSTICK_CTRL_ENABLE;
	ticks1ms = cm3_systick_load_1ms << 8;
 80019aa:	6818      	ldr	r0, [r3, #0]
	struct cm3_systick * systick = CM3_SYSTICK;
	uint32_t ticks1ms;
	uint32_t load;
	uint32_t ctrl;

	load = systick->load;
 80019ac:	6866      	ldr	r6, [r4, #4]
	ctrl = systick->ctrl;
 80019ae:	6825      	ldr	r5, [r4, #0]

	systick->load = 0xffffff;
 80019b0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80019b4:	6063      	str	r3, [r4, #4]
	systick->ctrl = SYSTICK_CTRL_ENABLE;
	ticks1ms = cm3_systick_load_1ms << 8;

	udelay_calibrate(ticks1ms, cm3_get_ticks);
 80019b6:	f641 1189 	movw	r1, #6537	; 0x1989

	load = systick->load;
	ctrl = systick->ctrl;

	systick->load = 0xffffff;
	systick->ctrl = SYSTICK_CTRL_ENABLE;
 80019ba:	2301      	movs	r3, #1
	ticks1ms = cm3_systick_load_1ms << 8;

	udelay_calibrate(ticks1ms, cm3_get_ticks);
 80019bc:	0200      	lsls	r0, r0, #8

	load = systick->load;
	ctrl = systick->ctrl;

	systick->load = 0xffffff;
	systick->ctrl = SYSTICK_CTRL_ENABLE;
 80019be:	6023      	str	r3, [r4, #0]
	ticks1ms = cm3_systick_load_1ms << 8;

	udelay_calibrate(ticks1ms, cm3_get_ticks);
 80019c0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80019c4:	f000 f814 	bl	80019f0 <udelay_calibrate>

	systick->load = load;
 80019c8:	6066      	str	r6, [r4, #4]
	systick->ctrl = ctrl;
 80019ca:	6025      	str	r5, [r4, #0]
 80019cc:	bd70      	pop	{r4, r5, r6, pc}
 80019ce:	bf00      	nop

080019d0 <udelay>:

void udelay(uint32_t usec)
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;
 80019d0:	4b06      	ldr	r3, [pc, #24]	; (80019ec <udelay+0x1c>)
 80019d2:	681b      	ldr	r3, [r3, #0]
 80019d4:	fb03 f000 	mul.w	r0, r3, r0

	while (count) {
 80019d8:	09c3      	lsrs	r3, r0, #7
 80019da:	d006      	beq.n	80019ea <udelay+0x1a>
		asm("nop\n"
 80019dc:	bf00      	nop
 80019de:	bf00      	nop
 80019e0:	bf00      	nop
 80019e2:	bf00      	nop
 80019e4:	bf00      	nop
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;

	while (count) {
 80019e6:	3b01      	subs	r3, #1
 80019e8:	d1f8      	bne.n	80019dc <udelay+0xc>
 80019ea:	4770      	bx	lr
 80019ec:	20000080 	.word	0x20000080

080019f0 <udelay_calibrate>:
		count--;
	}
}

void udelay_calibrate(int32_t ticks1ms, uint32_t (* get_ticks)(void))
{
 80019f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int32_t dt;
#if UDELAY_ERROR_ENABLE
	int32_t err = 0;
#endif

	udelay_factor = 1;
 80019f4:	4d25      	ldr	r5, [pc, #148]	; (8001a8c <udelay_calibrate+0x9c>)
 80019f6:	2301      	movs	r3, #1
		count--;
	}
}

void udelay_calibrate(int32_t ticks1ms, uint32_t (* get_ticks)(void))
{
 80019f8:	4680      	mov	r8, r0
 80019fa:	460e      	mov	r6, r1
	int32_t dt;
#if UDELAY_ERROR_ENABLE
	int32_t err = 0;
#endif

	udelay_factor = 1;
 80019fc:	602b      	str	r3, [r5, #0]
	for (x = 0; x < 20; x++) {
 80019fe:	2400      	movs	r4, #0

void udelay(uint32_t usec)
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;
 8001a00:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
			err = ticks1ms - dt;
#endif
			x--;
			break;
		}
		udelay_factor = 1 << x;
 8001a04:	4699      	mov	r9, r3
	int32_t err = 0;
#endif

	udelay_factor = 1;
	for (x = 0; x < 20; x++) {
		t0 = get_ticks();
 8001a06:	47b0      	blx	r6

void udelay(uint32_t usec)
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;
 8001a08:	682b      	ldr	r3, [r5, #0]
 8001a0a:	fb07 f303 	mul.w	r3, r7, r3

	while (count) {
 8001a0e:	09db      	lsrs	r3, r3, #7
	int32_t err = 0;
#endif

	udelay_factor = 1;
	for (x = 0; x < 20; x++) {
		t0 = get_ticks();
 8001a10:	4682      	mov	sl, r0
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;

	while (count) {
 8001a12:	d006      	beq.n	8001a22 <udelay_calibrate+0x32>
		asm("nop\n"
 8001a14:	bf00      	nop
 8001a16:	bf00      	nop
 8001a18:	bf00      	nop
 8001a1a:	bf00      	nop
 8001a1c:	bf00      	nop
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;

	while (count) {
 8001a1e:	3b01      	subs	r3, #1
 8001a20:	d1f8      	bne.n	8001a14 <udelay_calibrate+0x24>

	udelay_factor = 1;
	for (x = 0; x < 20; x++) {
		t0 = get_ticks();
		udelay(1000);
		t1 = get_ticks();
 8001a22:	47b0      	blx	r6
		dt = t1 - t0;
 8001a24:	ebca 0000 	rsb	r0, sl, r0
		if (dt > ticks1ms) {
 8001a28:	4540      	cmp	r0, r8
 8001a2a:	dc2a      	bgt.n	8001a82 <udelay_calibrate+0x92>
			err = ticks1ms - dt;
#endif
			x--;
			break;
		}
		udelay_factor = 1 << x;
 8001a2c:	fa09 f304 	lsl.w	r3, r9, r4
#if UDELAY_ERROR_ENABLE
	int32_t err = 0;
#endif

	udelay_factor = 1;
	for (x = 0; x < 20; x++) {
 8001a30:	3401      	adds	r4, #1
 8001a32:	2c14      	cmp	r4, #20
			err = ticks1ms - dt;
#endif
			x--;
			break;
		}
		udelay_factor = 1 << x;
 8001a34:	602b      	str	r3, [r5, #0]
#if UDELAY_ERROR_ENABLE
	int32_t err = 0;
#endif

	udelay_factor = 1;
	for (x = 0; x < 20; x++) {
 8001a36:	d1e6      	bne.n	8001a06 <udelay_calibrate+0x16>
		}
		udelay_factor = 1 << x;
	}

	for (; x >= 0; x--) {
		udelay_factor |= 1 << x;
 8001a38:	f04f 0a01 	mov.w	sl, #1

void udelay(uint32_t usec)
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;
 8001a3c:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
		}
		udelay_factor = 1 << x;
	}

	for (; x >= 0; x--) {
		udelay_factor |= 1 << x;
 8001a40:	fa0a f704 	lsl.w	r7, sl, r4
 8001a44:	433b      	orrs	r3, r7
 8001a46:	602b      	str	r3, [r5, #0]
		t0 = get_ticks();
 8001a48:	47b0      	blx	r6

void udelay(uint32_t usec)
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;
 8001a4a:	682b      	ldr	r3, [r5, #0]
 8001a4c:	fb09 f303 	mul.w	r3, r9, r3

	while (count) {
 8001a50:	09db      	lsrs	r3, r3, #7
		udelay_factor = 1 << x;
	}

	for (; x >= 0; x--) {
		udelay_factor |= 1 << x;
		t0 = get_ticks();
 8001a52:	4683      	mov	fp, r0
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;

	while (count) {
 8001a54:	d006      	beq.n	8001a64 <udelay_calibrate+0x74>
		asm("nop\n"
 8001a56:	bf00      	nop
 8001a58:	bf00      	nop
 8001a5a:	bf00      	nop
 8001a5c:	bf00      	nop
 8001a5e:	bf00      	nop
{
	uint32_t count;

	count = (usec * udelay_factor) >> 7;

	while (count) {
 8001a60:	3b01      	subs	r3, #1
 8001a62:	d1f8      	bne.n	8001a56 <udelay_calibrate+0x66>

	for (; x >= 0; x--) {
		udelay_factor |= 1 << x;
		t0 = get_ticks();
		udelay(1000);
		t1 = get_ticks();
 8001a64:	47b0      	blx	r6
		dt = t1 - t0;
 8001a66:	ebcb 0000 	rsb	r0, fp, r0
		if (dt > ticks1ms) {
 8001a6a:	4580      	cmp	r8, r0
			udelay_factor &= ~(1 << x);
 8001a6c:	bfbe      	ittt	lt
 8001a6e:	682b      	ldrlt	r3, [r5, #0]
 8001a70:	43bb      	biclt	r3, r7
 8001a72:	602b      	strlt	r3, [r5, #0]
			break;
		}
		udelay_factor = 1 << x;
	}

	for (; x >= 0; x--) {
 8001a74:	f114 34ff 	adds.w	r4, r4, #4294967295
 8001a78:	d301      	bcc.n	8001a7e <udelay_calibrate+0x8e>
 8001a7a:	682b      	ldr	r3, [r5, #0]
 8001a7c:	e7e0      	b.n	8001a40 <udelay_calibrate+0x50>
 8001a7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001a82:	f114 34ff 	adds.w	r4, r4, #4294967295
 8001a86:	d3fa      	bcc.n	8001a7e <udelay_calibrate+0x8e>
 8001a88:	682b      	ldr	r3, [r5, #0]
 8001a8a:	e7d5      	b.n	8001a38 <udelay_calibrate+0x48>
 8001a8c:	20000080 	.word	0x20000080

08001a90 <thinkos_idle_task>:
#endif
#if THINKOS_ENABLE_IDLE_SNAPSHOT
		asm volatile ("ldr  r12, [lr, #0]\n"); /* update the snapshot value */
#endif
#if THINKOS_ENABLE_IDLE_WFI
		asm volatile ("wfi\n"); /* wait for interrupt */
 8001a90:	bf30      	wfi
 8001a92:	e7fd      	b.n	8001a90 <thinkos_idle_task>
 8001a94:	f3af 8000 	nop.w
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <cm3_pendsv_isr>:
}

static inline struct thinkos_context * __attribute__((always_inline)) 
__sched_entry(void) {
	register struct thinkos_context * ctx asm("r0");
	asm volatile (
 8001aa0:	f3ef 8009 	mrs	r0, PSP
 8001aa4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}

	/* get the active (current) thread */	
	idx = thinkos_rt.active;

	/* save SP */
	thinkos_rt.ctx[idx] = ctx;
 8001aa8:	f240 0388 	movw	r3, #136	; 0x88
 8001aac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ab0:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8001ab4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8001ab8:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
 8001abc:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8001ac0:	fab2 f282 	clz	r2, r2

	/* get a thread from the ready bitmap */
	idx = __clz(__rbit(thinkos_rt.wq_ready));

	/* update the active thread */
	thinkos_rt.active = idx;
 8001ac4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	return ctx;
}

static inline void __attribute__((always_inline)) 
__sched_exit(struct thinkos_context * __ctx) {
	register struct thinkos_context * r0 asm("r0") = __ctx;
 8001ac8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
	asm volatile (
 8001acc:	f100 0320 	add.w	r3, r0, #32
 8001ad0:	f383 8809 	msr	PSP, r3
 8001ad4:	e890 0ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001ad8:	4770      	bx	lr
 8001ada:	bf00      	nop
 8001adc:	f3af 8000 	nop.w

08001ae0 <cm3_systick_isr>:
}

#if THINKOS_ENABLE_CLOCK || THINKOS_ENABLE_TIMESHARE

void __attribute__((aligned(16))) cm3_systick_isr(void)
{
 8001ae0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
#if THINKOS_ENABLE_CLOCK
	uint32_t ticks;
	uint32_t wq;
	int j;

	ticks = thinkos_rt.ticks; 
 8001ae4:	4c24      	ldr	r4, [pc, #144]	; (8001b78 <cm3_systick_isr+0x98>)
 8001ae6:	f8d4 66f0 	ldr.w	r6, [r4, #1776]	; 0x6f0
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8001aea:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
	ticks++;
 8001aee:	3601      	adds	r6, #1
	thinkos_rt.ticks = ticks; 
 8001af0:	f8c4 66f0 	str.w	r6, [r4, #1776]	; 0x6f0
 8001af4:	fa92 f2a2 	rbit	r2, r2
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8001af8:	4b20      	ldr	r3, [pc, #128]	; (8001b7c <cm3_systick_isr+0x9c>)

#if THINKOS_ENABLE_CLOCK || THINKOS_ENABLE_TIMESHARE

void __attribute__((aligned(16))) cm3_systick_isr(void)
{
	int sched = 0;
 8001afa:	f04f 0c00 	mov.w	ip, #0
 8001afe:	ea4f 1b43 	mov.w	fp, r3, lsl #5
 8001b02:	3b04      	subs	r3, #4
 8001b04:	ea4f 1a43 	mov.w	sl, r3, lsl #5
	ticks++;
	thinkos_rt.ticks = ticks; 

	wq = __rbit(thinkos_rt.wq_clock);
	while ((j = __clz(wq)) < 32) {
		wq &= ~(0x80000000 >> j);  
 8001b08:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
		if ((int32_t)(thinkos_rt.clock[j] - ticks) <= 0) {
 8001b0c:	46a1      	mov	r9, r4
#if THINKOS_ENABLE_THREAD_STAT
			int stat;
			/* update the thread status */
			stat = thinkos_rt.th_stat[j];
			thinkos_rt.th_stat[j] = 0;
 8001b0e:	4667      	mov	r7, ip
 8001b10:	f104 7888 	add.w	r8, r4, #17825792	; 0x1100000
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8001b14:	fab2 f382 	clz	r3, r2
	ticks++;
	thinkos_rt.ticks = ticks; 

	wq = __rbit(thinkos_rt.wq_clock);
	while ((j = __clz(wq)) < 32) {
		wq &= ~(0x80000000 >> j);  
 8001b18:	fa25 f103 	lsr.w	r1, r5, r3
	ticks = thinkos_rt.ticks; 
	ticks++;
	thinkos_rt.ticks = ticks; 

	wq = __rbit(thinkos_rt.wq_clock);
	while ((j = __clz(wq)) < 32) {
 8001b1c:	2b1f      	cmp	r3, #31
		wq &= ~(0x80000000 >> j);  
		if ((int32_t)(thinkos_rt.clock[j] - ticks) <= 0) {
 8001b1e:	eb04 0083 	add.w	r0, r4, r3, lsl #2
	ticks++;
	thinkos_rt.ticks = ticks; 

	wq = __rbit(thinkos_rt.wq_clock);
	while ((j = __clz(wq)) < 32) {
		wq &= ~(0x80000000 >> j);  
 8001b22:	ea22 0201 	bic.w	r2, r2, r1
	ticks = thinkos_rt.ticks; 
	ticks++;
	thinkos_rt.ticks = ticks; 

	wq = __rbit(thinkos_rt.wq_clock);
	while ((j = __clz(wq)) < 32) {
 8001b26:	dc19      	bgt.n	8001b5c <cm3_systick_isr+0x7c>
		wq &= ~(0x80000000 >> j);  
		if ((int32_t)(thinkos_rt.clock[j] - ticks) <= 0) {
 8001b28:	f8d0 16f4 	ldr.w	r1, [r0, #1780]	; 0x6f4
 8001b2c:	1b89      	subs	r1, r1, r6
 8001b2e:	2900      	cmp	r1, #0
 8001b30:	dcf0      	bgt.n	8001b14 <cm3_systick_isr+0x34>
#if THINKOS_ENABLE_THREAD_STAT
			int stat;
			/* update the thread status */
			stat = thinkos_rt.th_stat[j];
 8001b32:	eb09 0103 	add.w	r1, r9, r3
#if THINKOS_ENABLE_SCHED_DEBUG
			thinkos_rt.sched_trace_req = 1;
#endif
			/* insert into the ready wait queue */
			bmp_bit_set(&thinkos_rt.wq_ready, j);  
			sched++;
 8001b36:	f10c 0c01 	add.w	ip, ip, #1
		wq &= ~(0x80000000 >> j);  
		if ((int32_t)(thinkos_rt.clock[j] - ticks) <= 0) {
#if THINKOS_ENABLE_THREAD_STAT
			int stat;
			/* update the thread status */
			stat = thinkos_rt.th_stat[j];
 8001b3a:	f891 06d0 	ldrb.w	r0, [r1, #1744]	; 0x6d0
			thinkos_rt.th_stat[j] = 0;
 8001b3e:	f881 76d0 	strb.w	r7, [r1, #1744]	; 0x6d0
			/* remove from other wait queue, if any */
			bmp_bit_clr(&thinkos_rt.wq_lst[stat >> 1], j);  
 8001b42:	1041      	asrs	r1, r0, #1
 8001b44:	3122      	adds	r1, #34	; 0x22
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8001b46:	eb08 0181 	add.w	r1, r8, r1, lsl #2
	bit_addr[bit] = val;
 8001b4a:	0149      	lsls	r1, r1, #5
 8001b4c:	f841 7023 	str.w	r7, [r1, r3, lsl #2]
 8001b50:	2101      	movs	r1, #1
 8001b52:	f84b 7023 	str.w	r7, [fp, r3, lsl #2]
 8001b56:	f84a 1023 	str.w	r1, [sl, r3, lsl #2]
 8001b5a:	e7db      	b.n	8001b14 <cm3_systick_isr+0x34>
//		printf("i");
//	}

#endif /* THINKOS_ENABLE_TIMESHARE */

	if (sched)
 8001b5c:	f1bc 0f00 	cmp.w	ip, #0
 8001b60:	d006      	beq.n	8001b70 <cm3_systick_isr+0x90>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8001b62:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8001b66:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001b6a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001b6e:	605a      	str	r2, [r3, #4]
		__thinkos_defer_sched();
}
 8001b70:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001b74:	4770      	bx	lr
 8001b76:	bf00      	nop
 8001b78:	20000088 	.word	0x20000088
 8001b7c:	21100114 	.word	0x21100114

08001b80 <thinkos_thread_exit>:
#endif /* THINKOS_ENABLE_CLOCK || THINKOS_ENABLE_TIMESHARE */

void __attribute__((noreturn)) thinkos_thread_exit(int code)
{
	int self = thinkos_rt.active;
 8001b80:	4d15      	ldr	r5, [pc, #84]	; (8001bd8 <thinkos_thread_exit+0x58>)
 8001b82:	f8d5 4084 	ldr.w	r4, [r5, #132]	; 0x84
		__thinkos_defer_sched();
}
#endif /* THINKOS_ENABLE_CLOCK || THINKOS_ENABLE_TIMESHARE */

void __attribute__((noreturn)) thinkos_thread_exit(int code)
{
 8001b86:	4602      	mov	r2, r0
 8001b88:	b508      	push	{r3, lr}
	int self = thinkos_rt.active;
	int j;

	DCC_LOG2(LOG_TRACE, "<%d> code=%d", self, code); 
 8001b8a:	4621      	mov	r1, r4
 8001b8c:	4813      	ldr	r0, [pc, #76]	; (8001bdc <thinkos_thread_exit+0x5c>)
 8001b8e:	f002 fc6f 	bl	8004470 <ice_trace2>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8001b92:	b672      	cpsid	i

#ifdef THINKOS_ENABLE_CANCEL
#if THINKOS_ENABLE_THREAD_STAT
	int stat;
	/* update the thread status */
	stat = thinkos_rt.th_stat[self];
 8001b94:	192a      	adds	r2, r5, r4
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8001b96:	f105 7388 	add.w	r3, r5, #17825792	; 0x1100000
 8001b9a:	f892 16d0 	ldrb.w	r1, [r2, #1744]	; 0x6d0
	thinkos_rt.th_stat[self] = 0;
	/* remove from other wait queue, if any */
	bmp_bit_clr(&thinkos_rt.wq_lst[stat >> 1], self);  
 8001b9e:	1049      	asrs	r1, r1, #1
 8001ba0:	3122      	adds	r1, #34	; 0x22
 8001ba2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
	bit_addr[bit] = val;
 8001ba6:	0149      	lsls	r1, r1, #5
#ifdef THINKOS_ENABLE_CANCEL
#if THINKOS_ENABLE_THREAD_STAT
	int stat;
	/* update the thread status */
	stat = thinkos_rt.th_stat[self];
	thinkos_rt.th_stat[self] = 0;
 8001ba8:	2300      	movs	r3, #0
 8001baa:	f882 36d0 	strb.w	r3, [r2, #1744]	; 0x6d0
 8001bae:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8001bb2:	b662      	cpsie	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8001bb4:	490a      	ldr	r1, [pc, #40]	; (8001be0 <thinkos_thread_exit+0x60>)
 8001bb6:	0149      	lsls	r1, r1, #5
 8001bb8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8001bbc:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
 8001bc0:	4908      	ldr	r1, [pc, #32]	; (8001be4 <thinkos_thread_exit+0x64>)
#endif


	/* FIXME: clear context. The way is implemented th scheduler will 
	   override this value...  */
	thinkos_rt.ctx[self] = 0;
 8001bc2:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 8001bc6:	0149      	lsls	r1, r1, #5
 8001bc8:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001bcc:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
 8001bd0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8001bd4:	6053      	str	r3, [r2, #4]
 8001bd6:	e7fe      	b.n	8001bd6 <thinkos_thread_exit+0x56>
 8001bd8:	20000088 	.word	0x20000088
 8001bdc:	400000f0 	.word	0x400000f0
 8001be0:	21100c74 	.word	0x21100c74
 8001be4:	21100110 	.word	0x21100110

08001be8 <thinkos_init>:

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
{
 8001be8:	b570      	push	{r4, r5, r6, lr}
 8001bea:	b084      	sub	sp, #16
 8001bec:	f3c0 6506 	ubfx	r5, r0, #24, #7
 8001bf0:	9003      	str	r0, [sp, #12]
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8001bf2:	b672      	cpsid	i
	return CM3_NVIC->ip[irq];
}

/* Set Priority for Cortex-M3 System Interrupts */
static inline void __attribute__((always_inline)) cm3_except_pri_set(int xcpt, int pri) {
	CM3_SCB->shp[xcpt - 4] = pri;
 8001bf4:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8001bf8:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001bfc:	2100      	movs	r1, #0
 8001bfe:	2360      	movs	r3, #96	; 0x60
 8001c00:	26a0      	movs	r6, #160	; 0xa0
 8001c02:	20ff      	movs	r0, #255	; 0xff
 8001c04:	4c63      	ldr	r4, [pc, #396]	; (8001d94 <thinkos_init+0x1ac>)
 8001c06:	77d3      	strb	r3, [r2, #31]
 8001c08:	f882 6023 	strb.w	r6, [r2, #35]	; 0x23
	cm3_except_pri_set(CM3_EXCEPT_USAGE_FAULT, EXCEPT_PRIORITY);


#if	(THINKOS_IRQ_MAX > 0)
	/* adjust IRQ priorities to regular (above SysTick and bellow SVC) */
	for (irq = 0; irq < THINKOS_IRQ_MAX; irq++) {
 8001c0c:	460b      	mov	r3, r1
 8001c0e:	f882 0022 	strb.w	r0, [r2, #34]	; 0x22
	return (CM3_NVIC->iabr[irq >> 5] & (1 << (irq & 0x1f))) ? 1 : 0;
}

/* Set the priority for an interrupt */
static inline void __attribute__((always_inline)) cm3_irq_pri_set(int irq, int pri) {
	CM3_NVIC->ip[irq] = pri;
 8001c12:	2680      	movs	r6, #128	; 0x80
	return CM3_NVIC->ip[irq];
}

/* Set Priority for Cortex-M3 System Interrupts */
static inline void __attribute__((always_inline)) cm3_except_pri_set(int xcpt, int pri) {
	CM3_SCB->shp[xcpt - 4] = pri;
 8001c14:	7611      	strb	r1, [r2, #24]
 8001c16:	7651      	strb	r1, [r2, #25]
 8001c18:	7691      	strb	r1, [r2, #26]
	return (CM3_NVIC->iabr[irq >> 5] & (1 << (irq & 0x1f))) ? 1 : 0;
}

/* Set the priority for an interrupt */
static inline void __attribute__((always_inline)) cm3_irq_pri_set(int irq, int pri) {
	CM3_NVIC->ip[irq] = pri;
 8001c1a:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
	__thinkos_wait(self);

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
 8001c1e:	18e1      	adds	r1, r4, r3
 8001c20:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
	cm3_except_pri_set(CM3_EXCEPT_USAGE_FAULT, EXCEPT_PRIORITY);


#if	(THINKOS_IRQ_MAX > 0)
	/* adjust IRQ priorities to regular (above SysTick and bellow SVC) */
	for (irq = 0; irq < THINKOS_IRQ_MAX; irq++) {
 8001c24:	3301      	adds	r3, #1
 8001c26:	2b50      	cmp	r3, #80	; 0x50
 8001c28:	f882 6300 	strb.w	r6, [r2, #768]	; 0x300
		cm3_irq_pri_set(irq, IRQ_PRIORITY_REGULAR);
		thinkos_rt.irq_th[irq] = -1;
 8001c2c:	f881 0b9c 	strb.w	r0, [r1, #2972]	; 0xb9c
	cm3_except_pri_set(CM3_EXCEPT_USAGE_FAULT, EXCEPT_PRIORITY);


#if	(THINKOS_IRQ_MAX > 0)
	/* adjust IRQ priorities to regular (above SysTick and bellow SVC) */
	for (irq = 0; irq < THINKOS_IRQ_MAX; irq++) {
 8001c30:	d1f3      	bne.n	8001c1a <thinkos_init+0x32>
	return psp;
}

static inline uint32_t __attribute__((always_inline)) cm3_sp_get(void) {
	register uint32_t sp;
	asm volatile ("mov %0, sp\n" : "=r" (sp));
 8001c32:	466b      	mov	r3, sp
	asm volatile ("mrs %0, MSP\n" : "=r" (msp));
	return msp;
}

static inline void __attribute__((always_inline)) cm3_psp_set(uint32_t val) {
	asm volatile ("msr PSP, %0\n" : : "r" (val));
 8001c34:	f383 8809 	msr	PSP, r3
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_msp_set(uint32_t val) {
	asm volatile ("msr MSP, %0\n" : : "r" (val));
 8001c38:	4b57      	ldr	r3, [pc, #348]	; (8001d98 <thinkos_init+0x1b0>)
 8001c3a:	f383 8808 	msr	MSP, r3
	msp = (uint32_t)&thinkos_except_stack + sizeof(thinkos_except_stack);
#endif
	msp = (uint32_t)&thinkos_idle.stack.r12;
	cm3_msp_set(msp);

	DCC_LOG2(LOG_TRACE, "msp=0x%08x idle=0x%08x", msp, &thinkos_idle);
 8001c3e:	4857      	ldr	r0, [pc, #348]	; (8001d9c <thinkos_init+0x1b4>)
 8001c40:	4619      	mov	r1, r3
 8001c42:	f5a3 72c0 	sub.w	r2, r3, #384	; 0x180
 8001c46:	f002 fc13 	bl	8004470 <ice_trace2>

#define CONTROL_THREAD_MSP (0 << 1)
#define CONTROL_THREAD_PSP (1 << 1)

static inline void __attribute__((always_inline)) cm3_control_set(uint32_t val) {
	asm volatile ("msr CONTROL, %0\n" : : "r" (val));
 8001c4a:	2302      	movs	r3, #2
 8001c4c:	f383 8814 	msr	CONTROL, r3
 8001c50:	4b53      	ldr	r3, [pc, #332]	; (8001da0 <thinkos_init+0x1b8>)
	/* configure the use of PSP in thread mode */
	cm3_control_set(CONTROL_THREAD_PSP | CONTROL_THREAD_PRIV);

	/* initialize exception stack */
	for (i = 0; i < (THINKOS_EXCEPT_STACK_SIZE / 4 - IDLE_UNUSED_REGS); ++i)
		thinkos_idle.except_stack[i] = 0xdeadbeef;
 8001c52:	f64b 62ef 	movw	r2, #48879	; 0xbeef
	__thinkos_wait(self);

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
 8001c56:	f503 71a8 	add.w	r1, r3, #336	; 0x150
	/* configure the use of PSP in thread mode */
	cm3_control_set(CONTROL_THREAD_PSP | CONTROL_THREAD_PRIV);

	/* initialize exception stack */
	for (i = 0; i < (THINKOS_EXCEPT_STACK_SIZE / 4 - IDLE_UNUSED_REGS); ++i)
		thinkos_idle.except_stack[i] = 0xdeadbeef;
 8001c5a:	f6cd 62ad 	movt	r2, #57005	; 0xdead
 8001c5e:	f843 2f04 	str.w	r2, [r3, #4]!

	/* configure the use of PSP in thread mode */
	cm3_control_set(CONTROL_THREAD_PSP | CONTROL_THREAD_PRIV);

	/* initialize exception stack */
	for (i = 0; i < (THINKOS_EXCEPT_STACK_SIZE / 4 - IDLE_UNUSED_REGS); ++i)
 8001c62:	428b      	cmp	r3, r1
 8001c64:	d1fb      	bne.n	8001c5e <thinkos_init+0x76>
	{	/* initialize the mutex allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_MUTEX_MAX / 32); ++i)
			thinkos_rt.mutex_alloc[i] = 0;
		if (THINKOS_MUTEX_MAX % 32)
			thinkos_rt.mutex_alloc[i] = 0xffffffff << (THINKOS_MUTEX_MAX % 32);
 8001c66:	2100      	movs	r1, #0
#if THINKOS_ENABLE_CLOCK
	thinkos_idle.snapshot.ptr = &thinkos_rt.ticks;
#else
	thinkos_idle.snapshot.ptr = (void *)&thinkos_rt.active;
#endif
	thinkos_idle.snapshot.val = 0;
 8001c68:	460b      	mov	r3, r1
	{	/* initialize the mutex allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_MUTEX_MAX / 32); ++i)
			thinkos_rt.mutex_alloc[i] = 0;
		if (THINKOS_MUTEX_MAX % 32)
			thinkos_rt.mutex_alloc[i] = 0xffffffff << (THINKOS_MUTEX_MAX % 32);
 8001c6a:	f6cf 71ff 	movt	r1, #65535	; 0xffff
	/* initialize exception stack */
	for (i = 0; i < (THINKOS_EXCEPT_STACK_SIZE / 4 - IDLE_UNUSED_REGS); ++i)
		thinkos_idle.except_stack[i] = 0xdeadbeef;

	/* initialize the idle thread */
	thinkos_rt.idle_ctx = &thinkos_idle.ctx;
 8001c6e:	484d      	ldr	r0, [pc, #308]	; (8001da4 <thinkos_init+0x1bc>)


	thinkos_idle.ctx.pc = (uint32_t)thinkos_idle_task,
	thinkos_idle.ctx.xpsr = 0x01000000;
#if THINKOS_ENABLE_CLOCK
	thinkos_idle.snapshot.ptr = &thinkos_rt.ticks;
 8001c70:	4a4d      	ldr	r2, [pc, #308]	; (8001da8 <thinkos_init+0x1c0>)
	{	/* initialize the mutex allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_MUTEX_MAX / 32); ++i)
			thinkos_rt.mutex_alloc[i] = 0;
		if (THINKOS_MUTEX_MAX % 32)
			thinkos_rt.mutex_alloc[i] = 0xffffffff << (THINKOS_MUTEX_MAX % 32);
 8001c72:	f8c4 1bf8 	str.w	r1, [r4, #3064]	; 0xbf8
	{	/* initialize the semaphore allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_SEMAPHORE_MAX / 32); ++i)
			thinkos_rt.sem_alloc[i] = 0;
		if (THINKOS_SEMAPHORE_MAX % 32)
			thinkos_rt.sem_alloc[i] = 0xffffffff << (THINKOS_SEMAPHORE_MAX % 32);
 8001c76:	f8c4 1c10 	str.w	r1, [r4, #3088]	; 0xc10
	{	/* initialize the conditional variable allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_COND_MAX / 32); ++i)
			thinkos_rt.cond_alloc[i] = 0;
		if (THINKOS_COND_MAX % 32)
			thinkos_rt.cond_alloc[i] = 0xffffffff << (THINKOS_COND_MAX % 32);
 8001c7a:	f8c4 1c04 	str.w	r1, [r4, #3076]	; 0xc04
	{	/* initialize the flag allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_FLAG_MAX / 32); ++i)
			thinkos_rt.flag_alloc[i] = 0;
		if (THINKOS_FLAG_MAX % 32)
			thinkos_rt.flag_alloc[i] = 0xffffffff << (THINKOS_FLAG_MAX % 32);
 8001c7e:	f8c4 1c28 	str.w	r1, [r4, #3112]	; 0xc28
	{	/* initialize the event set allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_EVENT_MAX / 32); ++i)
			thinkos_rt.ev_alloc[i] = 0;
		if (THINKOS_EVENT_MAX % 32)
			thinkos_rt.ev_alloc[i] = 0xffffffff << (THINKOS_EVENT_MAX % 32);
 8001c82:	f8c4 1c1c 	str.w	r1, [r4, #3100]	; 0xc1c
	thinkos_rt.sched_idle_pri = 0;
#endif
//	thinkos_idle.ctx.ret = CM3_EXC_RET_THREAD_PSP;


	thinkos_idle.ctx.pc = (uint32_t)thinkos_idle_task,
 8001c86:	4949      	ldr	r1, [pc, #292]	; (8001dac <thinkos_init+0x1c4>)
	/* initialize exception stack */
	for (i = 0; i < (THINKOS_EXCEPT_STACK_SIZE / 4 - IDLE_UNUSED_REGS); ++i)
		thinkos_idle.except_stack[i] = 0xdeadbeef;

	/* initialize the idle thread */
	thinkos_rt.idle_ctx = &thinkos_idle.ctx;
 8001c88:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80

#if THINKOS_ENABLE_MUTEX_ALLOC
	{	/* initialize the mutex allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_MUTEX_MAX / 32); ++i)
			thinkos_rt.mutex_alloc[i] = 0;
 8001c8c:	f8c4 3bf0 	str.w	r3, [r4, #3056]	; 0xbf0
 8001c90:	f8c4 3bf4 	str.w	r3, [r4, #3060]	; 0xbf4

#if THINKOS_ENABLE_SEM_ALLOC
	{	/* initialize the semaphore allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_SEMAPHORE_MAX / 32); ++i)
			thinkos_rt.sem_alloc[i] = 0;
 8001c94:	f8c4 3c08 	str.w	r3, [r4, #3080]	; 0xc08
 8001c98:	f8c4 3c0c 	str.w	r3, [r4, #3084]	; 0xc0c

#if THINKOS_ENABLE_COND_ALLOC
	{	/* initialize the conditional variable allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_COND_MAX / 32); ++i)
			thinkos_rt.cond_alloc[i] = 0;
 8001c9c:	f8c4 3bfc 	str.w	r3, [r4, #3068]	; 0xbfc
 8001ca0:	f8c4 3c00 	str.w	r3, [r4, #3072]	; 0xc00

#if THINKOS_ENABLE_FLAG_ALLOC
	{	/* initialize the flag allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_FLAG_MAX / 32); ++i)
			thinkos_rt.flag_alloc[i] = 0;
 8001ca4:	f8c4 3c20 	str.w	r3, [r4, #3104]	; 0xc20
 8001ca8:	f8c4 3c24 	str.w	r3, [r4, #3108]	; 0xc24

#if THINKOS_ENABLE_EVENT_ALLOC
	{	/* initialize the event set allocation bitmap */ 
		int i;
		for (i = 0; i < (THINKOS_EVENT_MAX / 32); ++i)
			thinkos_rt.ev_alloc[i] = 0;
 8001cac:	f8c4 3c14 	str.w	r3, [r4, #3092]	; 0xc14
 8001cb0:	f8c4 3c18 	str.w	r3, [r4, #3096]	; 0xc18
	thinkos_rt.sched_idle_pri = 0;
#endif
//	thinkos_idle.ctx.ret = CM3_EXC_RET_THREAD_PSP;


	thinkos_idle.ctx.pc = (uint32_t)thinkos_idle_task,
 8001cb4:	6381      	str	r1, [r0, #56]	; 0x38
	__thinkos_wait(self);

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
 8001cb6:	f5a2 64de 	sub.w	r4, r2, #1776	; 0x6f0
#endif
//	thinkos_idle.ctx.ret = CM3_EXC_RET_THREAD_PSP;


	thinkos_idle.ctx.pc = (uint32_t)thinkos_idle_task,
	thinkos_idle.ctx.xpsr = 0x01000000;
 8001cba:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8001cbe:	63c1      	str	r1, [r0, #60]	; 0x3c
#if THINKOS_ENABLE_CLOCK
	thinkos_idle.snapshot.ptr = &thinkos_rt.ticks;
 8001cc0:	6342      	str	r2, [r0, #52]	; 0x34
#else
	thinkos_idle.snapshot.ptr = (void *)&thinkos_rt.active;
#endif
	thinkos_idle.snapshot.val = 0;
 8001cc2:	6303      	str	r3, [r0, #48]	; 0x30
 8001cc4:	f202 425b 	addw	r2, r2, #1115	; 0x45b
	__thinkos_wait(self);

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
 8001cc8:	4623      	mov	r3, r4
 8001cca:	f604 309b 	addw	r0, r4, #2971	; 0xb9b
#if (THINKOS_MUTEX_MAX > 0)
	{
		int i;
		/* initialize the mutex locks */
		for (i = 0; i < THINKOS_MUTEX_MAX; i++) 
			thinkos_rt.lock[i] = -1;
 8001cce:	21ff      	movs	r1, #255	; 0xff
 8001cd0:	f802 1f01 	strb.w	r1, [r2, #1]!

#if (THINKOS_MUTEX_MAX > 0)
	{
		int i;
		/* initialize the mutex locks */
		for (i = 0; i < THINKOS_MUTEX_MAX; i++) 
 8001cd4:	4282      	cmp	r2, r0
 8001cd6:	d1fb      	bne.n	8001cd0 <thinkos_init+0xe8>
#if THINKOS_FLAG_MAX > 0
	{
		/* initialize the flags */
		int i;
		for (i = 0; i < ((THINKOS_FLAG_MAX + 31) / 32); ++i) {
			thinkos_rt.flag.sig[i] = 0;
 8001cd8:	2100      	movs	r1, #0
	__thinkos_wait(self);

	for(;;);
}

int thinkos_init(struct thinkos_thread_opt opt)
 8001cda:	4835      	ldr	r0, [pc, #212]	; (8001db0 <thinkos_init+0x1c8>)
#if THINKOS_FLAG_MAX > 0
	{
		/* initialize the flags */
		int i;
		for (i = 0; i < ((THINKOS_FLAG_MAX + 31) / 32); ++i) {
			thinkos_rt.flag.sig[i] = 0;
 8001cdc:	f8c4 1b34 	str.w	r1, [r4, #2868]	; 0xb34
			thinkos_rt.flag.lock[i] = 0;
 8001ce0:	f8c4 1b40 	str.w	r1, [r4, #2880]	; 0xb40
#if THINKOS_FLAG_MAX > 0
	{
		/* initialize the flags */
		int i;
		for (i = 0; i < ((THINKOS_FLAG_MAX + 31) / 32); ++i) {
			thinkos_rt.flag.sig[i] = 0;
 8001ce4:	f8c4 1b38 	str.w	r1, [r4, #2872]	; 0xb38
			thinkos_rt.flag.lock[i] = 0;
 8001ce8:	f8c4 1b44 	str.w	r1, [r4, #2884]	; 0xb44
#if THINKOS_FLAG_MAX > 0
	{
		/* initialize the flags */
		int i;
		for (i = 0; i < ((THINKOS_FLAG_MAX + 31) / 32); ++i) {
			thinkos_rt.flag.sig[i] = 0;
 8001cec:	f8c4 1b3c 	str.w	r1, [r4, #2876]	; 0xb3c
			thinkos_rt.flag.lock[i] = 0;
 8001cf0:	f8c4 1b48 	str.w	r1, [r4, #2888]	; 0xb48
	{
		int i;
		/* initialize the event sets */
		for (i = 0; i < THINKOS_EVENT_MAX; i++) {
			thinkos_rt.ev[i].pend = 0; /* no pending events */
			thinkos_rt.ev[i].mask = 0xffffffff; /* all events a are enabled */
 8001cf4:	f04f 32ff 	mov.w	r2, #4294967295
#if THINKOS_EVENT_MAX > 0
	{
		int i;
		/* initialize the event sets */
		for (i = 0; i < THINKOS_EVENT_MAX; i++) {
			thinkos_rt.ev[i].pend = 0; /* no pending events */
 8001cf8:	f8c3 18b4 	str.w	r1, [r3, #2228]	; 0x8b4
			thinkos_rt.ev[i].mask = 0xffffffff; /* all events a are enabled */
 8001cfc:	f8c3 28b8 	str.w	r2, [r3, #2232]	; 0x8b8
 8001d00:	3308      	adds	r3, #8

#if THINKOS_EVENT_MAX > 0
	{
		int i;
		/* initialize the event sets */
		for (i = 0; i < THINKOS_EVENT_MAX; i++) {
 8001d02:	4283      	cmp	r3, r0
 8001d04:	d1f8      	bne.n	8001cf8 <thinkos_init+0x110>
	/* alloc main thread */
	if (opt.id >= THINKOS_THREADS_MAX)
		opt.id = THINKOS_THREADS_MAX - 1;
#if THINKOS_ENABLE_THREAD_ALLOC
	/* initialize the thread allocation bitmap */ 
	thinkos_rt.th_alloc[0] = (uint32_t)(0xffffffffLL << THINKOS_THREADS_MAX);
 8001d06:	2300      	movs	r3, #0
 8001d08:	f8c4 3bec 	str.w	r3, [r4, #3052]	; 0xbec
 8001d0c:	2d1f      	cmp	r5, #31
 8001d0e:	bfa8      	it	ge
 8001d10:	251f      	movge	r5, #31
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8001d12:	f04f 32ff 	mov.w	r2, #4294967295
 8001d16:	fa92 f3a2 	rbit	r3, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8001d1a:	fab3 f383 	clz	r3, r3

static inline int __attribute__((always_inline)) 
thinkos_alloc_lo(uint32_t * ptr, int start) {
	int idx;
	/* Look for an empty bit MSB first */
	idx = __clz(__rbit(~(*ptr >> start))) + start;
 8001d1e:	18ed      	adds	r5, r5, r3
	if (idx >= 32)
 8001d20:	2d1f      	cmp	r5, #31
 8001d22:	dc33      	bgt.n	8001d8c <thinkos_init+0x1a4>

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8001d24:	4b23      	ldr	r3, [pc, #140]	; (8001db4 <thinkos_init+0x1cc>)
 8001d26:	015b      	lsls	r3, r3, #5
 8001d28:	2201      	movs	r2, #1
 8001d2a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 8001d2e:	00ab      	lsls	r3, r5, #2
#else
	self = opt.id;
#endif

#if THINKOS_ENABLE_THREAD_INFO
	thinkos_rt.th_inf[self] = (struct thinkos_thread_inf *)&thinkos_main_inf;
 8001d30:	eb04 0285 	add.w	r2, r4, r5, lsl #2
 8001d34:	4920      	ldr	r1, [pc, #128]	; (8001db8 <thinkos_init+0x1d0>)
	if (thinkos_rt.sched_limit < THINKOS_SCHED_LIMIT_MIN)
		thinkos_rt.sched_limit = THINKOS_SCHED_LIMIT_MIN;
#endif /* THINKOS_ENABLE_TIMESHARE */

	/* set the active thread */
	thinkos_rt.active = self;
 8001d36:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
#else
	self = opt.id;
#endif

#if THINKOS_ENABLE_THREAD_INFO
	thinkos_rt.th_inf[self] = (struct thinkos_thread_inf *)&thinkos_main_inf;
 8001d3a:	f8c2 1c2c 	str.w	r1, [r2, #3116]	; 0xc2c
 8001d3e:	4a1f      	ldr	r2, [pc, #124]	; (8001dbc <thinkos_init+0x1d4>)
#if (THINKOS_THREADS_MAX < 32) 
	/* put the IDLE thread in the ready queue */
	bmp_bit_set(&thinkos_rt.wq_ready, THINKOS_THREADS_MAX);
#endif

	DCC_LOG2(LOG_TRACE, "threads_max=%d ready=%08x", 
 8001d40:	481f      	ldr	r0, [pc, #124]	; (8001dc0 <thinkos_init+0x1d8>)
 8001d42:	0152      	lsls	r2, r2, #5
 8001d44:	2101      	movs	r1, #1
 8001d46:	50d1      	str	r1, [r2, r3]
 8001d48:	2120      	movs	r1, #32
 8001d4a:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 8001d4e:	f002 fb8f 	bl	8004470 <ice_trace2>
			 THINKOS_THREADS_MAX, thinkos_rt.wq_ready);

	/* initialize the SysTick module */
	systick->load = cm3_systick_load_1ms; /* 1ms tick period */
 8001d52:	4a1c      	ldr	r2, [pc, #112]	; (8001dc4 <thinkos_init+0x1dc>)
		/* Invoke the scheduler */
		__thinkos_defer_sched();
	} else
#endif

	DCC_LOG(LOG_TRACE, "enabling interrupts!");
 8001d54:	481c      	ldr	r0, [pc, #112]	; (8001dc8 <thinkos_init+0x1e0>)

	DCC_LOG2(LOG_TRACE, "threads_max=%d ready=%08x", 
			 THINKOS_THREADS_MAX, thinkos_rt.wq_ready);

	/* initialize the SysTick module */
	systick->load = cm3_systick_load_1ms; /* 1ms tick period */
 8001d56:	6812      	ldr	r2, [r2, #0]
 8001d58:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001d5c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001d60:	605a      	str	r2, [r3, #4]
	systick->val = 0;
 8001d62:	2200      	movs	r2, #0
 8001d64:	609a      	str	r2, [r3, #8]
#if THINKOS_ENABLE_CLOCK || THINKOS_ENABLE_TIMESHARE
	systick->ctrl = SYSTICK_CTRL_ENABLE | SYSTICK_CTRL_TICKINT;
 8001d66:	2203      	movs	r2, #3
 8001d68:	601a      	str	r2, [r3, #0]
		/* Invoke the scheduler */
		__thinkos_defer_sched();
	} else
#endif

	DCC_LOG(LOG_TRACE, "enabling interrupts!");
 8001d6a:	f002 fb2d 	bl	80043c8 <ice_trace0>
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8001d6e:	b662      	cpsie	i
	asm volatile ("msr MSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_msp_get(void) {
	uint32_t msp;
	asm volatile ("mrs %0, MSP\n" : "=r" (msp));
 8001d70:	f3ef 8208 	mrs	r2, MSP
	asm volatile ("msr PSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_psp_get(void) {
	uint32_t psp;
	asm volatile ("mrs %0, PSP\n" : "=r" (psp));
 8001d74:	f3ef 8309 	mrs	r3, PSP
	asm volatile ("msr CONTROL, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_control_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, CONTROL\n" : "=r" (val));
 8001d78:	f3ef 8114 	mrs	r1, CONTROL

	/* enable interrupts */
	cm3_cpsie_i();

	DCC_LOG4(LOG_TRACE, "<%d> msp=%08x psp=%08x ctrl=%08x", 
 8001d7c:	4813      	ldr	r0, [pc, #76]	; (8001dcc <thinkos_init+0x1e4>)
 8001d7e:	9100      	str	r1, [sp, #0]
 8001d80:	4629      	mov	r1, r5
 8001d82:	f002 fbe7 	bl	8004554 <ice_trace4>
			 self, cm3_msp_get(), cm3_psp_get(), cm3_control_get());

	return self;
}
 8001d86:	4628      	mov	r0, r5
 8001d88:	b004      	add	sp, #16
 8001d8a:	bd70      	pop	{r4, r5, r6, pc}
 8001d8c:	f06f 0303 	mvn.w	r3, #3
		return -1;
 8001d90:	4615      	mov	r5, r2
 8001d92:	e7cd      	b.n	8001d30 <thinkos_init+0x148>
 8001d94:	20000088 	.word	0x20000088
 8001d98:	20000eb8 	.word	0x20000eb8
 8001d9c:	40000100 	.word	0x40000100
 8001da0:	20000d34 	.word	0x20000d34
 8001da4:	20000e88 	.word	0x20000e88
 8001da8:	20000778 	.word	0x20000778
 8001dac:	08001a91 	.word	0x08001a91
 8001db0:	20000308 	.word	0x20000308
 8001db4:	21100c74 	.word	0x21100c74
 8001db8:	0800514c 	.word	0x0800514c
 8001dbc:	21100110 	.word	0x21100110
 8001dc0:	40000110 	.word	0x40000110
 8001dc4:	08004ce0 	.word	0x08004ce0
 8001dc8:	40000120 	.word	0x40000120
 8001dcc:	40000130 	.word	0x40000130

08001dd0 <thinkos_bmp_alloc>:

int thinkos_bmp_alloc(uint32_t bmp[], int bits) 
{
 8001dd0:	b410      	push	{r4}
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
 8001dd2:	f101 043e 	add.w	r4, r1, #62	; 0x3e
 8001dd6:	311f      	adds	r1, #31
 8001dd8:	bf58      	it	pl
 8001dda:	460c      	movpl	r4, r1
 8001ddc:	1164      	asrs	r4, r4, #5
 8001dde:	2c00      	cmp	r4, #0
 8001de0:	dd18      	ble.n	8001e14 <thinkos_bmp_alloc+0x44>
		/* Look for an empty bit MSB first */
		if ((j = __clz(__rbit(~(bmp[i])))) < 32) {
 8001de2:	6802      	ldr	r2, [r0, #0]
 8001de4:	43d2      	mvns	r2, r2
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8001de6:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8001dea:	fab2 f282 	clz	r2, r2
int thinkos_bmp_alloc(uint32_t bmp[], int bits) 
{
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
 8001dee:	2300      	movs	r3, #0
			 self, cm3_msp_get(), cm3_psp_get(), cm3_control_get());

	return self;
}

int thinkos_bmp_alloc(uint32_t bmp[], int bits) 
 8001df0:	1d01      	adds	r1, r0, #4
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
		/* Look for an empty bit MSB first */
		if ((j = __clz(__rbit(~(bmp[i])))) < 32) {
 8001df2:	2a1f      	cmp	r2, #31
 8001df4:	dc08      	bgt.n	8001e08 <thinkos_bmp_alloc+0x38>
 8001df6:	e01a      	b.n	8001e2e <thinkos_bmp_alloc+0x5e>
 8001df8:	6802      	ldr	r2, [r0, #0]
 8001dfa:	43d2      	mvns	r2, r2
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8001dfc:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8001e00:	fab2 f282 	clz	r2, r2
 8001e04:	2a1f      	cmp	r2, #31
 8001e06:	dd09      	ble.n	8001e1c <thinkos_bmp_alloc+0x4c>
int thinkos_bmp_alloc(uint32_t bmp[], int bits) 
{
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
 8001e08:	3301      	adds	r3, #1
 8001e0a:	42a3      	cmp	r3, r4
		/* Look for an empty bit MSB first */
		if ((j = __clz(__rbit(~(bmp[i])))) < 32) {
 8001e0c:	4608      	mov	r0, r1
 8001e0e:	f101 0104 	add.w	r1, r1, #4
int thinkos_bmp_alloc(uint32_t bmp[], int bits) 
{
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
 8001e12:	d1f1      	bne.n	8001df8 <thinkos_bmp_alloc+0x28>
			/* Mark as used */
			__bit_mem_wr(&bmp[i], j, 1);  
			return 32 * i + j;;
		}
	}
	return -1;
 8001e14:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001e18:	bc10      	pop	{r4}
 8001e1a:	4770      	bx	lr
 8001e1c:	015b      	lsls	r3, r3, #5
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8001e1e:	f100 7188 	add.w	r1, r0, #17825792	; 0x1100000
	bit_addr[bit] = val;
 8001e22:	0149      	lsls	r1, r1, #5
 8001e24:	2401      	movs	r4, #1
 8001e26:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
	for (i = 0; i < ((bits + 31) / 32); ++i) {
		/* Look for an empty bit MSB first */
		if ((j = __clz(__rbit(~(bmp[i])))) < 32) {
			/* Mark as used */
			__bit_mem_wr(&bmp[i], j, 1);  
			return 32 * i + j;;
 8001e2a:	18d0      	adds	r0, r2, r3
 8001e2c:	e7f4      	b.n	8001e18 <thinkos_bmp_alloc+0x48>
	int i;
	int j;

	for (i = 0; i < ((bits + 31) / 32); ++i) {
		/* Look for an empty bit MSB first */
		if ((j = __clz(__rbit(~(bmp[i])))) < 32) {
 8001e2e:	2300      	movs	r3, #0
 8001e30:	e7f5      	b.n	8001e1e <thinkos_bmp_alloc+0x4e>
 8001e32:	bf00      	nop
 8001e34:	f3af 8000 	nop.w
 8001e38:	f3af 8000 	nop.w
 8001e3c:	f3af 8000 	nop.w

08001e40 <cm3_svc_isr>:
				  : "=r" (sp));
	return sp;
}

void cm3_svc_isr(void)
{
 8001e40:	b510      	push	{r4, lr}

void thinkos_rt_snapshot_svc(int32_t * arg);

static inline uint32_t __attribute__((always_inline)) cm3_svc_stackframe(void) {
	register uint32_t sp;
	asm volatile ("tst lr, #4\n" 
 8001e42:	f01e 0f04 	tst.w	lr, #4
 8001e46:	bf0c      	ite	eq
 8001e48:	f3ef 8408 	mrseq	r4, MSP
 8001e4c:	f3ef 8409 	mrsne	r4, PSP
#endif

	/* get PC value */
	pc = (uint8_t *)arg[6];
	/* get the immediate data from instruction */
	svc = pc[-2];
 8001e50:	69a3      	ldr	r3, [r4, #24]
 8001e52:	f813 1c02 	ldrb.w	r1, [r3, #-2]

	DCC_LOG1(LOG_MSG, "pc=0x%08x", pc);

	switch (svc) {
 8001e56:	2930      	cmp	r1, #48	; 0x30
 8001e58:	f200 8117 	bhi.w	800208a <cm3_svc_isr+0x24a>
 8001e5c:	e8df f011 	tbh	[pc, r1, lsl #1]
 8001e60:	010b0110 	.word	0x010b0110
 8001e64:	01010106 	.word	0x01010106
 8001e68:	00f700fc 	.word	0x00f700fc
 8001e6c:	00ed00f2 	.word	0x00ed00f2
 8001e70:	00e300e8 	.word	0x00e300e8
 8001e74:	00d900de 	.word	0x00d900de
 8001e78:	00cf00d4 	.word	0x00cf00d4
 8001e7c:	00c500ca 	.word	0x00c500ca
 8001e80:	00bb00c0 	.word	0x00bb00c0
 8001e84:	00b100b6 	.word	0x00b100b6
 8001e88:	00a700ac 	.word	0x00a700ac
 8001e8c:	009d00a2 	.word	0x009d00a2
 8001e90:	00930098 	.word	0x00930098
 8001e94:	0089008e 	.word	0x0089008e
 8001e98:	007f0084 	.word	0x007f0084
 8001e9c:	0075007a 	.word	0x0075007a
 8001ea0:	006b0070 	.word	0x006b0070
 8001ea4:	00610066 	.word	0x00610066
 8001ea8:	0057005c 	.word	0x0057005c
 8001eac:	004d0052 	.word	0x004d0052
 8001eb0:	00430048 	.word	0x00430048
 8001eb4:	0115003b 	.word	0x0115003b
 8001eb8:	01150115 	.word	0x01150115
 8001ebc:	00360115 	.word	0x00360115
 8001ec0:	0031      	.short	0x0031
		break;
#endif /* THINKOS_IRQ_MAX > 0 */

#if THINKOS_ENABLE_EXIT
	case THINKOS_EXIT:
		thinkos_exit_svc(arg);
 8001ec2:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001ec4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif /* THINKOS_IRQ_MAX > 0 */

#if THINKOS_ENABLE_EXIT
	case THINKOS_EXIT:
		thinkos_exit_svc(arg);
 8001ec8:	f000 bee2 	b.w	8002c90 <thinkos_exit_svc>
		break;
#endif

#if THINKOS_ENABLE_RT_DEBUG
	case THINKOS_RT_SNAPSHOT:
		thinkos_rt_snapshot_svc(arg);
 8001ecc:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001ece:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif

#if THINKOS_ENABLE_RT_DEBUG
	case THINKOS_RT_SNAPSHOT:
		thinkos_rt_snapshot_svc(arg);
 8001ed2:	f000 be5f 	b.w	8002b94 <thinkos_rt_snapshot_svc>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8001ed6:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8001eda:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001ede:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001ee2:	605a      	str	r2, [r3, #4]
 8001ee4:	bd10      	pop	{r4, pc}
	case THINKOS_EVENT_ALLOC:
		thinkos_ev_alloc_svc(arg);
		break;

	case THINKOS_EVENT_FREE:
		thinkos_ev_free_svc(arg);
 8001ee6:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001ee8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_EVENT_ALLOC:
		thinkos_ev_alloc_svc(arg);
		break;

	case THINKOS_EVENT_FREE:
		thinkos_ev_free_svc(arg);
 8001eec:	f001 bd44 	b.w	8003978 <thinkos_ev_free_svc>


#if (THINKOS_EVENT_MAX > 0)
#if THINKOS_ENABLE_EVENT_ALLOC
	case THINKOS_EVENT_ALLOC:
		thinkos_ev_alloc_svc(arg);
 8001ef0:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001ef2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


#if (THINKOS_EVENT_MAX > 0)
#if THINKOS_ENABLE_EVENT_ALLOC
	case THINKOS_EVENT_ALLOC:
		thinkos_ev_alloc_svc(arg);
 8001ef6:	f001 bd23 	b.w	8003940 <thinkos_ev_alloc_svc>
	case THINKOS_FLAG_ALLOC:
		thinkos_flag_alloc_svc(arg);
		break;

	case THINKOS_FLAG_FREE:
		thinkos_flag_free_svc(arg);
 8001efa:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001efc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_FLAG_ALLOC:
		thinkos_flag_alloc_svc(arg);
		break;

	case THINKOS_FLAG_FREE:
		thinkos_flag_free_svc(arg);
 8001f00:	f000 b94c 	b.w	800219c <thinkos_flag_free_svc>


#if (THINKOS_FLAG_MAX > 0)
#if THINKOS_ENABLE_FLAG_ALLOC
	case THINKOS_FLAG_ALLOC:
		thinkos_flag_alloc_svc(arg);
 8001f04:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


#if (THINKOS_FLAG_MAX > 0)
#if THINKOS_ENABLE_FLAG_ALLOC
	case THINKOS_FLAG_ALLOC:
		thinkos_flag_alloc_svc(arg);
 8001f0a:	f000 b923 	b.w	8002154 <thinkos_flag_alloc_svc>
	case THINKOS_COND_ALLOC:
		thinkos_cond_alloc_svc(arg);
		break;

	case THINKOS_COND_FREE:
		thinkos_cond_free_svc(arg);
 8001f0e:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_COND_ALLOC:
		thinkos_cond_alloc_svc(arg);
		break;

	case THINKOS_COND_FREE:
		thinkos_cond_free_svc(arg);
 8001f14:	f001 b926 	b.w	8003164 <thinkos_cond_free_svc>


#if THINKOS_COND_MAX > 0
#if THINKOS_ENABLE_COND_ALLOC
	case THINKOS_COND_ALLOC:
		thinkos_cond_alloc_svc(arg);
 8001f18:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


#if THINKOS_COND_MAX > 0
#if THINKOS_ENABLE_COND_ALLOC
	case THINKOS_COND_ALLOC:
		thinkos_cond_alloc_svc(arg);
 8001f1e:	f001 b911 	b.w	8003144 <thinkos_cond_alloc_svc>
	case THINKOS_SEM_ALLOC:
		thinkos_sem_alloc_svc(arg);
		break;

	case THINKOS_SEM_FREE:
		thinkos_sem_free_svc(arg);
 8001f22:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_SEM_ALLOC:
		thinkos_sem_alloc_svc(arg);
		break;

	case THINKOS_SEM_FREE:
		thinkos_sem_free_svc(arg);
 8001f28:	f001 bb78 	b.w	800361c <thinkos_sem_free_svc>


#if THINKOS_SEMAPHORE_MAX > 0
#if THINKOS_ENABLE_SEM_ALLOC
	case THINKOS_SEM_ALLOC:
		thinkos_sem_alloc_svc(arg);
 8001f2c:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


#if THINKOS_SEMAPHORE_MAX > 0
#if THINKOS_ENABLE_SEM_ALLOC
	case THINKOS_SEM_ALLOC:
		thinkos_sem_alloc_svc(arg);
 8001f32:	f001 bb55 	b.w	80035e0 <thinkos_sem_alloc_svc>
	case THINKOS_MUTEX_ALLOC:
		thinkos_mutex_alloc_svc(arg);
		break;

	case THINKOS_MUTEX_FREE:
		thinkos_mutex_free_svc(arg);
 8001f36:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_MUTEX_ALLOC:
		thinkos_mutex_alloc_svc(arg);
		break;

	case THINKOS_MUTEX_FREE:
		thinkos_mutex_free_svc(arg);
 8001f3c:	f000 bf84 	b.w	8002e48 <thinkos_mutex_free_svc>
#endif

#if THINKOS_MUTEX_MAX > 0
#if THINKOS_ENABLE_MUTEX_ALLOC
	case THINKOS_MUTEX_ALLOC:
		thinkos_mutex_alloc_svc(arg);
 8001f40:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#endif

#if THINKOS_MUTEX_MAX > 0
#if THINKOS_ENABLE_MUTEX_ALLOC
	case THINKOS_MUTEX_ALLOC:
		thinkos_mutex_alloc_svc(arg);
 8001f46:	f000 bf69 	b.w	8002e1c <thinkos_mutex_alloc_svc>
		break;
#endif /* (THINKOS_FLAG_MAX > 0) */

#if THINKOS_IRQ_MAX > 0
	case THINKOS_IRQ_WAIT:
		thinkos_irq_wait_svc(arg);
 8001f4a:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif /* (THINKOS_FLAG_MAX > 0) */

#if THINKOS_IRQ_MAX > 0
	case THINKOS_IRQ_WAIT:
		thinkos_irq_wait_svc(arg);
 8001f50:	f000 b8ca 	b.w	80020e8 <thinkos_irq_wait_svc>
	case THINKOS_EVENT_MASK:
		thinkos_ev_mask_svc(arg);
		break;

	case THINKOS_EVENT_UNMASK:
		thinkos_ev_unmask_svc(arg);
 8001f54:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_EVENT_MASK:
		thinkos_ev_mask_svc(arg);
		break;

	case THINKOS_EVENT_UNMASK:
		thinkos_ev_unmask_svc(arg);
 8001f5a:	f001 be95 	b.w	8003c88 <thinkos_ev_unmask_svc>
	case THINKOS_EVENT_RAISE:
		thinkos_ev_raise_svc(arg);
		break;

	case THINKOS_EVENT_MASK:
		thinkos_ev_mask_svc(arg);
 8001f5e:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_EVENT_RAISE:
		thinkos_ev_raise_svc(arg);
		break;

	case THINKOS_EVENT_MASK:
		thinkos_ev_mask_svc(arg);
 8001f64:	f001 be64 	b.w	8003c30 <thinkos_ev_mask_svc>
		thinkos_ev_timedwait_svc(arg);
		break;
#endif

	case THINKOS_EVENT_RAISE:
		thinkos_ev_raise_svc(arg);
 8001f68:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_ev_timedwait_svc(arg);
		break;
#endif

	case THINKOS_EVENT_RAISE:
		thinkos_ev_raise_svc(arg);
 8001f6e:	f001 bded 	b.w	8003b4c <thinkos_ev_raise_svc>
		thinkos_ev_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_EVENT_TIMEDWAIT:
		thinkos_ev_timedwait_svc(arg);
 8001f72:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_ev_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_EVENT_TIMEDWAIT:
		thinkos_ev_timedwait_svc(arg);
 8001f78:	f001 bd76 	b.w	8003a68 <thinkos_ev_timedwait_svc>
		thinkos_ev_free_svc(arg);
		break;
#endif

	case THINKOS_EVENT_WAIT:
		thinkos_ev_wait_svc(arg);
 8001f7c:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_ev_free_svc(arg);
		break;
#endif

	case THINKOS_EVENT_WAIT:
		thinkos_ev_wait_svc(arg);
 8001f82:	f001 bd11 	b.w	80039a8 <thinkos_ev_wait_svc>
		thinkos_flag_timedtake_svc(arg);
		break;
#endif

	case THINKOS_FLAG_GIVE:
		thinkos_flag_give_svc(arg);
 8001f86:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_flag_timedtake_svc(arg);
		break;
#endif

	case THINKOS_FLAG_GIVE:
		thinkos_flag_give_svc(arg);
 8001f8c:	f000 bb16 	b.w	80025bc <thinkos_flag_give_svc>
		thinkos_flag_take_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_FLAG_TIMEDTAKE:
		thinkos_flag_timedtake_svc(arg);
 8001f90:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_flag_take_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_FLAG_TIMEDTAKE:
		thinkos_flag_timedtake_svc(arg);
 8001f96:	f000 baad 	b.w	80024f4 <thinkos_flag_timedtake_svc>
		thinkos_flag_release_svc(arg);
		break;
#endif

	case THINKOS_FLAG_TAKE:
		thinkos_flag_take_svc(arg);
 8001f9a:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001f9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_flag_release_svc(arg);
		break;
#endif

	case THINKOS_FLAG_TAKE:
		thinkos_flag_take_svc(arg);
 8001fa0:	f000 ba56 	b.w	8002450 <thinkos_flag_take_svc>
		break;
#endif

#if THINKOS_ENABLE_FLAG_LOCK
	case THINKOS_FLAG_RELEASE:
		thinkos_flag_release_svc(arg);
 8001fa4:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fa6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif

#if THINKOS_ENABLE_FLAG_LOCK
	case THINKOS_FLAG_RELEASE:
		thinkos_flag_release_svc(arg);
 8001faa:	f000 b9db 	b.w	8002364 <thinkos_flag_release_svc>
		thinkos_flag_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_FLAG_TIMEDWAIT:
		thinkos_flag_timedwait_svc(arg);
 8001fae:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_flag_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_FLAG_TIMEDWAIT:
		thinkos_flag_timedwait_svc(arg);
 8001fb4:	f000 b964 	b.w	8002280 <thinkos_flag_timedwait_svc>
	case THINKOS_FLAG_SET:
		thinkos_flag_set_svc(arg);
		break;

	case THINKOS_FLAG_WAIT:
		thinkos_flag_wait_svc(arg);
 8001fb8:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_FLAG_SET:
		thinkos_flag_set_svc(arg);
		break;

	case THINKOS_FLAG_WAIT:
		thinkos_flag_wait_svc(arg);
 8001fbe:	f000 b905 	b.w	80021cc <thinkos_flag_wait_svc>
	case THINKOS_FLAG_CLR:
		thinkos_flag_clr_svc(arg);
		break;

	case THINKOS_FLAG_SET:
		thinkos_flag_set_svc(arg);
 8001fc2:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_FLAG_CLR:
		thinkos_flag_clr_svc(arg);
		break;

	case THINKOS_FLAG_SET:
		thinkos_flag_set_svc(arg);
 8001fc8:	f000 bb7c 	b.w	80026c4 <thinkos_flag_set_svc>
		thinkos_flag_free_svc(arg);
		break;
#endif

	case THINKOS_FLAG_CLR:
		thinkos_flag_clr_svc(arg);
 8001fcc:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_flag_free_svc(arg);
		break;
#endif

	case THINKOS_FLAG_CLR:
		thinkos_flag_clr_svc(arg);
 8001fd2:	f000 bb4d 	b.w	8002670 <thinkos_flag_clr_svc>
	case THINKOS_COND_SIGNAL:
		thinkos_cond_signal_svc(arg);
		break;

	case THINKOS_COND_BROADCAST:
		thinkos_cond_broadcast_svc(arg);
 8001fd6:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_COND_SIGNAL:
		thinkos_cond_signal_svc(arg);
		break;

	case THINKOS_COND_BROADCAST:
		thinkos_cond_broadcast_svc(arg);
 8001fdc:	f001 ba86 	b.w	80034ec <thinkos_cond_broadcast_svc>
		thinkos_cond_timedwait_svc(arg);
		break;
#endif

	case THINKOS_COND_SIGNAL:
		thinkos_cond_signal_svc(arg);
 8001fe0:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fe2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_cond_timedwait_svc(arg);
		break;
#endif

	case THINKOS_COND_SIGNAL:
		thinkos_cond_signal_svc(arg);
 8001fe6:	f001 ba2d 	b.w	8003444 <thinkos_cond_signal_svc>
		thinkos_cond_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_COND_TIMEDWAIT:
		thinkos_cond_timedwait_svc(arg);
 8001fea:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001fec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_cond_wait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_COND_TIMEDWAIT:
		thinkos_cond_timedwait_svc(arg);
 8001ff0:	f001 b974 	b.w	80032dc <thinkos_cond_timedwait_svc>
		thinkos_cond_free_svc(arg);
		break;
#endif /* THINKOS_COND_ALLOC */

	case THINKOS_COND_WAIT:
		thinkos_cond_wait_svc(arg);
 8001ff4:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8001ff6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_cond_free_svc(arg);
		break;
#endif /* THINKOS_COND_ALLOC */

	case THINKOS_COND_WAIT:
		thinkos_cond_wait_svc(arg);
 8001ffa:	f001 b8cb 	b.w	8003194 <thinkos_cond_wait_svc>
		thinkos_sem_timedwait_svc(arg);
		break;
#endif

	case THINKOS_SEM_POST:
		thinkos_sem_post_svc(arg);
 8001ffe:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002000:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_sem_timedwait_svc(arg);
		break;
#endif

	case THINKOS_SEM_POST:
		thinkos_sem_post_svc(arg);
 8002004:	f001 bc40 	b.w	8003888 <thinkos_sem_post_svc>
		thinkos_sem_trywait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_SEM_TIMEDWAIT:
		thinkos_sem_timedwait_svc(arg);
 8002008:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 800200a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_sem_trywait_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_SEM_TIMEDWAIT:
		thinkos_sem_timedwait_svc(arg);
 800200e:	f001 bbd5 	b.w	80037bc <thinkos_sem_timedwait_svc>
	case THINKOS_SEM_WAIT:
		thinkos_sem_wait_svc(arg);
		break;

	case THINKOS_SEM_TRYWAIT:
		thinkos_sem_trywait_svc(arg);
 8002012:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002014:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_SEM_WAIT:
		thinkos_sem_wait_svc(arg);
		break;

	case THINKOS_SEM_TRYWAIT:
		thinkos_sem_trywait_svc(arg);
 8002018:	f001 bb9c 	b.w	8003754 <thinkos_sem_trywait_svc>
	case THINKOS_SEM_INIT:
		thinkos_sem_init_svc(arg);
		break;

	case THINKOS_SEM_WAIT:
		thinkos_sem_wait_svc(arg);
 800201c:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 800201e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_SEM_INIT:
		thinkos_sem_init_svc(arg);
		break;

	case THINKOS_SEM_WAIT:
		thinkos_sem_wait_svc(arg);
 8002022:	f001 bb47 	b.w	80036b4 <thinkos_sem_wait_svc>
		thinkos_sem_free_svc(arg);
		break;
#endif /* THINKOS_ENABLE_SEM_ALLOC */

	case THINKOS_SEM_INIT:
		thinkos_sem_init_svc(arg);
 8002026:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002028:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_sem_free_svc(arg);
		break;
#endif /* THINKOS_ENABLE_SEM_ALLOC */

	case THINKOS_SEM_INIT:
		thinkos_sem_init_svc(arg);
 800202c:	f001 bb0e 	b.w	800364c <thinkos_sem_init_svc>
		thinkos_mutex_timedlock_svc(arg);
		break;
#endif

	case THINKOS_MUTEX_UNLOCK:
		thinkos_mutex_unlock_svc(arg);
 8002030:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002032:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_mutex_timedlock_svc(arg);
		break;
#endif

	case THINKOS_MUTEX_UNLOCK:
		thinkos_mutex_unlock_svc(arg);
 8002036:	f001 b81b 	b.w	8003070 <thinkos_mutex_unlock_svc>
		thinkos_mutex_trylock_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_MUTEX_TIMEDLOCK:
		thinkos_mutex_timedlock_svc(arg);
 800203a:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 800203c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_mutex_trylock_svc(arg);
		break;

#if THINKOS_ENABLE_TIMED_CALLS
	case THINKOS_MUTEX_TIMEDLOCK:
		thinkos_mutex_timedlock_svc(arg);
 8002040:	f000 bfaa 	b.w	8002f98 <thinkos_mutex_timedlock_svc>
	case THINKOS_MUTEX_LOCK:
		thinkos_mutex_lock_svc(arg);
		break;

	case THINKOS_MUTEX_TRYLOCK:
		thinkos_mutex_trylock_svc(arg);
 8002044:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002046:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_MUTEX_LOCK:
		thinkos_mutex_lock_svc(arg);
		break;

	case THINKOS_MUTEX_TRYLOCK:
		thinkos_mutex_trylock_svc(arg);
 800204a:	f000 bf6f 	b.w	8002f2c <thinkos_mutex_trylock_svc>
		thinkos_mutex_free_svc(arg);
		break;
#endif /* THINKOS_MUTEX_ALLOC */

	case THINKOS_MUTEX_LOCK:
		thinkos_mutex_lock_svc(arg);
 800204e:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002050:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		thinkos_mutex_free_svc(arg);
		break;
#endif /* THINKOS_MUTEX_ALLOC */

	case THINKOS_MUTEX_LOCK:
		thinkos_mutex_lock_svc(arg);
 8002054:	f000 bf10 	b.w	8002e78 <thinkos_mutex_lock_svc>
		break;
#endif

#if THINKOS_ENABLE_SLEEP
	case THINKOS_SLEEP:
		thinkos_sleep_svc(arg);
 8002058:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 800205a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif

#if THINKOS_ENABLE_SLEEP
	case THINKOS_SLEEP:
		thinkos_sleep_svc(arg);
 800205e:	f000 bdc5 	b.w	8002bec <thinkos_sleep_svc>
		break;
#endif

#if THINKOS_ENABLE_ALARM
	case THINKOS_ALARM:
		thinkos_alarm_svc(arg);
 8002062:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002064:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
#endif

#if THINKOS_ENABLE_ALARM
	case THINKOS_ALARM:
		thinkos_alarm_svc(arg);
 8002068:	f000 bdea 	b.w	8002c40 <thinkos_alarm_svc>
		break;
#endif
		
#if THINKOS_ENABLE_CLOCK
	case THINKOS_CLOCK:
		arg[0] = thinkos_rt.ticks;
 800206c:	4b0a      	ldr	r3, [pc, #40]	; (8002098 <cm3_svc_isr+0x258>)
 800206e:	f8d3 36f0 	ldr.w	r3, [r3, #1776]	; 0x6f0
 8002072:	6023      	str	r3, [r4, #0]
		break;
 8002074:	bd10      	pop	{r4, pc}
	case THINKOS_THREAD_SELF:
		arg[0] = thinkos_rt.active;
		break;

	case THINKOS_THREAD_CREATE:
		thinkos_thread_create_svc(arg);
 8002076:	4620      	mov	r0, r4
	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
		arg[0] = THINKOS_ENOSYS;
		break;
	}
}
 8002078:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	case THINKOS_THREAD_SELF:
		arg[0] = thinkos_rt.active;
		break;

	case THINKOS_THREAD_CREATE:
		thinkos_thread_create_svc(arg);
 800207c:	f000 be32 	b.w	8002ce4 <thinkos_thread_create_svc>

	DCC_LOG1(LOG_MSG, "pc=0x%08x", pc);

	switch (svc) {
	case THINKOS_THREAD_SELF:
		arg[0] = thinkos_rt.active;
 8002080:	4b05      	ldr	r3, [pc, #20]	; (8002098 <cm3_svc_isr+0x258>)
 8002082:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8002086:	6023      	str	r3, [r4, #0]
		break;
 8002088:	bd10      	pop	{r4, pc}
		thinkos_rt_snapshot_svc(arg);
		break;
#endif

	default:
		DCC_LOG1(LOG_WARNING, "Invalid System call: %d", svc);
 800208a:	4804      	ldr	r0, [pc, #16]	; (800209c <cm3_svc_isr+0x25c>)
 800208c:	f002 f9c2 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_ENOSYS;
 8002090:	f06f 0306 	mvn.w	r3, #6
 8002094:	6023      	str	r3, [r4, #0]
 8002096:	bd10      	pop	{r4, pc}
 8002098:	20000088 	.word	0x20000088
 800209c:	40000140 	.word	0x40000140

080020a0 <cm3_default_isr>:
#include <stdio.h>

#if THINKOS_IRQ_MAX > 0

void cm3_default_isr(int irq) 
{
 80020a0:	b430      	push	{r4, r5}
	CM3_NVIC->iser[irq >> 5] = (1 << (irq & 0x1f));
}

/* Disable the interrupt line for external interrupt specified */
static inline void __attribute__((always_inline)) cm3_irq_disable(int irq) {
	CM3_NVIC->icer[irq >> 5] = (1 << (irq & 0x1f));
 80020a2:	f44f 4161 	mov.w	r1, #57600	; 0xe100
 80020a6:	1144      	asrs	r4, r0, #5
 80020a8:	2201      	movs	r2, #1
 80020aa:	f000 051f 	and.w	r5, r0, #31
 80020ae:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80020b2:	3420      	adds	r4, #32
	int th;

	/* disable this interrupt source */
	cm3_irq_disable(irq);

	th = thinkos_rt.irq_th[irq];
 80020b4:	f240 0388 	movw	r3, #136	; 0x88
 80020b8:	fa02 f505 	lsl.w	r5, r2, r5
 80020bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020c0:	f841 5024 	str.w	r5, [r1, r4, lsl #2]
 80020c4:	1818      	adds	r0, r3, r0

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 80020c6:	4907      	ldr	r1, [pc, #28]	; (80020e4 <cm3_default_isr+0x44>)
 80020c8:	f990 0b9c 	ldrsb.w	r0, [r0, #2972]	; 0xb9c
 80020cc:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80020d0:	0149      	lsls	r1, r1, #5
 80020d2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80020d6:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
 80020da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80020de:	605a      	str	r2, [r3, #4]
	/* insert the thread into ready queue */
	__bit_mem_wr(&thinkos_rt.wq_ready, th, 1);  

	/* signal the scheduler ... */
	__thinkos_defer_sched();
}
 80020e0:	bc30      	pop	{r4, r5}
 80020e2:	4770      	bx	lr
 80020e4:	21100110 	.word	0x21100110

080020e8 <thinkos_irq_wait_svc>:

void thinkos_irq_wait_svc(int32_t * arg)
{
	unsigned int irq = arg[0];
 80020e8:	6801      	ldr	r1, [r0, #0]
	int32_t self = thinkos_rt.active;
 80020ea:	4a17      	ldr	r2, [pc, #92]	; (8002148 <thinkos_irq_wait_svc+0x60>)

#if THINKOS_ENABLE_ARG_CHECK
	if (irq >= THINKOS_IRQ_MAX) {
 80020ec:	294f      	cmp	r1, #79	; 0x4f
	/* signal the scheduler ... */
	__thinkos_defer_sched();
}

void thinkos_irq_wait_svc(int32_t * arg)
{
 80020ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80020f0:	4605      	mov	r5, r0
	unsigned int irq = arg[0];
	int32_t self = thinkos_rt.active;
 80020f2:	f8d2 4084 	ldr.w	r4, [r2, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (irq >= THINKOS_IRQ_MAX) {
 80020f6:	d81f      	bhi.n	8002138 <thinkos_irq_wait_svc+0x50>
	CM3_NVIC->ispr[irq >> 5] = (1 << (irq & 0x1f));
}

/* Clear the pending bit for an external interrupt */
static inline void __attribute__((always_inline)) cm3_irq_pend_clr(int irq) {
	CM3_NVIC->icpr[irq >> 5] = (1 << (irq & 0x1f));
 80020f8:	114d      	asrs	r5, r1, #5
 80020fa:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80020fe:	f2ce 0300 	movt	r3, #57344	; 0xe000
#endif

	DCC_LOG1(LOG_MSG, "IRQ %d", irq);

	/* store the thread info */
	thinkos_rt.irq_th[irq] = self;
 8002102:	1852      	adds	r2, r2, r1
 8002104:	f105 0660 	add.w	r6, r5, #96	; 0x60
 8002108:	f001 011f 	and.w	r1, r1, #31
 800210c:	2701      	movs	r7, #1
 800210e:	fa07 f101 	lsl.w	r1, r7, r1
 8002112:	f882 4b9c 	strb.w	r4, [r2, #2972]	; 0xb9c
 8002116:	f843 1026 	str.w	r1, [r3, r6, lsl #2]
extern "C" {
#endif

/* Enable Interrupt in NVIC Interrupt Controller */
static inline void __attribute__((always_inline)) cm3_irq_enable(int irq) {
	CM3_NVIC->iser[irq >> 5] = (1 << (irq & 0x1f));
 800211a:	f843 1025 	str.w	r1, [r3, r5, lsl #2]

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 800211e:	4b0b      	ldr	r3, [pc, #44]	; (800214c <thinkos_irq_wait_svc+0x64>)
 8002120:	f44f 406d 	mov.w	r0, #60672	; 0xed00
 8002124:	015b      	lsls	r3, r3, #5
 8002126:	f2ce 0000 	movt	r0, #57344	; 0xe000
 800212a:	2200      	movs	r2, #0
 800212c:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8002130:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002134:	6043      	str	r3, [r0, #4]
 8002136:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int irq = arg[0];
	int32_t self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (irq >= THINKOS_IRQ_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid IRQ %d!", irq);
 8002138:	4805      	ldr	r0, [pc, #20]	; (8002150 <thinkos_irq_wait_svc+0x68>)
 800213a:	f002 f96b 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800213e:	f06f 0302 	mvn.w	r3, #2
 8002142:	602b      	str	r3, [r5, #0]
		return;
 8002144:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002146:	bf00      	nop
 8002148:	20000088 	.word	0x20000088
 800214c:	21100110 	.word	0x21100110
 8002150:	40000150 	.word	0x40000150

08002154 <thinkos_flag_alloc_svc>:
#if THINKOS_FLAG_MAX > 0

#if THINKOS_ENABLE_FLAG_ALLOC

void thinkos_flag_alloc_svc(int32_t * arg)
{
 8002154:	b570      	push	{r4, r5, r6, lr}
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.flag_alloc, 
 8002156:	2150      	movs	r1, #80	; 0x50
#if THINKOS_FLAG_MAX > 0

#if THINKOS_ENABLE_FLAG_ALLOC

void thinkos_flag_alloc_svc(int32_t * arg)
{
 8002158:	4604      	mov	r4, r0
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.flag_alloc, 
 800215a:	480d      	ldr	r0, [pc, #52]	; (8002190 <thinkos_flag_alloc_svc+0x3c>)
 800215c:	f7ff fe38 	bl	8001dd0 <thinkos_bmp_alloc>
 8002160:	1e03      	subs	r3, r0, #0
 8002162:	da01      	bge.n	8002168 <thinkos_flag_alloc_svc+0x14>
		__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);
#endif
		arg[0] = idx + THINKOS_FLAG_BASE;
		DCC_LOG1(LOG_TRACE, "wq=%d", arg[0]);
	} else {
		arg[0] = idx;
 8002164:	6023      	str	r3, [r4, #0]
 8002166:	bd70      	pop	{r4, r5, r6, pc}
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002168:	4a0a      	ldr	r2, [pc, #40]	; (8002194 <thinkos_flag_alloc_svc+0x40>)
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
#if THINKOS_ENABLE_FLAG_LOCK
		__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);
#endif
		arg[0] = idx + THINKOS_FLAG_BASE;
		DCC_LOG1(LOG_TRACE, "wq=%d", arg[0]);
 800216a:	480b      	ldr	r0, [pc, #44]	; (8002198 <thinkos_flag_alloc_svc+0x44>)
	bit_addr[bit] = val;
 800216c:	0151      	lsls	r1, r2, #5
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800216e:	f102 060c 	add.w	r6, r2, #12
	bit_addr[bit] = val;
 8002172:	2500      	movs	r5, #0
								 THINKOS_FLAG_MAX)) >= 0) {
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
#if THINKOS_ENABLE_FLAG_LOCK
		__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);
#endif
		arg[0] = idx + THINKOS_FLAG_BASE;
 8002174:	f503 72a1 	add.w	r2, r3, #322	; 0x142
 8002178:	0176      	lsls	r6, r6, #5
 800217a:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
		DCC_LOG1(LOG_TRACE, "wq=%d", arg[0]);
 800217e:	4611      	mov	r1, r2
 8002180:	f846 5023 	str.w	r5, [r6, r3, lsl #2]
								 THINKOS_FLAG_MAX)) >= 0) {
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
#if THINKOS_ENABLE_FLAG_LOCK
		__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);
#endif
		arg[0] = idx + THINKOS_FLAG_BASE;
 8002184:	6022      	str	r2, [r4, #0]
		DCC_LOG1(LOG_TRACE, "wq=%d", arg[0]);
	} else {
		arg[0] = idx;
	}
}
 8002186:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
#if THINKOS_ENABLE_FLAG_LOCK
		__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);
#endif
		arg[0] = idx + THINKOS_FLAG_BASE;
		DCC_LOG1(LOG_TRACE, "wq=%d", arg[0]);
 800218a:	f002 b943 	b.w	8004414 <ice_trace1>
 800218e:	bf00      	nop
 8002190:	20000ca8 	.word	0x20000ca8
 8002194:	21100bbc 	.word	0x21100bbc
 8002198:	40000160 	.word	0x40000160

0800219c <thinkos_flag_free_svc>:
	}
}

void thinkos_flag_free_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 800219c:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 800219e:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80021a2:	2b4f      	cmp	r3, #79	; 0x4f
		arg[0] = idx;
	}
}

void thinkos_flag_free_svc(int32_t * arg)
{
 80021a4:	b510      	push	{r4, lr}
 80021a6:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80021a8:	d805      	bhi.n	80021b6 <thinkos_flag_free_svc+0x1a>
 80021aa:	4a06      	ldr	r2, [pc, #24]	; (80021c4 <thinkos_flag_free_svc+0x28>)
 80021ac:	0152      	lsls	r2, r2, #5
 80021ae:	2100      	movs	r1, #0
 80021b0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 80021b4:	bd10      	pop	{r4, pc}
		DCC_LOG1(LOG_ERROR, "object %d is not a xdmon!", wq);
 80021b6:	4804      	ldr	r0, [pc, #16]	; (80021c8 <thinkos_flag_free_svc+0x2c>)
 80021b8:	f002 f92c 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80021bc:	f06f 0302 	mvn.w	r3, #2
 80021c0:	6023      	str	r3, [r4, #0]
		return;
 80021c2:	bd10      	pop	{r4, pc}
 80021c4:	21100ca8 	.word	0x21100ca8
 80021c8:	40000170 	.word	0x40000170

080021cc <thinkos_flag_wait_svc>:

#endif

void thinkos_flag_wait_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 80021cc:	6801      	ldr	r1, [r0, #0]
}

#endif

void thinkos_flag_wait_svc(int32_t * arg)
{
 80021ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	int self = thinkos_rt.active;
 80021d0:	4c24      	ldr	r4, [pc, #144]	; (8002264 <thinkos_flag_wait_svc+0x98>)
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 80021d2:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80021d6:	2b4f      	cmp	r3, #79	; 0x4f
}

#endif

void thinkos_flag_wait_svc(int32_t * arg)
{
 80021d8:	4605      	mov	r5, r0
	unsigned int wq = arg[0];
	int self = thinkos_rt.active;
 80021da:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80021de:	d82b      	bhi.n	8002238 <thinkos_flag_wait_svc+0x6c>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80021e0:	4821      	ldr	r0, [pc, #132]	; (8002268 <thinkos_flag_wait_svc+0x9c>)
	return bit_addr[bit];
 80021e2:	0140      	lsls	r0, r0, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 80021e4:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80021e8:	2800      	cmp	r0, #0
 80021ea:	d034      	beq.n	8002256 <thinkos_flag_wait_svc+0x8a>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80021ec:	b672      	cpsid	i
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80021ee:	481f      	ldr	r0, [pc, #124]	; (800226c <thinkos_flag_wait_svc+0xa0>)
 80021f0:	0140      	lsls	r0, r0, #5
#endif
#endif

	/* disable interrupts */
	cm3_cpsid_i();
	if (__bit_mem_rd(thinkos_rt.flag.sig, idx)) {
 80021f2:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]
 80021f6:	b126      	cbz	r6, 8002202 <thinkos_flag_wait_svc+0x36>
 80021f8:	4f1d      	ldr	r7, [pc, #116]	; (8002270 <thinkos_flag_wait_svc+0xa4>)
 80021fa:	017f      	lsls	r7, r7, #5
#if THINKOS_ENABLE_FLAG_LOCK
		if (!__bit_mem_rd(thinkos_rt.flag.lock, idx)) {
 80021fc:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
 8002200:	b30e      	cbz	r6, 8002246 <thinkos_flag_wait_svc+0x7a>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002202:	4b1c      	ldr	r3, [pc, #112]	; (8002274 <thinkos_flag_wait_svc+0xa8>)
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 8002204:	f101 0022 	add.w	r0, r1, #34	; 0x22
 8002208:	eb03 0080 	add.w	r0, r3, r0, lsl #2
	bit_addr[bit] = val;
 800220c:	0140      	lsls	r0, r0, #5
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800220e:	3388      	adds	r3, #136	; 0x88
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 8002210:	18a4      	adds	r4, r4, r2
 8002212:	0049      	lsls	r1, r1, #1
	bit_addr[bit] = val;
 8002214:	015b      	lsls	r3, r3, #5
 8002216:	2501      	movs	r5, #1
 8002218:	f840 5022 	str.w	r5, [r0, r2, lsl #2]
 800221c:	f884 16d0 	strb.w	r1, [r4, #1744]	; 0x6d0
 8002220:	2100      	movs	r1, #0
 8002222:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002226:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002228:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800222c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002230:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002234:	605a      	str	r2, [r3, #4]
 8002236:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int self = thinkos_rt.active;
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002238:	480f      	ldr	r0, [pc, #60]	; (8002278 <thinkos_flag_wait_svc+0xac>)
 800223a:	f002 f8eb 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800223e:	f06f 0302 	mvn.w	r3, #2
 8002242:	602b      	str	r3, [r5, #0]
		return;
 8002244:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002246:	2201      	movs	r2, #1
 8002248:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 800224c:	b662      	cpsie	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 800224e:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
			__bit_mem_wr(thinkos_rt.flag.lock, idx, 1);
#endif
			cm3_cpsie_i();
			/* clear the signal */
			__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
			arg[0] = 0;
 8002252:	602e      	str	r6, [r5, #0]
			return;
 8002254:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002256:	4809      	ldr	r0, [pc, #36]	; (800227c <thinkos_flag_wait_svc+0xb0>)
 8002258:	f002 f8dc 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800225c:	f06f 0302 	mvn.w	r3, #2
 8002260:	602b      	str	r3, [r5, #0]
		return;
 8002262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002264:	20000088 	.word	0x20000088
 8002268:	21100ca8 	.word	0x21100ca8
 800226c:	21100bbc 	.word	0x21100bbc
 8002270:	21100bc8 	.word	0x21100bc8
 8002274:	21100088 	.word	0x21100088
 8002278:	40000180 	.word	0x40000180
 800227c:	40000190 	.word	0x40000190

08002280 <thinkos_flag_timedwait_svc>:
	__thinkos_defer_sched(); /* signal the scheduler ... */
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_flag_timedwait_svc(int32_t * arg)
{
 8002280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002284:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
 8002286:	e894 0042 	ldmia.w	r4, {r1, r6}
	int self = thinkos_rt.active;
 800228a:	482f      	ldr	r0, [pc, #188]	; (8002348 <thinkos_flag_timedwait_svc+0xc8>)
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 800228c:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002290:	2b4f      	cmp	r3, #79	; 0x4f
#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_flag_timedwait_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	int self = thinkos_rt.active;
 8002292:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002296:	d83e      	bhi.n	8002316 <thinkos_flag_timedwait_svc+0x96>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002298:	4d2c      	ldr	r5, [pc, #176]	; (800234c <thinkos_flag_timedwait_svc+0xcc>)
	return bit_addr[bit];
 800229a:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 800229c:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
 80022a0:	2d00      	cmp	r5, #0
 80022a2:	d049      	beq.n	8002338 <thinkos_flag_timedwait_svc+0xb8>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80022a4:	b672      	cpsid	i
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80022a6:	4d2a      	ldr	r5, [pc, #168]	; (8002350 <thinkos_flag_timedwait_svc+0xd0>)
 80022a8:	016d      	lsls	r5, r5, #5
#endif
#endif

	/* disable interrupts */
	cm3_cpsid_i();
	if (__bit_mem_rd(thinkos_rt.flag.sig, idx)) {
 80022aa:	f855 7023 	ldr.w	r7, [r5, r3, lsl #2]
 80022ae:	b137      	cbz	r7, 80022be <thinkos_flag_timedwait_svc+0x3e>
 80022b0:	4f28      	ldr	r7, [pc, #160]	; (8002354 <thinkos_flag_timedwait_svc+0xd4>)
 80022b2:	ea4f 1c47 	mov.w	ip, r7, lsl #5
#if THINKOS_ENABLE_FLAG_LOCK
		if (!__bit_mem_rd(thinkos_rt.flag.lock, idx)) {
 80022b6:	f85c 7023 	ldr.w	r7, [ip, r3, lsl #2]
 80022ba:	2f00      	cmp	r7, #0
 80022bc:	d033      	beq.n	8002326 <thinkos_flag_timedwait_svc+0xa6>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80022be:	4b26      	ldr	r3, [pc, #152]	; (8002358 <thinkos_flag_timedwait_svc+0xd8>)
#endif
	}

	/* Set the default return value to timeout. The
	   flag_rise() call will change it to 0 */
	arg[0] = THINKOS_ETIMEDOUT;
 80022c0:	f04f 35ff 	mov.w	r5, #4294967295
 80022c4:	6025      	str	r5, [r4, #0]
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 80022c6:	f101 0722 	add.w	r7, r1, #34	; 0x22

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 80022ca:	f8d0 86f0 	ldr.w	r8, [r0, #1776]	; 0x6f0
 80022ce:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80022d2:	f103 058c 	add.w	r5, r3, #140	; 0x8c
	bit_addr[bit] = val;
 80022d6:	2401      	movs	r4, #1
 80022d8:	eb00 0c82 	add.w	ip, r0, r2, lsl #2
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80022dc:	3388      	adds	r3, #136	; 0x88
	bit_addr[bit] = val;
 80022de:	017f      	lsls	r7, r7, #5
 80022e0:	016d      	lsls	r5, r5, #5
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 80022e2:	1880      	adds	r0, r0, r2
 80022e4:	0049      	lsls	r1, r1, #1
 80022e6:	1909      	adds	r1, r1, r4
 80022e8:	015b      	lsls	r3, r3, #5

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 80022ea:	4446      	add	r6, r8
 80022ec:	f8cc 66f4 	str.w	r6, [ip, #1780]	; 0x6f4
 80022f0:	f847 4022 	str.w	r4, [r7, r2, lsl #2]
 80022f4:	f845 4022 	str.w	r4, [r5, r2, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 80022f8:	f880 16d0 	strb.w	r1, [r0, #1744]	; 0x6d0
 80022fc:	2100      	movs	r1, #0
 80022fe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002302:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002304:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002308:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800230c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002310:	605a      	str	r2, [r3, #4]
 8002312:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int self = thinkos_rt.active;
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002316:	4811      	ldr	r0, [pc, #68]	; (800235c <thinkos_flag_timedwait_svc+0xdc>)
 8002318:	f002 f87c 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800231c:	f06f 0302 	mvn.w	r3, #2
 8002320:	6023      	str	r3, [r4, #0]
		return;
 8002322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002326:	2201      	movs	r2, #1
 8002328:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 800232c:	b662      	cpsie	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 800232e:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
			__bit_mem_wr(thinkos_rt.flag.lock, idx, 1);
#endif
			cm3_cpsie_i();
			/* clear the signal */
			__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
			arg[0] = 0;
 8002332:	6027      	str	r7, [r4, #0]
			return;
 8002334:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002338:	4809      	ldr	r0, [pc, #36]	; (8002360 <thinkos_flag_timedwait_svc+0xe0>)
 800233a:	f002 f86b 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800233e:	f06f 0302 	mvn.w	r3, #2
 8002342:	6023      	str	r3, [r4, #0]
		return;
 8002344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002348:	20000088 	.word	0x20000088
 800234c:	21100ca8 	.word	0x21100ca8
 8002350:	21100bbc 	.word	0x21100bbc
 8002354:	21100bc8 	.word	0x21100bc8
 8002358:	21100088 	.word	0x21100088
 800235c:	400001a0 	.word	0x400001a0
 8002360:	400001b0 	.word	0x400001b0

08002364 <thinkos_flag_release_svc>:
#endif

#if THINKOS_ENABLE_FLAG_LOCK

void thinkos_flag_release_svc(int32_t * arg)
{
 8002364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	unsigned int wq = arg[0];
	unsigned int sig = arg[1];
 8002368:	e890 0022 	ldmia.w	r0, {r1, r5}
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 800236c:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002370:	2b4f      	cmp	r3, #79	; 0x4f
#endif

#if THINKOS_ENABLE_FLAG_LOCK

void thinkos_flag_release_svc(int32_t * arg)
{
 8002372:	4604      	mov	r4, r0
	unsigned int sig = arg[1];
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002374:	d84d      	bhi.n	8002412 <thinkos_flag_release_svc+0xae>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002376:	4a30      	ldr	r2, [pc, #192]	; (8002438 <thinkos_flag_release_svc+0xd4>)
	return bit_addr[bit];
 8002378:	0150      	lsls	r0, r2, #5
 800237a:	009f      	lsls	r7, r3, #2
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 800237c:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8002380:	2800      	cmp	r0, #0
 8002382:	d04e      	beq.n	8002422 <thinkos_flag_release_svc+0xbe>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002384:	f1a2 06e0 	sub.w	r6, r2, #224	; 0xe0
 8002388:	0176      	lsls	r6, r6, #5
 800238a:	3aec      	subs	r2, #236	; 0xec
		return;
	}
#endif
#endif

	arg[0] = 0;
 800238c:	2000      	movs	r0, #0
 800238e:	0152      	lsls	r2, r2, #5
 8002390:	6020      	str	r0, [r4, #0]
	bit_addr[bit] = val;
 8002392:	19d7      	adds	r7, r2, r7
 8002394:	f846 0023 	str.w	r0, [r6, r3, lsl #2]

	/* unlock the flag */
	__bit_mem_wr(thinkos_rt.flag.lock, idx, 0);

	if (sig) {
 8002398:	2d00      	cmp	r5, #0
 800239a:	d034      	beq.n	8002406 <thinkos_flag_release_svc+0xa2>
 800239c:	2001      	movs	r0, #1
 800239e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80023a2:	b672      	cpsid	i
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 80023a4:	4825      	ldr	r0, [pc, #148]	; (800243c <thinkos_flag_release_svc+0xd8>)
 80023a6:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80023a8:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
 80023ac:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80023b0:	fab2 f282 	clz	r2, r2
		return;

	/* disable interrupts */
	cm3_cpsid_i();

	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
 80023b4:	2a20      	cmp	r2, #32
 80023b6:	d03c      	beq.n	8002432 <thinkos_flag_release_svc+0xce>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80023b8:	f100 7488 	add.w	r4, r0, #17825792	; 0x1100000
	bit_addr[bit] = val;
 80023bc:	f8df 808c 	ldr.w	r8, [pc, #140]	; 800244c <thinkos_flag_release_svc+0xe8>
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80023c0:	f850 c022 	ldr.w	ip, [r0, r2, lsl #2]
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80023c4:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	bit_addr[bit] = val;
 80023c8:	0149      	lsls	r1, r1, #5
 80023ca:	ea4f 1848 	mov.w	r8, r8, lsl #5
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80023ce:	1885      	adds	r5, r0, r2
 80023d0:	2401      	movs	r4, #1
 80023d2:	2000      	movs	r0, #0
 80023d4:	f848 4022 	str.w	r4, [r8, r2, lsl #2]
 80023d8:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
 80023dc:	4918      	ldr	r1, [pc, #96]	; (8002440 <thinkos_flag_release_svc+0xdc>)
 80023de:	0149      	lsls	r1, r1, #5
 80023e0:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80023e4:	f8cc 0020 	str.w	r0, [ip, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80023e8:	f885 06d0 	strb.w	r0, [r5, #1744]	; 0x6d0
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 80023ec:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80023ee:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80023f2:	f2ce 0200 	movt	r2, #57344	; 0xe000

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 80023f6:	6038      	str	r0, [r7, #0]
 80023f8:	f846 4023 	str.w	r4, [r6, r3, lsl #2]
 80023fc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002400:	6053      	str	r3, [r2, #4]
 8002402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (sig) {
		/* signal the flag acoording to the call argument */
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 1);
	}

	if (!__bit_mem_rd(thinkos_rt.flag.sig, idx))
 8002406:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800240a:	2a00      	cmp	r2, #0
 800240c:	d1c9      	bne.n	80023a2 <thinkos_flag_release_svc+0x3e>
 800240e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002412:	480c      	ldr	r0, [pc, #48]	; (8002444 <thinkos_flag_release_svc+0xe0>)
 8002414:	f001 fffe 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002418:	f06f 0302 	mvn.w	r3, #2
 800241c:	6023      	str	r3, [r4, #0]
		return;
 800241e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002422:	4809      	ldr	r0, [pc, #36]	; (8002448 <thinkos_flag_release_svc+0xe4>)
 8002424:	f001 fff6 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002428:	f06f 0302 	mvn.w	r3, #2
 800242c:	6023      	str	r3, [r4, #0]
		return;
 800242e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002432:	b662      	cpsie	i
 8002434:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002438:	21100ca8 	.word	0x21100ca8
 800243c:	20000088 	.word	0x20000088
 8002440:	21100114 	.word	0x21100114
 8002444:	400001c0 	.word	0x400001c0
 8002448:	400001d0 	.word	0x400001d0
 800244c:	21100110 	.word	0x21100110

08002450 <thinkos_flag_take_svc>:
#endif /* THINKOS_FLAG_LOCK */


void thinkos_flag_take_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8002450:	6801      	ldr	r1, [r0, #0]
	int self = thinkos_rt.active;
 8002452:	4a22      	ldr	r2, [pc, #136]	; (80024dc <thinkos_flag_take_svc+0x8c>)
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 8002454:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002458:	2b4f      	cmp	r3, #79	; 0x4f

#endif /* THINKOS_FLAG_LOCK */


void thinkos_flag_take_svc(int32_t * arg)
{
 800245a:	b570      	push	{r4, r5, r6, lr}
 800245c:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	int self = thinkos_rt.active;
 800245e:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002462:	d82c      	bhi.n	80024be <thinkos_flag_take_svc+0x6e>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002464:	4d1e      	ldr	r5, [pc, #120]	; (80024e0 <thinkos_flag_take_svc+0x90>)
	return bit_addr[bit];
 8002466:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 8002468:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
 800246c:	2d00      	cmp	r5, #0
 800246e:	d02d      	beq.n	80024cc <thinkos_flag_take_svc+0x7c>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8002470:	b672      	cpsid	i
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002472:	4e1c      	ldr	r6, [pc, #112]	; (80024e4 <thinkos_flag_take_svc+0x94>)
 8002474:	0176      	lsls	r6, r6, #5
#endif

	/* disable interrupts */
	cm3_cpsid_i();

	if (__bit_mem_rd(thinkos_rt.flag.sig, idx)) {
 8002476:	f856 5023 	ldr.w	r5, [r6, r3, lsl #2]
 800247a:	b9d5      	cbnz	r5, 80024b2 <thinkos_flag_take_svc+0x62>
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 800247c:	f101 0422 	add.w	r4, r1, #34	; 0x22
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002480:	f102 7388 	add.w	r3, r2, #17825792	; 0x1100000
 8002484:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	bit_addr[bit] = val;
 8002488:	015b      	lsls	r3, r3, #5
 800248a:	2401      	movs	r4, #1
 800248c:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
 8002490:	4b15      	ldr	r3, [pc, #84]	; (80024e8 <thinkos_flag_take_svc+0x98>)
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 8002492:	1812      	adds	r2, r2, r0
 8002494:	015b      	lsls	r3, r3, #5
 8002496:	0049      	lsls	r1, r1, #1
 8002498:	f882 16d0 	strb.w	r1, [r2, #1744]	; 0x6d0
 800249c:	f843 5020 	str.w	r5, [r3, r0, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 80024a0:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80024a2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80024a6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80024aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80024ae:	605a      	str	r2, [r3, #4]
 80024b0:	bd70      	pop	{r4, r5, r6, pc}
 80024b2:	b662      	cpsie	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 80024b4:	2200      	movs	r2, #0
 80024b6:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
		cm3_cpsie_i();
		/* clear the signal */
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
		arg[0] = 0;
 80024ba:	6022      	str	r2, [r4, #0]
		return;
 80024bc:	bd70      	pop	{r4, r5, r6, pc}
	int self = thinkos_rt.active;
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 80024be:	480b      	ldr	r0, [pc, #44]	; (80024ec <thinkos_flag_take_svc+0x9c>)
 80024c0:	f001 ffa8 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80024c4:	f06f 0302 	mvn.w	r3, #2
 80024c8:	6023      	str	r3, [r4, #0]
		return;
 80024ca:	bd70      	pop	{r4, r5, r6, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 80024cc:	4808      	ldr	r0, [pc, #32]	; (80024f0 <thinkos_flag_take_svc+0xa0>)
 80024ce:	f001 ffa1 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80024d2:	f06f 0302 	mvn.w	r3, #2
 80024d6:	6023      	str	r3, [r4, #0]
		return;
 80024d8:	bd70      	pop	{r4, r5, r6, pc}
 80024da:	bf00      	nop
 80024dc:	20000088 	.word	0x20000088
 80024e0:	21100ca8 	.word	0x21100ca8
 80024e4:	21100bbc 	.word	0x21100bbc
 80024e8:	21100110 	.word	0x21100110
 80024ec:	400001e0 	.word	0x400001e0
 80024f0:	400001f0 	.word	0x400001f0

080024f4 <thinkos_flag_timedtake_svc>:
	__thinkos_defer_sched(); /* signal the scheduler ... */
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_flag_timedtake_svc(int32_t * arg)
{
 80024f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
 80024f6:	e890 0082 	ldmia.w	r0, {r1, r7}
	int self = thinkos_rt.active;
 80024fa:	4a29      	ldr	r2, [pc, #164]	; (80025a0 <thinkos_flag_timedtake_svc+0xac>)
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 80024fc:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002500:	2b4f      	cmp	r3, #79	; 0x4f
	__thinkos_defer_sched(); /* signal the scheduler ... */
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_flag_timedtake_svc(int32_t * arg)
{
 8002502:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	int self = thinkos_rt.active;
 8002504:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002508:	d83b      	bhi.n	8002582 <thinkos_flag_timedtake_svc+0x8e>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800250a:	4d26      	ldr	r5, [pc, #152]	; (80025a4 <thinkos_flag_timedtake_svc+0xb0>)
	return bit_addr[bit];
 800250c:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 800250e:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
 8002512:	2d00      	cmp	r5, #0
 8002514:	d03c      	beq.n	8002590 <thinkos_flag_timedtake_svc+0x9c>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8002516:	b672      	cpsid	i
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002518:	4e23      	ldr	r6, [pc, #140]	; (80025a8 <thinkos_flag_timedtake_svc+0xb4>)
 800251a:	0176      	lsls	r6, r6, #5
#endif
#endif

	/* disable interrupts */
	cm3_cpsid_i();
	if (__bit_mem_rd(thinkos_rt.flag.sig, idx)) {
 800251c:	f856 5023 	ldr.w	r5, [r6, r3, lsl #2]
 8002520:	bb4d      	cbnz	r5, 8002576 <thinkos_flag_timedtake_svc+0x82>
		return;
	} 

	/* Set the default return value to timeout. The
	   flag_rise() call will change it to 0 */
	arg[0] = THINKOS_ETIMEDOUT;
 8002522:	f04f 33ff 	mov.w	r3, #4294967295
 8002526:	6023      	str	r3, [r4, #0]
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002528:	f102 7388 	add.w	r3, r2, #17825792	; 0x1100000
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 800252c:	f101 0422 	add.w	r4, r1, #34	; 0x22

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 8002530:	f8d2 c6f0 	ldr.w	ip, [r2, #1776]	; 0x6f0
 8002534:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8002538:	eb02 0680 	add.w	r6, r2, r0, lsl #2
	bit_addr[bit] = val;
 800253c:	0164      	lsls	r4, r4, #5
 800253e:	2301      	movs	r3, #1
 8002540:	4467      	add	r7, ip
 8002542:	f8c6 76f4 	str.w	r7, [r6, #1780]	; 0x6f4
 8002546:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
 800254a:	4c18      	ldr	r4, [pc, #96]	; (80025ac <thinkos_flag_timedtake_svc+0xb8>)
 800254c:	0164      	lsls	r4, r4, #5
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 800254e:	0049      	lsls	r1, r1, #1
 8002550:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
 8002554:	18c9      	adds	r1, r1, r3
 8002556:	4b16      	ldr	r3, [pc, #88]	; (80025b0 <thinkos_flag_timedtake_svc+0xbc>)
 8002558:	1812      	adds	r2, r2, r0
 800255a:	015b      	lsls	r3, r3, #5
 800255c:	f882 16d0 	strb.w	r1, [r2, #1744]	; 0x6d0
 8002560:	f843 5020 	str.w	r5, [r3, r0, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002564:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002566:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800256a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800256e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002572:	605a      	str	r2, [r3, #4]
 8002574:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002576:	b662      	cpsie	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002578:	2200      	movs	r2, #0
 800257a:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
	cm3_cpsid_i();
	if (__bit_mem_rd(thinkos_rt.flag.sig, idx)) {
		cm3_cpsie_i();
		/* clear the signal */
		__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);
		arg[0] = 0;
 800257e:	6022      	str	r2, [r4, #0]
		return;
 8002580:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int self = thinkos_rt.active;
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002582:	480c      	ldr	r0, [pc, #48]	; (80025b4 <thinkos_flag_timedtake_svc+0xc0>)
 8002584:	f001 ff46 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002588:	f06f 0302 	mvn.w	r3, #2
 800258c:	6023      	str	r3, [r4, #0]
		return;
 800258e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002590:	4809      	ldr	r0, [pc, #36]	; (80025b8 <thinkos_flag_timedtake_svc+0xc4>)
 8002592:	f001 ff3f 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002596:	f06f 0302 	mvn.w	r3, #2
 800259a:	6023      	str	r3, [r4, #0]
		return;
 800259c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800259e:	bf00      	nop
 80025a0:	20000088 	.word	0x20000088
 80025a4:	21100ca8 	.word	0x21100ca8
 80025a8:	21100bbc 	.word	0x21100bbc
 80025ac:	21100114 	.word	0x21100114
 80025b0:	21100110 	.word	0x21100110
 80025b4:	40000200 	.word	0x40000200
 80025b8:	40000210 	.word	0x40000210

080025bc <thinkos_flag_give_svc>:
}
#endif

void thinkos_flag_give_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 80025bc:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 80025be:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80025c2:	2b4f      	cmp	r3, #79	; 0x4f
	__thinkos_defer_sched(); /* signal the scheduler ... */
}
#endif

void thinkos_flag_give_svc(int32_t * arg)
{
 80025c4:	b570      	push	{r4, r5, r6, lr}
 80025c6:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80025c8:	d835      	bhi.n	8002636 <thinkos_flag_give_svc+0x7a>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80025ca:	4a24      	ldr	r2, [pc, #144]	; (800265c <thinkos_flag_give_svc+0xa0>)
	return bit_addr[bit];
 80025cc:	0150      	lsls	r0, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 80025ce:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80025d2:	2800      	cmp	r0, #0
 80025d4:	d036      	beq.n	8002644 <thinkos_flag_give_svc+0x88>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80025d6:	3aec      	subs	r2, #236	; 0xec
 80025d8:	0155      	lsls	r5, r2, #5
	}
#endif
#endif

	/* get the flag state */
	if ((arg[0] = __bit_mem_rd(&thinkos_rt.flag.sig, idx)) != 0) {
 80025da:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 80025de:	6022      	str	r2, [r4, #0]
 80025e0:	bb42      	cbnz	r2, 8002634 <thinkos_flag_give_svc+0x78>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80025e2:	b672      	cpsid	i
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 80025e4:	4c1e      	ldr	r4, [pc, #120]	; (8002660 <thinkos_flag_give_svc+0xa4>)
 80025e6:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80025e8:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
 80025ec:	fa90 f0a0 	rbit	r0, r0
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80025f0:	fab0 f080 	clz	r0, r0
	}

	/* disable interrupts */
	cm3_cpsid_i();

	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
 80025f4:	2820      	cmp	r0, #32
 80025f6:	d02c      	beq.n	8002652 <thinkos_flag_give_svc+0x96>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80025f8:	f104 7588 	add.w	r5, r4, #17825792	; 0x1100000
 80025fc:	eb05 0181 	add.w	r1, r5, r1, lsl #2
	bit_addr[bit] = val;
 8002600:	3588      	adds	r5, #136	; 0x88
 8002602:	0149      	lsls	r1, r1, #5
 8002604:	016d      	lsls	r5, r5, #5
 8002606:	2601      	movs	r6, #1
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8002608:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 800260c:	f845 6020 	str.w	r6, [r5, r0, lsl #2]
 8002610:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
 8002614:	4913      	ldr	r1, [pc, #76]	; (8002664 <thinkos_flag_give_svc+0xa8>)
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002616:	1824      	adds	r4, r4, r0
 8002618:	0149      	lsls	r1, r1, #5
 800261a:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800261e:	621a      	str	r2, [r3, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002620:	f884 26d0 	strb.w	r2, [r4, #1744]	; 0x6d0
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002624:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002626:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800262a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800262e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002632:	605a      	str	r2, [r3, #4]
 8002634:	bd70      	pop	{r4, r5, r6, pc}
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002636:	480c      	ldr	r0, [pc, #48]	; (8002668 <thinkos_flag_give_svc+0xac>)
 8002638:	f001 feec 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800263c:	f06f 0302 	mvn.w	r3, #2
 8002640:	6023      	str	r3, [r4, #0]
		return;
 8002642:	bd70      	pop	{r4, r5, r6, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002644:	4809      	ldr	r0, [pc, #36]	; (800266c <thinkos_flag_give_svc+0xb0>)
 8002646:	f001 fee5 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800264a:	f06f 0302 	mvn.w	r3, #2
 800264e:	6023      	str	r3, [r4, #0]
		return;
 8002650:	bd70      	pop	{r4, r5, r6, pc}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002652:	2201      	movs	r2, #1
 8002654:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002658:	b662      	cpsie	i
 800265a:	bd70      	pop	{r4, r5, r6, pc}
 800265c:	21100ca8 	.word	0x21100ca8
 8002660:	20000088 	.word	0x20000088
 8002664:	21100114 	.word	0x21100114
 8002668:	40000220 	.word	0x40000220
 800266c:	40000230 	.word	0x40000230

08002670 <thinkos_flag_clr_svc>:
	__thinkos_defer_sched();
}

void thinkos_flag_clr_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8002670:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 8002672:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 8002676:	2b4f      	cmp	r3, #79	; 0x4f
	/* signal the scheduler ... */
	__thinkos_defer_sched();
}

void thinkos_flag_clr_svc(int32_t * arg)
{
 8002678:	b510      	push	{r4, lr}
 800267a:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 800267c:	d80d      	bhi.n	800269a <thinkos_flag_clr_svc+0x2a>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800267e:	4a0e      	ldr	r2, [pc, #56]	; (80026b8 <thinkos_flag_clr_svc+0x48>)
	return bit_addr[bit];
 8002680:	0150      	lsls	r0, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 8002682:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8002686:	b178      	cbz	r0, 80026a8 <thinkos_flag_clr_svc+0x38>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002688:	3aec      	subs	r2, #236	; 0xec
 800268a:	0152      	lsls	r2, r2, #5
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif
#endif
	arg[0] = __bit_mem_rd(thinkos_rt.flag.sig, idx);
 800268c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8002690:	6021      	str	r1, [r4, #0]

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002692:	2100      	movs	r1, #0
 8002694:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8002698:	bd10      	pop	{r4, pc}
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_FLAG_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 800269a:	4808      	ldr	r0, [pc, #32]	; (80026bc <thinkos_flag_clr_svc+0x4c>)
 800269c:	f001 feba 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80026a0:	f06f 0302 	mvn.w	r3, #2
 80026a4:	6023      	str	r3, [r4, #0]
		return;
 80026a6:	bd10      	pop	{r4, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 80026a8:	4805      	ldr	r0, [pc, #20]	; (80026c0 <thinkos_flag_clr_svc+0x50>)
 80026aa:	f001 feb3 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80026ae:	f06f 0302 	mvn.w	r3, #2
 80026b2:	6023      	str	r3, [r4, #0]
		return;
 80026b4:	bd10      	pop	{r4, pc}
 80026b6:	bf00      	nop
 80026b8:	21100ca8 	.word	0x21100ca8
 80026bc:	40000240 	.word	0x40000240
 80026c0:	40000250 	.word	0x40000250

080026c4 <thinkos_flag_set_svc>:
	__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);  
}

void thinkos_flag_set_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 80026c4:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_FLAG_BASE;
 80026c6:	f5a1 73a1 	sub.w	r3, r1, #322	; 0x142
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80026ca:	2b4f      	cmp	r3, #79	; 0x4f
	/* clear the flag signal bit */
	__bit_mem_wr(thinkos_rt.flag.sig, idx, 0);  
}

void thinkos_flag_set_svc(int32_t * arg)
{
 80026cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80026d0:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
 80026d2:	d858      	bhi.n	8002786 <thinkos_flag_set_svc+0xc2>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80026d4:	4a34      	ldr	r2, [pc, #208]	; (80027a8 <thinkos_flag_set_svc+0xe4>)
	return bit_addr[bit];
 80026d6:	0150      	lsls	r0, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
 80026d8:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80026dc:	2800      	cmp	r0, #0
 80026de:	d05a      	beq.n	8002796 <thinkos_flag_set_svc+0xd2>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80026e0:	3aec      	subs	r2, #236	; 0xec
 80026e2:	0152      	lsls	r2, r2, #5
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif
#endif
	arg[0] = __bit_mem_rd(thinkos_rt.flag.sig, idx);
 80026e4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 80026e8:	6020      	str	r0, [r4, #0]
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80026ea:	b672      	cpsid	i

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 80026ec:	2401      	movs	r4, #1
 80026ee:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 80026f2:	482e      	ldr	r0, [pc, #184]	; (80027ac <thinkos_flag_set_svc+0xe8>)
 80026f4:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80026f6:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 80026fa:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80026fe:	fab3 f383 	clz	r3, r3
	/* disable interrupts */
	cm3_cpsid_i();
	/* set the flag bit */
	__bit_mem_wr(thinkos_rt.flag.sig, idx, 1);  
	/* get a thread from the queue */
	if ((th = __thinkos_wq_head(wq)) != THINKOS_THREAD_NULL) {
 8002702:	2b20      	cmp	r3, #32
 8002704:	d03c      	beq.n	8002780 <thinkos_flag_set_svc+0xbc>
static void inline __attribute__((always_inline)) 
__thinkos_wakeup(unsigned int wq, unsigned int th) {
	/* insert the thread into ready queue */
	__bit_mem_wr(&thinkos_rt.wq_ready, th, 1);
	/* remove from the wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
 8002706:	eb00 0781 	add.w	r7, r0, r1, lsl #2
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800270a:	4a29      	ldr	r2, [pc, #164]	; (80027b0 <thinkos_flag_set_svc+0xec>)
 800270c:	4e29      	ldr	r6, [pc, #164]	; (80027b4 <thinkos_flag_set_svc+0xf0>)
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800270e:	f850 8023 	ldr.w	r8, [r0, r3, lsl #2]
 8002712:	f107 7788 	add.w	r7, r7, #17825792	; 0x1100000
 8002716:	ea4f 1c42 	mov.w	ip, r2, lsl #5
 800271a:	0176      	lsls	r6, r6, #5
 800271c:	017f      	lsls	r7, r7, #5
	bit_addr[bit] = val;
 800271e:	2200      	movs	r2, #0
 8002720:	f846 4023 	str.w	r4, [r6, r3, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002724:	18c5      	adds	r5, r0, r3
 8002726:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
 800272a:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800272e:	f8c8 2020 	str.w	r2, [r8, #32]
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8002732:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002736:	f885 26d0 	strb.w	r2, [r5, #1744]	; 0x6d0
 800273a:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 800273e:	fab3 f383 	clz	r3, r3
		__thinkos_wakeup(wq, th);
		DCC_LOG2(LOG_MSG, "<%d> waked up with flag %d", th, wq);
		while ((th = __thinkos_wq_head(wq)) != THINKOS_THREAD_NULL) {
 8002742:	2b20      	cmp	r3, #32

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002744:	bf18      	it	ne
 8002746:	46a0      	movne	r8, r4
 8002748:	d013      	beq.n	8002772 <thinkos_flag_set_svc+0xae>
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800274a:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
 800274e:	f846 8023 	str.w	r8, [r6, r3, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002752:	18c4      	adds	r4, r0, r3
 8002754:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
 8002758:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800275c:	622a      	str	r2, [r5, #32]
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 800275e:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8002762:	f884 26d0 	strb.w	r2, [r4, #1744]	; 0x6d0
 8002766:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 800276a:	fab3 f383 	clz	r3, r3
 800276e:	2b20      	cmp	r3, #32
 8002770:	d1eb      	bne.n	800274a <thinkos_flag_set_svc+0x86>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002772:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002776:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800277a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800277e:	605a      	str	r2, [r3, #4]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8002780:	b662      	cpsie	i
 8002782:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	unsigned int idx = wq - THINKOS_FLAG_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_FLAG_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a flag!", wq);
 8002786:	480c      	ldr	r0, [pc, #48]	; (80027b8 <thinkos_flag_set_svc+0xf4>)
 8002788:	f001 fe44 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800278c:	f06f 0302 	mvn.w	r3, #2
 8002790:	6023      	str	r3, [r4, #0]
		return;
 8002792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
#if THINKOS_ENABLE_FLAG_ALLOC
	if (__bit_mem_rd(thinkos_rt.flag_alloc, idx) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid flag %d!", wq);
 8002796:	4809      	ldr	r0, [pc, #36]	; (80027bc <thinkos_flag_set_svc+0xf8>)
 8002798:	f001 fe3c 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800279c:	f06f 0302 	mvn.w	r3, #2
 80027a0:	6023      	str	r3, [r4, #0]
		return;
 80027a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80027a6:	bf00      	nop
 80027a8:	21100ca8 	.word	0x21100ca8
 80027ac:	20000088 	.word	0x20000088
 80027b0:	21100114 	.word	0x21100114
 80027b4:	21100110 	.word	0x21100110
 80027b8:	40000260 	.word	0x40000260
 80027bc:	40000270 	.word	0x40000270

080027c0 <hard_fault>:
void __attribute__((noreturn)) 
	thinkos_exception_dsr(struct thinkos_context * ctx);

void hard_fault(struct thinkos_context * ctx, uint32_t msp, 
				uint32_t psp, uint32_t lr)
{
 80027c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	hfsr = scb->hfsr;
 80027c4:	f44f 456d 	mov.w	r5, #60672	; 0xed00
 80027c8:	f2ce 0500 	movt	r5, #57344	; 0xe000
void __attribute__((noreturn)) 
	thinkos_exception_dsr(struct thinkos_context * ctx);

void hard_fault(struct thinkos_context * ctx, uint32_t msp, 
				uint32_t psp, uint32_t lr)
{
 80027cc:	b087      	sub	sp, #28
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	hfsr = scb->hfsr;
 80027ce:	6aef      	ldr	r7, [r5, #44]	; 0x2c

	DCC_LOG3(LOG_ERROR, "Hard fault:%s%s%s", 
 80027d0:	4e5a      	ldr	r6, [pc, #360]	; (800293c <hard_fault+0x17c>)
	uint32_t hfsr;
	uint32_t sp;
	(void)sp;

	if (lr & (1 << 4))
		sp = psp;
 80027d2:	f013 0f10 	tst.w	r3, #16
 80027d6:	bf0c      	ite	eq
 80027d8:	468b      	moveq	fp, r1
 80027da:	4693      	movne	fp, r2
void __attribute__((noreturn)) 
	thinkos_exception_dsr(struct thinkos_context * ctx);

void hard_fault(struct thinkos_context * ctx, uint32_t msp, 
				uint32_t psp, uint32_t lr)
{
 80027dc:	469a      	mov	sl, r3
 80027de:	4690      	mov	r8, r2
	else
		sp = msp;

	hfsr = scb->hfsr;

	DCC_LOG3(LOG_ERROR, "Hard fault:%s%s%s", 
 80027e0:	f017 4380 	ands.w	r3, r7, #1073741824	; 0x40000000
 80027e4:	4a56      	ldr	r2, [pc, #344]	; (8002940 <hard_fault+0x180>)
 80027e6:	9305      	str	r3, [sp, #20]
void __attribute__((noreturn)) 
	thinkos_exception_dsr(struct thinkos_context * ctx);

void hard_fault(struct thinkos_context * ctx, uint32_t msp, 
				uint32_t psp, uint32_t lr)
{
 80027e8:	4689      	mov	r9, r1
	else
		sp = msp;

	hfsr = scb->hfsr;

	DCC_LOG3(LOG_ERROR, "Hard fault:%s%s%s", 
 80027ea:	4b56      	ldr	r3, [pc, #344]	; (8002944 <hard_fault+0x184>)
 80027ec:	4956      	ldr	r1, [pc, #344]	; (8002948 <hard_fault+0x188>)
 80027ee:	bf08      	it	eq
 80027f0:	4632      	moveq	r2, r6
 80027f2:	f017 0f02 	tst.w	r7, #2
 80027f6:	bf08      	it	eq
 80027f8:	4633      	moveq	r3, r6
void __attribute__((noreturn)) 
	thinkos_exception_dsr(struct thinkos_context * ctx);

void hard_fault(struct thinkos_context * ctx, uint32_t msp, 
				uint32_t psp, uint32_t lr)
{
 80027fa:	4604      	mov	r4, r0
	else
		sp = msp;

	hfsr = scb->hfsr;

	DCC_LOG3(LOG_ERROR, "Hard fault:%s%s%s", 
 80027fc:	ea11 0127 	ands.w	r1, r1, r7, asr #32
 8002800:	bf38      	it	cc
 8002802:	4631      	movcc	r1, r6
 8002804:	4851      	ldr	r0, [pc, #324]	; (800294c <hard_fault+0x18c>)
 8002806:	f001 fe67 	bl	80044d8 <ice_trace3>
			 (hfsr & SCB_HFSR_DEBUGEVT) ? " DEBUGEVT" : "",
			 (hfsr & SCB_HFSR_FORCED) ?  " FORCED" : "",
			 (hfsr & SCB_HFSR_VECTTBL) ? " VECTTBL" : "");

	DCC_LOG4(LOG_ERROR, "  R0=%08x  R1=%08x  R2=%08x  R3=%08x", 
 800280a:	f104 0120 	add.w	r1, r4, #32
 800280e:	c98e      	ldmia	r1, {r1, r2, r3, r7}
 8002810:	484f      	ldr	r0, [pc, #316]	; (8002950 <hard_fault+0x190>)
 8002812:	9700      	str	r7, [sp, #0]
 8002814:	f001 fe9e 	bl	8004554 <ice_trace4>
			ctx->r0, ctx->r1, ctx->r2, ctx->r3);
	DCC_LOG4(LOG_ERROR, "  R4=%08x  R5=%08x  R6=%08x  R7=%08x", 
 8002818:	e894 008e 	ldmia.w	r4, {r1, r2, r3, r7}
 800281c:	484d      	ldr	r0, [pc, #308]	; (8002954 <hard_fault+0x194>)
 800281e:	9700      	str	r7, [sp, #0]
 8002820:	f001 fe98 	bl	8004554 <ice_trace4>
			ctx->r4, ctx->r5, ctx->r6, ctx->r7);
	DCC_LOG4(LOG_ERROR, "  R8=%08x  R9=%08x R10=%08x R11=%08x", 
 8002824:	f104 0110 	add.w	r1, r4, #16
 8002828:	c98e      	ldmia	r1, {r1, r2, r3, r7}
 800282a:	484b      	ldr	r0, [pc, #300]	; (8002958 <hard_fault+0x198>)
 800282c:	9700      	str	r7, [sp, #0]
 800282e:	f001 fe91 	bl	8004554 <ice_trace4>
			ctx->r8, ctx->r9, ctx->r10, ctx->r11);
	DCC_LOG4(LOG_ERROR, " R12=%08x  SP=%08x  LR=%08x  PC=%08x", 
 8002832:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002834:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002836:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002838:	4848      	ldr	r0, [pc, #288]	; (800295c <hard_fault+0x19c>)
 800283a:	9200      	str	r2, [sp, #0]
 800283c:	465a      	mov	r2, fp
 800283e:	f001 fe89 	bl	8004554 <ice_trace4>
			ctx->r12, sp, ctx->lr, ctx->pc);
	DCC_LOG4(LOG_ERROR, "XPSR=%08x MSP=%08x PSP=%08x RET=%08x", 
 8002842:	4643      	mov	r3, r8
 8002844:	464a      	mov	r2, r9
 8002846:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002848:	4845      	ldr	r0, [pc, #276]	; (8002960 <hard_fault+0x1a0>)
 800284a:	f8cd a000 	str.w	sl, [sp]
 800284e:	f001 fe81 	bl	8004554 <ice_trace4>
			ctx->xpsr, msp, psp, lr);

	DCC_LOG1(LOG_ERROR, "HFSR=%08x", scb->hfsr);
 8002852:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8002854:	4843      	ldr	r0, [pc, #268]	; (8002964 <hard_fault+0x1a4>)
 8002856:	f001 fddd 	bl	8004414 <ice_trace1>
	DCC_LOG1(LOG_ERROR, "CFSR=%08x", scb->cfsr);
 800285a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800285c:	4842      	ldr	r0, [pc, #264]	; (8002968 <hard_fault+0x1a8>)
 800285e:	f001 fdd9 	bl	8004414 <ice_trace1>
	DCC_LOG1(LOG_ERROR, "BFAR=%08x", scb->bfar);
 8002862:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8002864:	4841      	ldr	r0, [pc, #260]	; (800296c <hard_fault+0x1ac>)
 8002866:	f001 fdd5 	bl	8004414 <ice_trace1>

	if (hfsr & SCB_HFSR_FORCED) {
 800286a:	9b05      	ldr	r3, [sp, #20]
 800286c:	b913      	cbnz	r3, 8002874 <hard_fault+0xb4>

	thinkos_context_show(ctx, sp, msp, psp);
	fprintf(stderr, "\n");
	fflush(stderr);
#endif
}
 800286e:	b007      	add	sp, #28
 8002870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (hfsr & SCB_HFSR_FORCED) {
		uint32_t bfsr;
		uint32_t ufsr;

		bfsr = SCB_CFSR_BFSR_GET(scb->cfsr);
 8002874:	6aab      	ldr	r3, [r5, #40]	; 0x28
		ufsr = SCB_CFSR_UFSR_GET(scb->cfsr);
 8002876:	6aac      	ldr	r4, [r5, #40]	; 0x28
		(void)bfsr;
		(void)ufsr;

		DCC_LOG1(LOG_ERROR, "BFSR=%08X", bfsr);
 8002878:	483d      	ldr	r0, [pc, #244]	; (8002970 <hard_fault+0x1b0>)

	if (hfsr & SCB_HFSR_FORCED) {
		uint32_t bfsr;
		uint32_t ufsr;

		bfsr = SCB_CFSR_BFSR_GET(scb->cfsr);
 800287a:	0a1d      	lsrs	r5, r3, #8
 800287c:	b2ef      	uxtb	r7, r5
		ufsr = SCB_CFSR_UFSR_GET(scb->cfsr);
		(void)bfsr;
		(void)ufsr;

		DCC_LOG1(LOG_ERROR, "BFSR=%08X", bfsr);
 800287e:	4639      	mov	r1, r7
	if (hfsr & SCB_HFSR_FORCED) {
		uint32_t bfsr;
		uint32_t ufsr;

		bfsr = SCB_CFSR_BFSR_GET(scb->cfsr);
		ufsr = SCB_CFSR_UFSR_GET(scb->cfsr);
 8002880:	0c24      	lsrs	r4, r4, #16
		(void)bfsr;
		(void)ufsr;

		DCC_LOG1(LOG_ERROR, "BFSR=%08X", bfsr);
 8002882:	f001 fdc7 	bl	8004414 <ice_trace1>
		if (bfsr) {
 8002886:	2f00      	cmp	r7, #0
 8002888:	d12b      	bne.n	80028e2 <hard_fault+0x122>
					 (bfsr & BFSR_IMPRECISERR) ?  " IMPRECISERR" : "",
					 (bfsr & BFSR_PRECISERR) ?  " PRECISERR" : "",
					 (bfsr & BFSR_IBUSERR)  ?  " IBUSERR" : "");
		}

		DCC_LOG1(LOG_ERROR, "UFSR=%08X", ufsr);
 800288a:	483a      	ldr	r0, [pc, #232]	; (8002974 <hard_fault+0x1b4>)
 800288c:	4621      	mov	r1, r4
 800288e:	f001 fdc1 	bl	8004414 <ice_trace1>
		if (ufsr) {
 8002892:	2c00      	cmp	r4, #0
 8002894:	d0eb      	beq.n	800286e <hard_fault+0xae>
			DCC_LOG6(LOG_ERROR, "    %s%s%s%s%s%s", 
 8002896:	4d29      	ldr	r5, [pc, #164]	; (800293c <hard_fault+0x17c>)
 8002898:	4937      	ldr	r1, [pc, #220]	; (8002978 <hard_fault+0x1b8>)
 800289a:	4a38      	ldr	r2, [pc, #224]	; (800297c <hard_fault+0x1bc>)
 800289c:	4b38      	ldr	r3, [pc, #224]	; (8002980 <hard_fault+0x1c0>)
 800289e:	4f39      	ldr	r7, [pc, #228]	; (8002984 <hard_fault+0x1c4>)
 80028a0:	4e39      	ldr	r6, [pc, #228]	; (8002988 <hard_fault+0x1c8>)
 80028a2:	483a      	ldr	r0, [pc, #232]	; (800298c <hard_fault+0x1cc>)
 80028a4:	f414 7f00 	tst.w	r4, #512	; 0x200
 80028a8:	bf08      	it	eq
 80028aa:	4629      	moveq	r1, r5
 80028ac:	f414 7f80 	tst.w	r4, #256	; 0x100
 80028b0:	bf08      	it	eq
 80028b2:	462a      	moveq	r2, r5
 80028b4:	f014 0f08 	tst.w	r4, #8
 80028b8:	bf08      	it	eq
 80028ba:	462b      	moveq	r3, r5
 80028bc:	f014 0f04 	tst.w	r4, #4
 80028c0:	bf08      	it	eq
 80028c2:	462f      	moveq	r7, r5
 80028c4:	f014 0f02 	tst.w	r4, #2
 80028c8:	bf08      	it	eq
 80028ca:	462e      	moveq	r6, r5
 80028cc:	f014 0f01 	tst.w	r4, #1
 80028d0:	4c2f      	ldr	r4, [pc, #188]	; (8002990 <hard_fault+0x1d0>)
 80028d2:	9700      	str	r7, [sp, #0]
 80028d4:	bf18      	it	ne
 80028d6:	4625      	movne	r5, r4
 80028d8:	9601      	str	r6, [sp, #4]
 80028da:	9502      	str	r5, [sp, #8]
 80028dc:	f001 fe82 	bl	80045e4 <ice_trace6>
 80028e0:	e7c5      	b.n	800286e <hard_fault+0xae>
		(void)bfsr;
		(void)ufsr;

		DCC_LOG1(LOG_ERROR, "BFSR=%08X", bfsr);
		if (bfsr) {
			DCC_LOG7(LOG_ERROR, "    %s%s%s%s%s%s%s", 
 80028e2:	492c      	ldr	r1, [pc, #176]	; (8002994 <hard_fault+0x1d4>)
 80028e4:	4a2c      	ldr	r2, [pc, #176]	; (8002998 <hard_fault+0x1d8>)
 80028e6:	4b2d      	ldr	r3, [pc, #180]	; (800299c <hard_fault+0x1dc>)
 80028e8:	4f26      	ldr	r7, [pc, #152]	; (8002984 <hard_fault+0x1c4>)
 80028ea:	482d      	ldr	r0, [pc, #180]	; (80029a0 <hard_fault+0x1e0>)
 80028ec:	f015 0f80 	tst.w	r5, #128	; 0x80
 80028f0:	bf08      	it	eq
 80028f2:	4631      	moveq	r1, r6
 80028f4:	f015 0f20 	tst.w	r5, #32
 80028f8:	bf08      	it	eq
 80028fa:	4632      	moveq	r2, r6
 80028fc:	f015 0f10 	tst.w	r5, #16
 8002900:	bf08      	it	eq
 8002902:	4633      	moveq	r3, r6
 8002904:	f015 0f08 	tst.w	r5, #8
 8002908:	bf0c      	ite	eq
 800290a:	46b4      	moveq	ip, r6
 800290c:	46bc      	movne	ip, r7
 800290e:	4f25      	ldr	r7, [pc, #148]	; (80029a4 <hard_fault+0x1e4>)
 8002910:	f015 0f04 	tst.w	r5, #4
 8002914:	bf0c      	ite	eq
 8002916:	46b6      	moveq	lr, r6
 8002918:	46be      	movne	lr, r7
 800291a:	4f23      	ldr	r7, [pc, #140]	; (80029a8 <hard_fault+0x1e8>)
 800291c:	f015 0f02 	tst.w	r5, #2
 8002920:	bf08      	it	eq
 8002922:	4637      	moveq	r7, r6
 8002924:	f015 0f01 	tst.w	r5, #1
 8002928:	4d20      	ldr	r5, [pc, #128]	; (80029ac <hard_fault+0x1ec>)
 800292a:	9702      	str	r7, [sp, #8]
 800292c:	bf18      	it	ne
 800292e:	462e      	movne	r6, r5
 8002930:	e88d 5000 	stmia.w	sp, {ip, lr}
 8002934:	9603      	str	r6, [sp, #12]
 8002936:	f001 fec7 	bl	80046c8 <ice_trace7>
 800293a:	e7a6      	b.n	800288a <hard_fault+0xca>
 800293c:	08004b04 	.word	0x08004b04
 8002940:	08004ed8 	.word	0x08004ed8
 8002944:	08004ee0 	.word	0x08004ee0
 8002948:	08004ecc 	.word	0x08004ecc
 800294c:	40000280 	.word	0x40000280
 8002950:	40000290 	.word	0x40000290
 8002954:	400002a0 	.word	0x400002a0
 8002958:	400002b0 	.word	0x400002b0
 800295c:	400002c0 	.word	0x400002c0
 8002960:	400002d0 	.word	0x400002d0
 8002964:	400002e0 	.word	0x400002e0
 8002968:	400002f0 	.word	0x400002f0
 800296c:	40000300 	.word	0x40000300
 8002970:	40000310 	.word	0x40000310
 8002974:	40000330 	.word	0x40000330
 8002978:	08004f38 	.word	0x08004f38
 800297c:	08004f44 	.word	0x08004f44
 8002980:	08004f50 	.word	0x08004f50
 8002984:	08004f08 	.word	0x08004f08
 8002988:	08004f58 	.word	0x08004f58
 800298c:	40000340 	.word	0x40000340
 8002990:	08004f64 	.word	0x08004f64
 8002994:	08004eec 	.word	0x08004eec
 8002998:	08004ef8 	.word	0x08004ef8
 800299c:	08004f00 	.word	0x08004f00
 80029a0:	40000320 	.word	0x40000320
 80029a4:	08004f10 	.word	0x08004f10
 80029a8:	08004f20 	.word	0x08004f20
 80029ac:	08004f2c 	.word	0x08004f2c

080029b0 <bus_fault>:
#endif
}

void bus_fault(struct thinkos_context * ctx, uint32_t msp, 
			   uint32_t psp, uint32_t lr)
{
 80029b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t sp;
	(void)sp;

	if (lr & (1 << 4))
 80029b4:	f013 0f10 	tst.w	r3, #16
#endif
}

void bus_fault(struct thinkos_context * ctx, uint32_t msp, 
			   uint32_t psp, uint32_t lr)
{
 80029b8:	4604      	mov	r4, r0
 80029ba:	b082      	sub	sp, #8
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	DCC_LOG(LOG_ERROR, "Bus fault!");
 80029bc:	481a      	ldr	r0, [pc, #104]	; (8002a28 <bus_fault+0x78>)
{
	uint32_t sp;
	(void)sp;

	if (lr & (1 << 4))
		sp = psp;
 80029be:	bf0c      	ite	eq
 80029c0:	4688      	moveq	r8, r1
 80029c2:	4690      	movne	r8, r2
#endif
}

void bus_fault(struct thinkos_context * ctx, uint32_t msp, 
			   uint32_t psp, uint32_t lr)
{
 80029c4:	461f      	mov	r7, r3
 80029c6:	460e      	mov	r6, r1
 80029c8:	4615      	mov	r5, r2
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	DCC_LOG(LOG_ERROR, "Bus fault!");
 80029ca:	f001 fcfd 	bl	80043c8 <ice_trace0>

	DCC_LOG4(LOG_ERROR, "  R0=%08x  R1=%08x  R2=%08x  R3=%08x", 
 80029ce:	f104 0120 	add.w	r1, r4, #32
 80029d2:	e891 4006 	ldmia.w	r1, {r1, r2, lr}
 80029d6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80029d8:	4814      	ldr	r0, [pc, #80]	; (8002a2c <bus_fault+0x7c>)
 80029da:	9300      	str	r3, [sp, #0]
 80029dc:	4673      	mov	r3, lr
 80029de:	f001 fdb9 	bl	8004554 <ice_trace4>
			ctx->r0, ctx->r1, ctx->r2, ctx->r3);
	DCC_LOG4(LOG_ERROR, "  R4=%08x  R5=%08x  R6=%08x  R7=%08x", 
 80029e2:	68e2      	ldr	r2, [r4, #12]
 80029e4:	6821      	ldr	r1, [r4, #0]
 80029e6:	68a3      	ldr	r3, [r4, #8]
 80029e8:	4811      	ldr	r0, [pc, #68]	; (8002a30 <bus_fault+0x80>)
 80029ea:	9200      	str	r2, [sp, #0]
 80029ec:	f001 fdb2 	bl	8004554 <ice_trace4>
			ctx->r4, ctx->r7, ctx->r6, ctx->r7);
	DCC_LOG4(LOG_ERROR, "  R8=%08x  R9=%08x R10=%08x R11=%08x", 
 80029f0:	f104 0110 	add.w	r1, r4, #16
 80029f4:	e891 4006 	ldmia.w	r1, {r1, r2, lr}
 80029f8:	69e3      	ldr	r3, [r4, #28]
 80029fa:	480e      	ldr	r0, [pc, #56]	; (8002a34 <bus_fault+0x84>)
 80029fc:	9300      	str	r3, [sp, #0]
 80029fe:	4673      	mov	r3, lr
 8002a00:	f001 fda8 	bl	8004554 <ice_trace4>
			ctx->r8, ctx->r9, ctx->r10, ctx->r11);
	DCC_LOG4(LOG_ERROR, " R12=%08x  SP=%08x  LR=%08x  PC=%08x", 
 8002a04:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002a06:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002a08:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002a0a:	480b      	ldr	r0, [pc, #44]	; (8002a38 <bus_fault+0x88>)
 8002a0c:	9200      	str	r2, [sp, #0]
 8002a0e:	4642      	mov	r2, r8
 8002a10:	f001 fda0 	bl	8004554 <ice_trace4>
			ctx->r12, sp, ctx->lr, ctx->pc);
	DCC_LOG4(LOG_ERROR, "XPSR=%08x MSP=%08x PSP=%08x RET=%08x", 
 8002a14:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002a16:	4809      	ldr	r0, [pc, #36]	; (8002a3c <bus_fault+0x8c>)
 8002a18:	9700      	str	r7, [sp, #0]
 8002a1a:	4632      	mov	r2, r6
 8002a1c:	462b      	mov	r3, r5
 8002a1e:	f001 fd99 	bl	8004554 <ice_trace4>

	thinkos_context_show(ctx, sp, msp, psp);
	fprintf(stderr, "\n");
	fflush(stderr);
#endif
}
 8002a22:	b002      	add	sp, #8
 8002a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002a28:	40000350 	.word	0x40000350
 8002a2c:	40000360 	.word	0x40000360
 8002a30:	40000370 	.word	0x40000370
 8002a34:	40000380 	.word	0x40000380
 8002a38:	40000390 	.word	0x40000390
 8002a3c:	400003a0 	.word	0x400003a0

08002a40 <usage_fault>:

void usage_fault(struct thinkos_context * ctx, uint32_t msp, 
				 uint32_t psp, uint32_t lr)
{
 8002a40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t sp;
	(void)sp;

	if (lr & (1 << 4))
 8002a44:	f013 0f10 	tst.w	r3, #16
#endif
}

void usage_fault(struct thinkos_context * ctx, uint32_t msp, 
				 uint32_t psp, uint32_t lr)
{
 8002a48:	4604      	mov	r4, r0
 8002a4a:	b082      	sub	sp, #8
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	DCC_LOG(LOG_ERROR, "Usage fault!");
 8002a4c:	481a      	ldr	r0, [pc, #104]	; (8002ab8 <usage_fault+0x78>)
{
	uint32_t sp;
	(void)sp;

	if (lr & (1 << 4))
		sp = psp;
 8002a4e:	bf0c      	ite	eq
 8002a50:	4688      	moveq	r8, r1
 8002a52:	4690      	movne	r8, r2
#endif
}

void usage_fault(struct thinkos_context * ctx, uint32_t msp, 
				 uint32_t psp, uint32_t lr)
{
 8002a54:	461f      	mov	r7, r3
 8002a56:	460e      	mov	r6, r1
 8002a58:	4615      	mov	r5, r2
	if (lr & (1 << 4))
		sp = psp;
	else
		sp = msp;

	DCC_LOG(LOG_ERROR, "Usage fault!");
 8002a5a:	f001 fcb5 	bl	80043c8 <ice_trace0>

	DCC_LOG4(LOG_ERROR, "  R0=%08x  R1=%08x  R2=%08x  R3=%08x", 
 8002a5e:	f104 0120 	add.w	r1, r4, #32
 8002a62:	e891 4006 	ldmia.w	r1, {r1, r2, lr}
 8002a66:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002a68:	4814      	ldr	r0, [pc, #80]	; (8002abc <usage_fault+0x7c>)
 8002a6a:	9300      	str	r3, [sp, #0]
 8002a6c:	4673      	mov	r3, lr
 8002a6e:	f001 fd71 	bl	8004554 <ice_trace4>
			ctx->r0, ctx->r1, ctx->r2, ctx->r3);
	DCC_LOG4(LOG_ERROR, "  R4=%08x  R5=%08x  R6=%08x  R7=%08x", 
 8002a72:	68e2      	ldr	r2, [r4, #12]
 8002a74:	6821      	ldr	r1, [r4, #0]
 8002a76:	68a3      	ldr	r3, [r4, #8]
 8002a78:	4811      	ldr	r0, [pc, #68]	; (8002ac0 <usage_fault+0x80>)
 8002a7a:	9200      	str	r2, [sp, #0]
 8002a7c:	f001 fd6a 	bl	8004554 <ice_trace4>
			ctx->r4, ctx->r7, ctx->r6, ctx->r7);
	DCC_LOG4(LOG_ERROR, "  R8=%08x  R9=%08x R10=%08x R11=%08x", 
 8002a80:	f104 0110 	add.w	r1, r4, #16
 8002a84:	e891 4006 	ldmia.w	r1, {r1, r2, lr}
 8002a88:	69e3      	ldr	r3, [r4, #28]
 8002a8a:	480e      	ldr	r0, [pc, #56]	; (8002ac4 <usage_fault+0x84>)
 8002a8c:	9300      	str	r3, [sp, #0]
 8002a8e:	4673      	mov	r3, lr
 8002a90:	f001 fd60 	bl	8004554 <ice_trace4>
			ctx->r8, ctx->r9, ctx->r10, ctx->r11);
	DCC_LOG4(LOG_ERROR, " R12=%08x  SP=%08x  LR=%08x  PC=%08x", 
 8002a94:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002a96:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002a98:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002a9a:	480b      	ldr	r0, [pc, #44]	; (8002ac8 <usage_fault+0x88>)
 8002a9c:	9200      	str	r2, [sp, #0]
 8002a9e:	4642      	mov	r2, r8
 8002aa0:	f001 fd58 	bl	8004554 <ice_trace4>
			ctx->r12, sp, ctx->lr, ctx->pc);
	DCC_LOG4(LOG_ERROR, "XPSR=%08x MSP=%08x PSP=%08x RET=%08x", 
 8002aa4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002aa6:	4809      	ldr	r0, [pc, #36]	; (8002acc <usage_fault+0x8c>)
 8002aa8:	9700      	str	r7, [sp, #0]
 8002aaa:	4632      	mov	r2, r6
 8002aac:	462b      	mov	r3, r5
 8002aae:	f001 fd51 	bl	8004554 <ice_trace4>

	thinkos_context_show(ctx, sp, msp, psp);
	fprintf(stderr, "\n");
	fflush(stderr);
#endif
}
 8002ab2:	b002      	add	sp, #8
 8002ab4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002ab8:	400003b0 	.word	0x400003b0
 8002abc:	400003c0 	.word	0x400003c0
 8002ac0:	400003d0 	.word	0x400003d0
 8002ac4:	400003e0 	.word	0x400003e0
 8002ac8:	400003f0 	.word	0x400003f0
 8002acc:	40000400 	.word	0x40000400

08002ad0 <thinkos_default_exception_dsr>:
	thinkos_exception_dsr(ctx);
}

void __attribute__((noreturn)) 
	thinkos_default_exception_dsr(struct thinkos_context * ctx)
{
 8002ad0:	e7fe      	b.n	8002ad0 <thinkos_default_exception_dsr>
 8002ad2:	bf00      	nop

08002ad4 <cm3_hard_fault_isr>:
#endif

static inline struct thinkos_context * 
	__attribute__((always_inline)) __get_context(void) {
	register struct thinkos_context * ctx;
	asm volatile ("tst   lr, #0x4\n" /* Test EXC_RETURN bit 2 */
 8002ad4:	f01e 0f04 	tst.w	lr, #4
 8002ad8:	bf18      	it	ne
 8002ada:	b088      	subne	sp, #32
 8002adc:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002ae0:	f01e 0f04 	tst.w	lr, #4
 8002ae4:	d006      	beq.n	8002af4 <cm3_hard_fault_isr+0x20>
 8002ae6:	f3ef 8009 	mrs	r0, PSP
 8002aea:	a908      	add	r1, sp, #32
 8002aec:	e890 03fc 	ldmia.w	r0, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002af0:	e881 03fc 	stmia.w	r1, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002af4:	466c      	mov	r4, sp
	asm volatile ("mov sp, %0\n" : "=r" (sp));
}

static inline uint32_t __attribute__((always_inline)) cm3_lr_get(void) {
	register uint32_t lr;
	asm volatile ("mov %0, lr\n" : "=r" (lr));
 8002af6:	4673      	mov	r3, lr
	asm volatile ("msr MSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_msp_get(void) {
	uint32_t msp;
	asm volatile ("mrs %0, MSP\n" : "=r" (msp));
 8002af8:	f3ef 8108 	mrs	r1, MSP
	asm volatile ("msr PSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_psp_get(void) {
	uint32_t psp;
	asm volatile ("mrs %0, PSP\n" : "=r" (psp));
 8002afc:	f3ef 8209 	mrs	r2, PSP
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 8002b00:	2001      	movs	r0, #1
 8002b02:	f380 8813 	msr	FAULTMASK, r0
	msp = cm3_msp_get();
	psp = cm3_psp_get();

	cm3_faultmask_set(1);

	hard_fault(ctx, msp, psp, lr);
 8002b06:	4620      	mov	r0, r4
 8002b08:	f7ff fe5a 	bl	80027c0 <hard_fault>

	thinkos_exception_dsr(ctx);
 8002b0c:	4620      	mov	r0, r4
 8002b0e:	f7ff ffdf 	bl	8002ad0 <thinkos_default_exception_dsr>
 8002b12:	bf00      	nop

08002b14 <cm3_usage_fault_isr>:
#endif

static inline struct thinkos_context * 
	__attribute__((always_inline)) __get_context(void) {
	register struct thinkos_context * ctx;
	asm volatile ("tst   lr, #0x4\n" /* Test EXC_RETURN bit 2 */
 8002b14:	f01e 0f04 	tst.w	lr, #4
 8002b18:	bf18      	it	ne
 8002b1a:	b088      	subne	sp, #32
 8002b1c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002b20:	f01e 0f04 	tst.w	lr, #4
 8002b24:	d006      	beq.n	8002b34 <cm3_usage_fault_isr+0x20>
 8002b26:	f3ef 8009 	mrs	r0, PSP
 8002b2a:	a908      	add	r1, sp, #32
 8002b2c:	e890 03fc 	ldmia.w	r0, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002b30:	e881 03fc 	stmia.w	r1, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002b34:	466c      	mov	r4, sp
	asm volatile ("mov sp, %0\n" : "=r" (sp));
}

static inline uint32_t __attribute__((always_inline)) cm3_lr_get(void) {
	register uint32_t lr;
	asm volatile ("mov %0, lr\n" : "=r" (lr));
 8002b36:	4673      	mov	r3, lr
	asm volatile ("msr MSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_msp_get(void) {
	uint32_t msp;
	asm volatile ("mrs %0, MSP\n" : "=r" (msp));
 8002b38:	f3ef 8108 	mrs	r1, MSP
	asm volatile ("msr PSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_psp_get(void) {
	uint32_t psp;
	asm volatile ("mrs %0, PSP\n" : "=r" (psp));
 8002b3c:	f3ef 8209 	mrs	r2, PSP
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 8002b40:	2001      	movs	r0, #1
 8002b42:	f380 8813 	msr	FAULTMASK, r0
	msp = cm3_msp_get();
	psp = cm3_psp_get();

	cm3_faultmask_set(1);

	usage_fault(ctx, msp, psp, lr);
 8002b46:	4620      	mov	r0, r4
 8002b48:	f7ff ff7a 	bl	8002a40 <usage_fault>

	thinkos_exception_dsr(ctx);
 8002b4c:	4620      	mov	r0, r4
 8002b4e:	f7ff ffbf 	bl	8002ad0 <thinkos_default_exception_dsr>
 8002b52:	bf00      	nop

08002b54 <cm3_bus_fault_isr>:
#endif

static inline struct thinkos_context * 
	__attribute__((always_inline)) __get_context(void) {
	register struct thinkos_context * ctx;
	asm volatile ("tst   lr, #0x4\n" /* Test EXC_RETURN bit 2 */
 8002b54:	f01e 0f04 	tst.w	lr, #4
 8002b58:	bf18      	it	ne
 8002b5a:	b088      	subne	sp, #32
 8002b5c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002b60:	f01e 0f04 	tst.w	lr, #4
 8002b64:	d006      	beq.n	8002b74 <cm3_bus_fault_isr+0x20>
 8002b66:	f3ef 8009 	mrs	r0, PSP
 8002b6a:	a908      	add	r1, sp, #32
 8002b6c:	e890 03fc 	ldmia.w	r0, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002b70:	e881 03fc 	stmia.w	r1, {r2, r3, r4, r5, r6, r7, r8, r9}
 8002b74:	466c      	mov	r4, sp
	asm volatile ("mov sp, %0\n" : "=r" (sp));
}

static inline uint32_t __attribute__((always_inline)) cm3_lr_get(void) {
	register uint32_t lr;
	asm volatile ("mov %0, lr\n" : "=r" (lr));
 8002b76:	4673      	mov	r3, lr
	asm volatile ("msr MSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_msp_get(void) {
	uint32_t msp;
	asm volatile ("mrs %0, MSP\n" : "=r" (msp));
 8002b78:	f3ef 8108 	mrs	r1, MSP
	asm volatile ("msr PSP, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_psp_get(void) {
	uint32_t psp;
	asm volatile ("mrs %0, PSP\n" : "=r" (psp));
 8002b7c:	f3ef 8209 	mrs	r2, PSP
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 8002b80:	2001      	movs	r0, #1
 8002b82:	f380 8813 	msr	FAULTMASK, r0
	msp = cm3_msp_get();
	psp = cm3_psp_get();

	cm3_faultmask_set(1);

	bus_fault(ctx, msp, psp, lr);
 8002b86:	4620      	mov	r0, r4
 8002b88:	f7ff ff12 	bl	80029b0 <bus_fault>

	thinkos_exception_dsr(ctx);
 8002b8c:	4620      	mov	r0, r4
 8002b8e:	f7ff ff9f 	bl	8002ad0 <thinkos_default_exception_dsr>
 8002b92:	bf00      	nop

08002b94 <thinkos_rt_snapshot_svc>:
#include <thinkos.h>

extern const uint8_t thinkos_obj_type_lut[];

void thinkos_rt_snapshot_svc(int32_t * arg)
{
 8002b94:	b430      	push	{r4, r5}
	uint32_t * dst = (uint32_t *)arg[0];
 8002b96:	6804      	ldr	r4, [r0, #0]
	asm volatile ("msr PRIMASK, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_primask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
 8002b98:	f3ef 8510 	mrs	r5, PRIMASK
static inline void __attribute__((always_inline)) cm3_cpsie_f(void) {
	asm volatile ("cpsie f\n");
}

static inline void __attribute__((always_inline)) cm3_primask_set(uint32_t val) {
	asm volatile ("msr PRIMASK, %0\n" : : "r" (val));
 8002b9c:	2301      	movs	r3, #1
 8002b9e:	f383 8810 	msr	PRIMASK, r3

	cm3_primask_set(1);

	src = (uint32_t *)&thinkos_rt;

	for (i = 0; i < (sizeof(struct thinkos_rt) / 4); ++i)
 8002ba2:	2200      	movs	r2, #0
 8002ba4:	4807      	ldr	r0, [pc, #28]	; (8002bc4 <thinkos_rt_snapshot_svc+0x30>)
 8002ba6:	4613      	mov	r3, r2
		dst[i] = src[i];
 8002ba8:	f850 1022 	ldr.w	r1, [r0, r2, lsl #2]

	cm3_primask_set(1);

	src = (uint32_t *)&thinkos_rt;

	for (i = 0; i < (sizeof(struct thinkos_rt) / 4); ++i)
 8002bac:	3301      	adds	r3, #1
 8002bae:	f5b3 7f4b 	cmp.w	r3, #812	; 0x32c
		dst[i] = src[i];
 8002bb2:	f844 1022 	str.w	r1, [r4, r2, lsl #2]

	cm3_primask_set(1);

	src = (uint32_t *)&thinkos_rt;

	for (i = 0; i < (sizeof(struct thinkos_rt) / 4); ++i)
 8002bb6:	461a      	mov	r2, r3
 8002bb8:	d1f6      	bne.n	8002ba8 <thinkos_rt_snapshot_svc+0x14>
 8002bba:	f385 8810 	msr	PRIMASK, r5
		dst[i] = src[i];

	cm3_primask_set(pri);
}
 8002bbe:	bc30      	pop	{r4, r5}
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop
 8002bc4:	20000088 	.word	0x20000088

08002bc8 <thinkos_obj_type_get>:

int thinkos_obj_type_get(unsigned int oid)
{
	if (oid >= THINKOS_WQ_LST_END)
 8002bc8:	f5b0 7fc9 	cmp.w	r0, #402	; 0x192
		return THINKOS_EINVAL;

	return thinkos_obj_type_lut[oid];
 8002bcc:	bf3a      	itte	cc
 8002bce:	4b02      	ldrcc	r3, [pc, #8]	; (8002bd8 <thinkos_obj_type_get+0x10>)
 8002bd0:	5c18      	ldrbcc	r0, [r3, r0]
}

int thinkos_obj_type_get(unsigned int oid)
{
	if (oid >= THINKOS_WQ_LST_END)
		return THINKOS_EINVAL;
 8002bd2:	f06f 0002 	mvncs.w	r0, #2

	return thinkos_obj_type_lut[oid];
}
 8002bd6:	4770      	bx	lr
 8002bd8:	08004fb8 	.word	0x08004fb8

08002bdc <thinkos_alloc_bmp_get>:

uint32_t * thinkos_alloc_bmp_get(unsigned int type)
{
	return thinkos_obj_alloc_lut[type];
 8002bdc:	f644 7388 	movw	r3, #20360	; 0x4f88
 8002be0:	f6c0 0300 	movt	r3, #2048	; 0x800
}
 8002be4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8002be8:	4770      	bx	lr
 8002bea:	bf00      	nop

08002bec <thinkos_sleep_svc>:
#if THINKOS_ENABLE_SLEEP
void thinkos_sleep_svc(int32_t * arg)
{
	uint32_t ms = (uint32_t)arg[0];
#if THINKOS_ENABLE_CLOCK
	int self = thinkos_rt.active;
 8002bec:	f240 0388 	movw	r3, #136	; 0x88
 8002bf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
#include <thinkos.h>
#include <sys/delay.h>

#if THINKOS_ENABLE_SLEEP
void thinkos_sleep_svc(int32_t * arg)
{
 8002bf4:	b430      	push	{r4, r5}
	uint32_t ms = (uint32_t)arg[0];
#if THINKOS_ENABLE_CLOCK
	int self = thinkos_rt.active;
 8002bf6:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84

	/* set the clock */
	thinkos_rt.clock[self] = thinkos_rt.ticks + ms;
 8002bfa:	6805      	ldr	r5, [r0, #0]
 8002bfc:	f8d3 46f0 	ldr.w	r4, [r3, #1776]	; 0x6f0
 8002c00:	eb03 0082 	add.w	r0, r3, r2, lsl #2
 8002c04:	192c      	adds	r4, r5, r4
 8002c06:	f8c0 46f4 	str.w	r4, [r0, #1780]	; 0x6f4

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002c0a:	480b      	ldr	r0, [pc, #44]	; (8002c38 <thinkos_sleep_svc+0x4c>)
 8002c0c:	0140      	lsls	r0, r0, #5
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, self, 1);

#if THINKOS_ENABLE_THREAD_STAT
	/* mark the thread clock enable bit */
	thinkos_rt.th_stat[self] = (THINKOS_WQ_CLOCK << 1) + 1;
 8002c0e:	189b      	adds	r3, r3, r2
 8002c10:	2401      	movs	r4, #1
 8002c12:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
 8002c16:	2003      	movs	r0, #3
 8002c18:	f883 06d0 	strb.w	r0, [r3, #1744]	; 0x6d0
 8002c1c:	4b07      	ldr	r3, [pc, #28]	; (8002c3c <thinkos_sleep_svc+0x50>)
 8002c1e:	f44f 416d 	mov.w	r1, #60672	; 0xed00
 8002c22:	015b      	lsls	r3, r3, #5
 8002c24:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8002c28:	2000      	movs	r0, #0
 8002c2a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8002c2e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002c32:	604b      	str	r3, [r1, #4]
	__thinkos_wait(self);
#else
	DCC_LOG1(LOG_TRACE, "busy wait: %d milliseconds...", ms);
	udelay(1000 * ms);
#endif
}
 8002c34:	bc30      	pop	{r4, r5}
 8002c36:	4770      	bx	lr
 8002c38:	21100114 	.word	0x21100114
 8002c3c:	21100110 	.word	0x21100110

08002c40 <thinkos_alarm_svc>:

#if THINKOS_ENABLE_ALARM
void thinkos_alarm_svc(int32_t * arg)
{
	uint32_t ms = (uint32_t)arg[0];
	int self = thinkos_rt.active;
 8002c40:	f240 0388 	movw	r3, #136	; 0x88
 8002c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
#endif

#if THINKOS_ENABLE_ALARM
void thinkos_alarm_svc(int32_t * arg)
{
 8002c48:	b410      	push	{r4}
	uint32_t ms = (uint32_t)arg[0];
	int self = thinkos_rt.active;
 8002c4a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84

	/* set the clock */
	thinkos_rt.clock[self] = ms;
 8002c4e:	6804      	ldr	r4, [r0, #0]
 8002c50:	eb03 0082 	add.w	r0, r3, r2, lsl #2
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, self, 1);
#if THINKOS_ENABLE_THREAD_STAT
	/* mark the thread clock enable bit */
	thinkos_rt.th_stat[self] = (THINKOS_WQ_CLOCK << 1) + 1;
 8002c54:	189b      	adds	r3, r3, r2
{
	uint32_t ms = (uint32_t)arg[0];
	int self = thinkos_rt.active;

	/* set the clock */
	thinkos_rt.clock[self] = ms;
 8002c56:	f8c0 46f4 	str.w	r4, [r0, #1780]	; 0x6f4
 8002c5a:	480b      	ldr	r0, [pc, #44]	; (8002c88 <thinkos_alarm_svc+0x48>)
 8002c5c:	0140      	lsls	r0, r0, #5
 8002c5e:	2401      	movs	r4, #1
 8002c60:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, self, 1);
#if THINKOS_ENABLE_THREAD_STAT
	/* mark the thread clock enable bit */
	thinkos_rt.th_stat[self] = (THINKOS_WQ_CLOCK << 1) + 1;
 8002c64:	2003      	movs	r0, #3
 8002c66:	f883 06d0 	strb.w	r0, [r3, #1744]	; 0x6d0
 8002c6a:	4b08      	ldr	r3, [pc, #32]	; (8002c8c <thinkos_alarm_svc+0x4c>)
 8002c6c:	f44f 416d 	mov.w	r1, #60672	; 0xed00
 8002c70:	015b      	lsls	r3, r3, #5
 8002c72:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8002c76:	2000      	movs	r0, #0
 8002c78:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8002c7c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002c80:	604b      	str	r3, [r1, #4]
#endif
	/* wait for event */
	__thinkos_wait(self);
}
 8002c82:	bc10      	pop	{r4}
 8002c84:	4770      	bx	lr
 8002c86:	bf00      	nop
 8002c88:	21100114 	.word	0x21100114
 8002c8c:	21100110 	.word	0x21100110

08002c90 <thinkos_exit_svc>:


#if THINKOS_ENABLE_EXIT
void thinkos_exit_svc(int32_t * arg)
{
	int self = thinkos_rt.active;
 8002c90:	f240 0388 	movw	r3, #136	; 0x88
 8002c94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c98:	4a11      	ldr	r2, [pc, #68]	; (8002ce0 <thinkos_exit_svc+0x50>)
 8002c9a:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
 8002c9e:	0152      	lsls	r2, r2, #5
#endif


#if THINKOS_ENABLE_EXIT
void thinkos_exit_svc(int32_t * arg)
{
 8002ca0:	b570      	push	{r4, r5, r6, lr}
	int self = thinkos_rt.active;
	int code = arg[0];
 8002ca2:	6805      	ldr	r5, [r0, #0]
#endif


#if THINKOS_ENABLE_EXIT
void thinkos_exit_svc(int32_t * arg)
{
 8002ca4:	4604      	mov	r4, r0
 8002ca6:	2001      	movs	r0, #1
 8002ca8:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 8002cac:	185b      	adds	r3, r3, r1
	wq = __wq_idx(&thinkos_rt.wq_ready);
#endif /* THINKOS_ENABLE_JOIN */

	__thinkos_wq_insert(wq, self);

	DCC_LOG2(LOG_TRACE, "<%d> exit with code %d!", self, code); 
 8002cae:	f240 4010 	movw	r0, #1040	; 0x410
 8002cb2:	462a      	mov	r2, r5
 8002cb4:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8002cb8:	2600      	movs	r6, #0
 8002cba:	f883 66d0 	strb.w	r6, [r3, #1744]	; 0x6d0
 8002cbe:	f001 fbd7 	bl	8004470 <ice_trace2>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002cc2:	f44f 436d 	mov.w	r3, #60672	; 0xed00

	/* adjust PC */
	arg[6] = (uint32_t)thinkos_thread_exit;
 8002cc6:	f641 3281 	movw	r2, #7041	; 0x1b81
 8002cca:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002cce:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002cd2:	61a2      	str	r2, [r4, #24]
 8002cd4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	/* set the return code at R0 */
	arg[0] = code;
 8002cd8:	6025      	str	r5, [r4, #0]
 8002cda:	605a      	str	r2, [r3, #4]
 8002cdc:	bd70      	pop	{r4, r5, r6, pc}
 8002cde:	bf00      	nop
 8002ce0:	21100110 	.word	0x21100110

08002ce4 <thinkos_thread_create_svc>:
}
#endif

/* initialize a thread context */
void thinkos_thread_create_svc(int32_t * arg)
{
 8002ce4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct thinkos_context * ctx;
	uint32_t sp;
	int th;

#if THINKOS_ENABLE_THREAD_ALLOC
	if (init->opt.id >= THINKOS_THREADS_MAX) {
 8002ce8:	7bc3      	ldrb	r3, [r0, #15]

	if (start > 31)
		start = 31;

	/* Look for an empty bit LSB first */
	idx = start - __clz(~(*ptr << (31 - start)));
 8002cea:	4f46      	ldr	r7, [pc, #280]	; (8002e04 <thinkos_thread_create_svc+0x120>)
 8002cec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002cf0:	2b1f      	cmp	r3, #31
}
#endif

/* initialize a thread context */
void thinkos_thread_create_svc(int32_t * arg)
{
 8002cf2:	4605      	mov	r5, r0
	struct thinkos_context * ctx;
	uint32_t sp;
	int th;

#if THINKOS_ENABLE_THREAD_ALLOC
	if (init->opt.id >= THINKOS_THREADS_MAX) {
 8002cf4:	dd52      	ble.n	8002d9c <thinkos_thread_create_svc+0xb8>
 8002cf6:	f8d7 6bec 	ldr.w	r6, [r7, #3052]	; 0xbec
 8002cfa:	43f6      	mvns	r6, r6
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8002cfc:	fab6 f686 	clz	r6, r6
	if (idx < 0)
 8002d00:	f1d6 061f 	rsbs	r6, r6, #31
 8002d04:	d463      	bmi.n	8002dce <thinkos_thread_create_svc+0xea>

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002d06:	4b40      	ldr	r3, [pc, #256]	; (8002e08 <thinkos_thread_create_svc+0x124>)
 8002d08:	015b      	lsls	r3, r3, #5
 8002d0a:	2201      	movs	r2, #1
 8002d0c:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif

	sp = (uint32_t)init->stack_ptr + init->opt.stack_size;
 8002d10:	89a9      	ldrh	r1, [r5, #12]
 8002d12:	68ab      	ldr	r3, [r5, #8]

	if (init->opt.stack_size < sizeof(struct thinkos_context)) {
 8002d14:	293f      	cmp	r1, #63	; 0x3f
 8002d16:	d96c      	bls.n	8002df2 <thinkos_thread_create_svc+0x10e>
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif

	sp = (uint32_t)init->stack_ptr + init->opt.stack_size;
 8002d18:	1859      	adds	r1, r3, r1
		DCC_LOG1(LOG_ERROR, "stack too small. size=%d", init->opt.stack_size);
		arg[0] = THINKOS_EINVAL;
		return;
	}

	sp &= 0xfffffff8; /* 64bits alignemnt */
 8002d1a:	f021 0807 	bic.w	r8, r1, #7
	DCC_LOG3(LOG_INFO, "stack ptr=%08x top=%08x size=%d", 
			 init->stack_ptr, sp, init->opt.stack_size);

	sp -= sizeof(struct thinkos_context);
 8002d1e:	f1a8 0440 	sub.w	r4, r8, #64	; 0x40

	DCC_LOG1(LOG_TRACE, "sp=%08x", sp);
 8002d22:	483a      	ldr	r0, [pc, #232]	; (8002e0c <thinkos_thread_create_svc+0x128>)
 8002d24:	4621      	mov	r1, r4
 8002d26:	f001 fb75 	bl	8004414 <ice_trace1>

	/* initialize stack */
	{
		uint32_t * ptr;
		for (ptr = init->stack_ptr; ptr < (uint32_t *)sp; ++ptr)
 8002d2a:	68ab      	ldr	r3, [r5, #8]
 8002d2c:	42a3      	cmp	r3, r4
			*ptr = 0xdeadbeef;
 8002d2e:	bf3c      	itt	cc
 8002d30:	f64b 62ef 	movwcc	r2, #48879	; 0xbeef
 8002d34:	f6cd 62ad 	movtcc	r2, #57005	; 0xdead
	DCC_LOG1(LOG_TRACE, "sp=%08x", sp);

	/* initialize stack */
	{
		uint32_t * ptr;
		for (ptr = init->stack_ptr; ptr < (uint32_t *)sp; ++ptr)
 8002d38:	d203      	bcs.n	8002d42 <thinkos_thread_create_svc+0x5e>
			*ptr = 0xdeadbeef;
 8002d3a:	f843 2b04 	str.w	r2, [r3], #4
	DCC_LOG1(LOG_TRACE, "sp=%08x", sp);

	/* initialize stack */
	{
		uint32_t * ptr;
		for (ptr = init->stack_ptr; ptr < (uint32_t *)sp; ++ptr)
 8002d3e:	42a3      	cmp	r3, r4
 8002d40:	d3fb      	bcc.n	8002d3a <thinkos_thread_create_svc+0x56>
	ctx->r9 = 0;
	ctx->r10 = 0;
	ctx->r11 = 0;
	ctx->r12 = 0;
	ctx->lr = (uint32_t)thinkos_thread_exit;
	ctx->pc = (uint32_t)init->task;
 8002d42:	e895 000c 	ldmia.w	r5, {r2, r3}
	}

	ctx = (struct thinkos_context *)sp;

//	ctx->ret = CM3_EXC_RET_THREAD_PSP;
	ctx->r0 = (uint32_t)init->arg;
 8002d46:	6223      	str	r3, [r4, #32]
	ctx->r1 = 0;
 8002d48:	2300      	movs	r3, #0
 8002d4a:	6263      	str	r3, [r4, #36]	; 0x24
	ctx->r2 = 0;
 8002d4c:	62a3      	str	r3, [r4, #40]	; 0x28
	ctx->r3 = 0;
 8002d4e:	62e3      	str	r3, [r4, #44]	; 0x2c
	ctx->r4 = 0;
 8002d50:	f848 3c40 	str.w	r3, [r8, #-64]
	ctx->r5 = 0;
 8002d54:	6063      	str	r3, [r4, #4]
	ctx->r6 = 0;
 8002d56:	60a3      	str	r3, [r4, #8]
	ctx->r7 = 0;
 8002d58:	60e3      	str	r3, [r4, #12]
	ctx->r8 = 0;
 8002d5a:	6123      	str	r3, [r4, #16]
	ctx->r9 = 0;
 8002d5c:	6163      	str	r3, [r4, #20]
	ctx->r10 = 0;
 8002d5e:	61a3      	str	r3, [r4, #24]
	ctx->r11 = 0;
 8002d60:	61e3      	str	r3, [r4, #28]
	ctx->r12 = 0;
 8002d62:	6323      	str	r3, [r4, #48]	; 0x30
	ctx->lr = (uint32_t)thinkos_thread_exit;
 8002d64:	4b2a      	ldr	r3, [pc, #168]	; (8002e10 <thinkos_thread_create_svc+0x12c>)
	ctx->pc = (uint32_t)init->task;
 8002d66:	63a2      	str	r2, [r4, #56]	; 0x38
	ctx->r8 = 0;
	ctx->r9 = 0;
	ctx->r10 = 0;
	ctx->r11 = 0;
	ctx->r12 = 0;
	ctx->lr = (uint32_t)thinkos_thread_exit;
 8002d68:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->pc = (uint32_t)init->task;
	ctx->xpsr = 0x01000000;
 8002d6a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002d6e:	63e3      	str	r3, [r4, #60]	; 0x3c

	thinkos_rt.ctx[th] = ctx;
 8002d70:	f847 4026 	str.w	r4, [r7, r6, lsl #2]

#if THINKOS_ENABLE_THREAD_INFO
	thinkos_rt.th_inf[th] = init->inf;
 8002d74:	eb07 0786 	add.w	r7, r7, r6, lsl #2
 8002d78:	692a      	ldr	r2, [r5, #16]
 8002d7a:	f8c7 2c2c 	str.w	r2, [r7, #3116]	; 0xc2c
 8002d7e:	4a25      	ldr	r2, [pc, #148]	; (8002e14 <thinkos_thread_create_svc+0x130>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002d80:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002d84:	0152      	lsls	r2, r2, #5
 8002d86:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002d8a:	2101      	movs	r1, #1
 8002d8c:	f842 1026 	str.w	r1, [r2, r6, lsl #2]
 8002d90:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002d94:	605a      	str	r2, [r3, #4]
	DCC_LOG5(LOG_TRACE, "<%d> pri=%d/%d task=%08x sp=%08x", 
			 th, thinkos_rt.sched_pri[th], 
			 thinkos_rt.sched_limit, init->task, ctx);
#endif

	arg[0] = th;
 8002d96:	602e      	str	r6, [r5, #0]
 8002d98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

static inline int __attribute__((always_inline)) 
thinkos_alloc_lo(uint32_t * ptr, int start) {
	int idx;
	/* Look for an empty bit MSB first */
	idx = __clz(__rbit(~(*ptr >> start))) + start;
 8002d9c:	f8d7 1bec 	ldr.w	r1, [r7, #3052]	; 0xbec
 8002da0:	fa21 f203 	lsr.w	r2, r1, r3
 8002da4:	43d2      	mvns	r2, r2
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8002da6:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8002daa:	fab2 f282 	clz	r2, r2
 8002dae:	18d2      	adds	r2, r2, r3
	if (idx >= 32)
 8002db0:	2a1f      	cmp	r2, #31

static inline int __attribute__((always_inline)) 
thinkos_alloc_lo(uint32_t * ptr, int start) {
	int idx;
	/* Look for an empty bit MSB first */
	idx = __clz(__rbit(~(*ptr >> start))) + start;
 8002db2:	4616      	mov	r6, r2
	if (idx >= 32)
 8002db4:	dd10      	ble.n	8002dd8 <thinkos_thread_create_svc+0xf4>
 8002db6:	2b1f      	cmp	r3, #31
 8002db8:	bfa8      	it	ge
 8002dba:	231f      	movge	r3, #31

	if (start > 31)
		start = 31;

	/* Look for an empty bit LSB first */
	idx = start - __clz(~(*ptr << (31 - start)));
 8002dbc:	f1c3 061f 	rsb	r6, r3, #31
 8002dc0:	fa01 f606 	lsl.w	r6, r1, r6
 8002dc4:	43f6      	mvns	r6, r6
 8002dc6:	fab6 f686 	clz	r6, r6
	if (idx < 0)
 8002dca:	1b9e      	subs	r6, r3, r6
 8002dcc:	d59b      	bpl.n	8002d06 <thinkos_thread_create_svc+0x22>
					init->opt.id, th);
		}
	}

	if (th < 0) {
		arg[0] = THINKOS_EINVAL;
 8002dce:	f06f 0302 	mvn.w	r3, #2
 8002dd2:	602b      	str	r3, [r5, #0]
		return;
 8002dd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8002dd8:	4b0b      	ldr	r3, [pc, #44]	; (8002e08 <thinkos_thread_create_svc+0x124>)
 8002dda:	015b      	lsls	r3, r3, #5
 8002ddc:	2101      	movs	r1, #1
		DCC_LOG1(LOG_INFO, "thinkos_rt.th_alloc=0x%08x", thinkos_rt.th_alloc);
	} else {
		/* Look for the next available slot */
		th = thinkos_alloc_lo(thinkos_rt.th_alloc, init->opt.id);
		DCC_LOG2(LOG_INFO, "thinkos_alloc_lo() %d -> %d.", init->opt.id, th);
		if (th < 0) {
 8002dde:	2a00      	cmp	r2, #0
 8002de0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8002de4:	da94      	bge.n	8002d10 <thinkos_thread_create_svc+0x2c>
 8002de6:	7bc3      	ldrb	r3, [r0, #15]
 8002de8:	f8d7 1bec 	ldr.w	r1, [r7, #3052]	; 0xbec
 8002dec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002df0:	e7e1      	b.n	8002db6 <thinkos_thread_create_svc+0xd2>
#endif

	sp = (uint32_t)init->stack_ptr + init->opt.stack_size;

	if (init->opt.stack_size < sizeof(struct thinkos_context)) {
		DCC_LOG1(LOG_ERROR, "stack too small. size=%d", init->opt.stack_size);
 8002df2:	4809      	ldr	r0, [pc, #36]	; (8002e18 <thinkos_thread_create_svc+0x134>)
 8002df4:	f001 fb0e 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002df8:	f06f 0302 	mvn.w	r3, #2
 8002dfc:	602b      	str	r3, [r5, #0]
		return;
 8002dfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002e02:	bf00      	nop
 8002e04:	20000088 	.word	0x20000088
 8002e08:	21100c74 	.word	0x21100c74
 8002e0c:	40000430 	.word	0x40000430
 8002e10:	08001b81 	.word	0x08001b81
 8002e14:	21100110 	.word	0x21100110
 8002e18:	40000420 	.word	0x40000420

08002e1c <thinkos_mutex_alloc_svc>:

#if THINKOS_MUTEX_MAX > 0

#if THINKOS_ENABLE_MUTEX_ALLOC
void thinkos_mutex_alloc_svc(int32_t * arg)
{
 8002e1c:	b510      	push	{r4, lr}
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.mutex_alloc, 
 8002e1e:	2150      	movs	r1, #80	; 0x50

#if THINKOS_MUTEX_MAX > 0

#if THINKOS_ENABLE_MUTEX_ALLOC
void thinkos_mutex_alloc_svc(int32_t * arg)
{
 8002e20:	4604      	mov	r4, r0
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.mutex_alloc, 
 8002e22:	4807      	ldr	r0, [pc, #28]	; (8002e40 <thinkos_mutex_alloc_svc+0x24>)
 8002e24:	f7fe ffd4 	bl	8001dd0 <thinkos_bmp_alloc>
 8002e28:	2800      	cmp	r0, #0
 8002e2a:	db07      	blt.n	8002e3c <thinkos_mutex_alloc_svc+0x20>
								 THINKOS_MUTEX_MAX)) >= 0) {
		thinkos_rt.lock[idx] = -1;
 8002e2c:	4a05      	ldr	r2, [pc, #20]	; (8002e44 <thinkos_mutex_alloc_svc+0x28>)
 8002e2e:	1812      	adds	r2, r2, r0
		wq = idx + THINKOS_MUTEX_BASE;
 8002e30:	1c83      	adds	r3, r0, #2
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.mutex_alloc, 
								 THINKOS_MUTEX_MAX)) >= 0) {
		thinkos_rt.lock[idx] = -1;
 8002e32:	21ff      	movs	r1, #255	; 0xff
 8002e34:	f882 1b4c 	strb.w	r1, [r2, #2892]	; 0xb4c
		wq = idx + THINKOS_MUTEX_BASE;
		DCC_LOG2(LOG_MSG, "mutex=%d wq=%d", idx, wq);
		arg[0] = wq;
 8002e38:	6023      	str	r3, [r4, #0]
 8002e3a:	bd10      	pop	{r4, pc}
	} else 
		arg[0] = idx;
 8002e3c:	6020      	str	r0, [r4, #0]
 8002e3e:	bd10      	pop	{r4, pc}
 8002e40:	20000c78 	.word	0x20000c78
 8002e44:	20000088 	.word	0x20000088

08002e48 <thinkos_mutex_free_svc>:
}

void thinkos_mutex_free_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8002e48:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_MUTEX_BASE;
 8002e4a:	1e8b      	subs	r3, r1, #2

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_MUTEX_MAX) {
 8002e4c:	2b4f      	cmp	r3, #79	; 0x4f
	} else 
		arg[0] = idx;
}

void thinkos_mutex_free_svc(int32_t * arg)
{
 8002e4e:	b510      	push	{r4, lr}
 8002e50:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_MUTEX_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_MUTEX_MAX) {
 8002e52:	d805      	bhi.n	8002e60 <thinkos_mutex_free_svc+0x18>
 8002e54:	4a06      	ldr	r2, [pc, #24]	; (8002e70 <thinkos_mutex_free_svc+0x28>)
 8002e56:	0152      	lsls	r2, r2, #5
 8002e58:	2100      	movs	r1, #0
 8002e5a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8002e5e:	bd10      	pop	{r4, pc}
		DCC_LOG1(LOG_ERROR, "object %d is not a mutex!", wq);
 8002e60:	4804      	ldr	r0, [pc, #16]	; (8002e74 <thinkos_mutex_free_svc+0x2c>)
 8002e62:	f001 fad7 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002e66:	f06f 0302 	mvn.w	r3, #2
 8002e6a:	6023      	str	r3, [r4, #0]
		return;
 8002e6c:	bd10      	pop	{r4, pc}
 8002e6e:	bf00      	nop
 8002e70:	21100c78 	.word	0x21100c78
 8002e74:	40000440 	.word	0x40000440

08002e78 <thinkos_mutex_lock_svc>:
}
#endif

void thinkos_mutex_lock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8002e78:	6802      	ldr	r2, [r0, #0]
	__bit_mem_wr(thinkos_rt.mutex_alloc, idx, 0);
}
#endif

void thinkos_mutex_lock_svc(int32_t * arg)
{
 8002e7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002e7c:	4b25      	ldr	r3, [pc, #148]	; (8002f14 <thinkos_mutex_lock_svc+0x9c>)
#endif

void thinkos_mutex_lock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
 8002e7e:	1e94      	subs	r4, r2, #2
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002e80:	2c4f      	cmp	r4, #79	; 0x4f
	__bit_mem_wr(thinkos_rt.mutex_alloc, idx, 0);
}
#endif

void thinkos_mutex_lock_svc(int32_t * arg)
{
 8002e82:	4605      	mov	r5, r0
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002e84:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002e88:	d828      	bhi.n	8002edc <thinkos_mutex_lock_svc+0x64>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002e8a:	4923      	ldr	r1, [pc, #140]	; (8002f18 <thinkos_mutex_lock_svc+0xa0>)
	return bit_addr[bit];
 8002e8c:	0149      	lsls	r1, r1, #5
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
 8002e8e:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8002e92:	b359      	cbz	r1, 8002eec <thinkos_mutex_lock_svc+0x74>
		return;
	}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
 8002e94:	191c      	adds	r4, r3, r4
 8002e96:	f994 1b4c 	ldrsb.w	r1, [r4, #2892]	; 0xb4c
 8002e9a:	f1b1 3fff 	cmp.w	r1, #4294967295
 8002e9e:	d02d      	beq.n	8002efc <thinkos_mutex_lock_svc+0x84>
		return;
	}

#if THINKOS_ENABLE_DEADLOCK_CHECK
	/* Sanity check: the current thread already owns the lock */
	if (thinkos_rt.lock[mutex] == self) {
 8002ea0:	4281      	cmp	r1, r0
 8002ea2:	d030      	beq.n	8002f06 <thinkos_mutex_lock_svc+0x8e>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002ea4:	f103 7188 	add.w	r1, r3, #17825792	; 0x1100000
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 8002ea8:	f102 0622 	add.w	r6, r2, #34	; 0x22
 8002eac:	eb01 0686 	add.w	r6, r1, r6, lsl #2
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 8002eb0:	181b      	adds	r3, r3, r0
	bit_addr[bit] = val;
 8002eb2:	0176      	lsls	r6, r6, #5
 8002eb4:	0052      	lsls	r2, r2, #1
 8002eb6:	2701      	movs	r7, #1
 8002eb8:	f846 7020 	str.w	r7, [r6, r0, lsl #2]
 8002ebc:	f883 26d0 	strb.w	r2, [r3, #1744]	; 0x6d0
 8002ec0:	4b16      	ldr	r3, [pc, #88]	; (8002f1c <thinkos_mutex_lock_svc+0xa4>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8002ec2:	f44f 416d 	mov.w	r1, #60672	; 0xed00
 8002ec6:	015b      	lsls	r3, r3, #5
#endif
	/* insert into the mutex wait queue */
	__thinkos_wq_insert(wq, self);
	DCC_LOG2(LOG_MSG , "<%d> waiting on mutex %d...", self, wq);

	arg[0] = 0;
 8002ec8:	2400      	movs	r4, #0
 8002eca:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8002ece:	602c      	str	r4, [r5, #0]
 8002ed0:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
 8002ed4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002ed8:	604b      	str	r3, [r1, #4]
 8002eda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8002edc:	4810      	ldr	r0, [pc, #64]	; (8002f20 <thinkos_mutex_lock_svc+0xa8>)
 8002ede:	4611      	mov	r1, r2
 8002ee0:	f001 fa98 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002ee4:	f06f 0302 	mvn.w	r3, #2
 8002ee8:	602b      	str	r3, [r5, #0]
		return;
 8002eea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8002eec:	480d      	ldr	r0, [pc, #52]	; (8002f24 <thinkos_mutex_lock_svc+0xac>)
 8002eee:	4611      	mov	r1, r2
 8002ef0:	f001 fa90 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002ef4:	f06f 0302 	mvn.w	r3, #2
 8002ef8:	602b      	str	r3, [r5, #0]
		return;
 8002efa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif

	if (thinkos_rt.lock[mutex] == -1) {
		thinkos_rt.lock[mutex] = self;
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked", self, wq);
		arg[0] = 0;
 8002efc:	2300      	movs	r3, #0
	}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
		thinkos_rt.lock[mutex] = self;
 8002efe:	f884 0b4c 	strb.w	r0, [r4, #2892]	; 0xb4c
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked", self, wq);
		arg[0] = 0;
 8002f02:	602b      	str	r3, [r5, #0]
		return;
 8002f04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

#if THINKOS_ENABLE_DEADLOCK_CHECK
	/* Sanity check: the current thread already owns the lock */
	if (thinkos_rt.lock[mutex] == self) {
		DCC_LOG2(LOG_WARNING, "<%d> mutex %d, possible deadlock!", self, wq);
 8002f06:	4808      	ldr	r0, [pc, #32]	; (8002f28 <thinkos_mutex_lock_svc+0xb0>)
 8002f08:	f001 fab2 	bl	8004470 <ice_trace2>
		arg[0] = THINKOS_EDEADLK;
 8002f0c:	f06f 0304 	mvn.w	r3, #4
 8002f10:	602b      	str	r3, [r5, #0]
		return;
 8002f12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002f14:	20000088 	.word	0x20000088
 8002f18:	21100c78 	.word	0x21100c78
 8002f1c:	21100110 	.word	0x21100110
 8002f20:	40000450 	.word	0x40000450
 8002f24:	40000460 	.word	0x40000460
 8002f28:	40000470 	.word	0x40000470

08002f2c <thinkos_mutex_trylock_svc>:
	__thinkos_wait(self);
}

void thinkos_mutex_trylock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8002f2c:	6801      	ldr	r1, [r0, #0]
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002f2e:	4a16      	ldr	r2, [pc, #88]	; (8002f88 <thinkos_mutex_trylock_svc+0x5c>)
	/* wait for event */
	__thinkos_wait(self);
}

void thinkos_mutex_trylock_svc(int32_t * arg)
{
 8002f30:	b538      	push	{r3, r4, r5, lr}
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
 8002f32:	1e8b      	subs	r3, r1, #2
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002f34:	2b4f      	cmp	r3, #79	; 0x4f
	/* wait for event */
	__thinkos_wait(self);
}

void thinkos_mutex_trylock_svc(int32_t * arg)
{
 8002f36:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002f38:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002f3c:	d811      	bhi.n	8002f62 <thinkos_mutex_trylock_svc+0x36>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002f3e:	4d13      	ldr	r5, [pc, #76]	; (8002f8c <thinkos_mutex_trylock_svc+0x60>)
	return bit_addr[bit];
 8002f40:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
 8002f42:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
 8002f46:	b19d      	cbz	r5, 8002f70 <thinkos_mutex_trylock_svc+0x44>
		return;
	}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
 8002f48:	18d3      	adds	r3, r2, r3
 8002f4a:	f993 1b4c 	ldrsb.w	r1, [r3, #2892]	; 0xb4c
 8002f4e:	1c4a      	adds	r2, r1, #1
 8002f50:	d015      	beq.n	8002f7e <thinkos_mutex_trylock_svc+0x52>
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked.", self, wq);
		thinkos_rt.lock[mutex] = self;
		arg[0] = 0;
	} else {
#if THINKOS_ENABLE_DEADLOCK_CHECK
		if (thinkos_rt.lock[mutex] == self) {
 8002f52:	4281      	cmp	r1, r0
			DCC_LOG2(LOG_MSG, "<%d> mutex %d deadlock.", self, wq);
			arg[0] = THINKOS_EDEADLK;
 8002f54:	bf0c      	ite	eq
 8002f56:	f06f 0304 	mvneq.w	r3, #4
		} else
#endif
		{
			DCC_LOG2(LOG_MSG, "<%d> mutex %d busy...", self, wq);
			arg[0] = THINKOS_EAGAIN;
 8002f5a:	f06f 0303 	mvnne.w	r3, #3
 8002f5e:	6023      	str	r3, [r4, #0]
 8002f60:	bd38      	pop	{r3, r4, r5, pc}
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8002f62:	480b      	ldr	r0, [pc, #44]	; (8002f90 <thinkos_mutex_trylock_svc+0x64>)
 8002f64:	f001 fa56 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002f68:	f06f 0302 	mvn.w	r3, #2
 8002f6c:	6023      	str	r3, [r4, #0]
		return;
 8002f6e:	bd38      	pop	{r3, r4, r5, pc}
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8002f70:	4808      	ldr	r0, [pc, #32]	; (8002f94 <thinkos_mutex_trylock_svc+0x68>)
 8002f72:	f001 fa4f 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8002f76:	f06f 0302 	mvn.w	r3, #2
 8002f7a:	6023      	str	r3, [r4, #0]
		return;
 8002f7c:	bd38      	pop	{r3, r4, r5, pc}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked.", self, wq);
		thinkos_rt.lock[mutex] = self;
 8002f7e:	f883 0b4c 	strb.w	r0, [r3, #2892]	; 0xb4c
		arg[0] = 0;
 8002f82:	2300      	movs	r3, #0
 8002f84:	6023      	str	r3, [r4, #0]
 8002f86:	bd38      	pop	{r3, r4, r5, pc}
 8002f88:	20000088 	.word	0x20000088
 8002f8c:	21100c78 	.word	0x21100c78
 8002f90:	40000480 	.word	0x40000480
 8002f94:	40000490 	.word	0x40000490

08002f98 <thinkos_mutex_timedlock_svc>:
	}
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_mutex_timedlock_svc(int32_t * arg)
{
 8002f98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
 8002f9c:	e890 0042 	ldmia.w	r0, {r1, r6}
	}
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_mutex_timedlock_svc(int32_t * arg)
{
 8002fa0:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002fa2:	4b2d      	ldr	r3, [pc, #180]	; (8003058 <thinkos_mutex_timedlock_svc+0xc0>)
#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_mutex_timedlock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
 8002fa4:	1e88      	subs	r0, r1, #2
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002fa6:	284f      	cmp	r0, #79	; 0x4f
void thinkos_mutex_timedlock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8002fa8:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8002fac:	d838      	bhi.n	8003020 <thinkos_mutex_timedlock_svc+0x88>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002fae:	4d2b      	ldr	r5, [pc, #172]	; (800305c <thinkos_mutex_timedlock_svc+0xc4>)
	return bit_addr[bit];
 8002fb0:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(&thinkos_rt.mutex_alloc, mutex) == 0) {
 8002fb2:	f855 5020 	ldr.w	r5, [r5, r0, lsl #2]
 8002fb6:	2d00      	cmp	r5, #0
 8002fb8:	d03f      	beq.n	800303a <thinkos_mutex_timedlock_svc+0xa2>
		return;
	}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
 8002fba:	1818      	adds	r0, r3, r0
 8002fbc:	f990 5b4c 	ldrsb.w	r5, [r0, #2892]	; 0xb4c
 8002fc0:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002fc4:	d041      	beq.n	800304a <thinkos_mutex_timedlock_svc+0xb2>
		return;
	}

#if THINKOS_ENABLE_DEADLOCK_CHECK
	/* Sanity check: the current thread already owns the lock */
	if (thinkos_rt.lock[mutex] == self) {
 8002fc6:	4295      	cmp	r5, r2
 8002fc8:	d032      	beq.n	8003030 <thinkos_mutex_timedlock_svc+0x98>

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 8002fca:	f8d3 86f0 	ldr.w	r8, [r3, #1776]	; 0x6f0
 8002fce:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 8002fd2:	4446      	add	r6, r8
 8002fd4:	f8cc 66f4 	str.w	r6, [ip, #1780]	; 0x6f4
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002fd8:	f103 7088 	add.w	r0, r3, #17825792	; 0x1100000
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 8002fdc:	f101 0722 	add.w	r7, r1, #34	; 0x22
	bit_addr[bit] = val;
 8002fe0:	4e1f      	ldr	r6, [pc, #124]	; (8003060 <thinkos_mutex_timedlock_svc+0xc8>)
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8002fe2:	eb00 0787 	add.w	r7, r0, r7, lsl #2
	bit_addr[bit] = val;
 8002fe6:	2501      	movs	r5, #1
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 8002fe8:	189b      	adds	r3, r3, r2
 8002fea:	017f      	lsls	r7, r7, #5
 8002fec:	0049      	lsls	r1, r1, #1
 8002fee:	0176      	lsls	r6, r6, #5
 8002ff0:	1949      	adds	r1, r1, r5
 8002ff2:	f847 5022 	str.w	r5, [r7, r2, lsl #2]
 8002ff6:	f846 5022 	str.w	r5, [r6, r2, lsl #2]
 8002ffa:	f883 16d0 	strb.w	r1, [r3, #1744]	; 0x6d0
	__thinkos_tmdwq_insert(wq, self, ms);
	DCC_LOG2(LOG_MSG, "<%d> waiting on mutex %d...", self, wq);

	/* Set the default return value to timeout. The
	   mutex_unlock() call will change this to 0 */
	arg[0] = THINKOS_ETIMEDOUT;
 8002ffe:	f04f 33ff 	mov.w	r3, #4294967295
 8003002:	6023      	str	r3, [r4, #0]
 8003004:	4b17      	ldr	r3, [pc, #92]	; (8003064 <thinkos_mutex_timedlock_svc+0xcc>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003006:	f44f 406d 	mov.w	r0, #60672	; 0xed00
 800300a:	015b      	lsls	r3, r3, #5
 800300c:	f2ce 0000 	movt	r0, #57344	; 0xe000
 8003010:	2100      	movs	r1, #0
 8003012:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8003016:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800301a:	6043      	str	r3, [r0, #4]
 800301c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8003020:	4811      	ldr	r0, [pc, #68]	; (8003068 <thinkos_mutex_timedlock_svc+0xd0>)
 8003022:	f001 f9f7 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003026:	f06f 0302 	mvn.w	r3, #2
 800302a:	6023      	str	r3, [r4, #0]
		return;
 800302c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

#if THINKOS_ENABLE_DEADLOCK_CHECK
	/* Sanity check: the current thread already owns the lock */
	if (thinkos_rt.lock[mutex] == self) {
		arg[0] = THINKOS_EDEADLK;
 8003030:	f06f 0304 	mvn.w	r3, #4
 8003034:	6023      	str	r3, [r4, #0]
		return;
 8003036:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(&thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 800303a:	480c      	ldr	r0, [pc, #48]	; (800306c <thinkos_mutex_timedlock_svc+0xd4>)
 800303c:	f001 f9ea 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003040:	f06f 0302 	mvn.w	r3, #2
 8003044:	6023      	str	r3, [r4, #0]
		return;
 8003046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#endif

	if (thinkos_rt.lock[mutex] == -1) {
		thinkos_rt.lock[mutex] = self;
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked.", self, wq);
		arg[0] = 0;
 800304a:	2300      	movs	r3, #0
	}
#endif
#endif

	if (thinkos_rt.lock[mutex] == -1) {
		thinkos_rt.lock[mutex] = self;
 800304c:	f880 2b4c 	strb.w	r2, [r0, #2892]	; 0xb4c
		DCC_LOG2(LOG_MSG, "<%d> mutex %d locked.", self, wq);
		arg[0] = 0;
 8003050:	6023      	str	r3, [r4, #0]
		return;
 8003052:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003056:	bf00      	nop
 8003058:	20000088 	.word	0x20000088
 800305c:	21100c78 	.word	0x21100c78
 8003060:	21100114 	.word	0x21100114
 8003064:	21100110 	.word	0x21100110
 8003068:	400004a0 	.word	0x400004a0
 800306c:	400004b0 	.word	0x400004b0

08003070 <thinkos_mutex_unlock_svc>:
#endif


void thinkos_mutex_unlock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8003070:	6802      	ldr	r2, [r0, #0]
}
#endif


void thinkos_mutex_unlock_svc(int32_t * arg)
{
 8003072:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 8003074:	4c2c      	ldr	r4, [pc, #176]	; (8003128 <thinkos_mutex_unlock_svc+0xb8>)


void thinkos_mutex_unlock_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
 8003076:	1e93      	subs	r3, r2, #2
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8003078:	2b4f      	cmp	r3, #79	; 0x4f
}
#endif


void thinkos_mutex_unlock_svc(int32_t * arg)
{
 800307a:	4605      	mov	r5, r0
	unsigned int wq = arg[0];
	unsigned int mutex = wq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 800307c:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 8003080:	d83e      	bhi.n	8003100 <thinkos_mutex_unlock_svc+0x90>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003082:	482a      	ldr	r0, [pc, #168]	; (800312c <thinkos_mutex_unlock_svc+0xbc>)
	return bit_addr[bit];
 8003084:	0140      	lsls	r0, r0, #5
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
 8003086:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 800308a:	2800      	cmp	r0, #0
 800308c:	d040      	beq.n	8003110 <thinkos_mutex_unlock_svc+0xa0>
#endif
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
 800308e:	18e0      	adds	r0, r4, r3
 8003090:	f990 3b4c 	ldrsb.w	r3, [r0, #2892]	; 0xb4c
 8003094:	428b      	cmp	r3, r1
 8003096:	d12c      	bne.n	80030f2 <thinkos_mutex_unlock_svc+0x82>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003098:	3222      	adds	r2, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 800309a:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 800309e:	fa91 f1a1 	rbit	r1, r1
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80030a2:	fab1 f181 	clz	r1, r1
		return;
	}

	DCC_LOG2(LOG_MSG, "<%d> mutex %d unlocked.", self, wq);

	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
 80030a6:	2920      	cmp	r1, #32
 80030a8:	d03a      	beq.n	8003120 <thinkos_mutex_unlock_svc+0xb0>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80030aa:	f104 7388 	add.w	r3, r4, #17825792	; 0x1100000
	bit_addr[bit] = val;
 80030ae:	4f20      	ldr	r7, [pc, #128]	; (8003130 <thinkos_mutex_unlock_svc+0xc0>)
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80030b0:	f854 6021 	ldr.w	r6, [r4, r1, lsl #2]
		   the lock */
		DCC_LOG2(LOG_MSG, "<%d> mutex %d released", self, wq);
		thinkos_rt.lock[mutex] = -1;
	} else {
		/* set the mutex ownership to the new thread */
		thinkos_rt.lock[mutex] = th;
 80030b4:	f880 1b4c 	strb.w	r1, [r0, #2892]	; 0xb4c
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80030b8:	eb03 0282 	add.w	r2, r3, r2, lsl #2
	bit_addr[bit] = val;
 80030bc:	0152      	lsls	r2, r2, #5
 80030be:	017f      	lsls	r7, r7, #5
 80030c0:	2300      	movs	r3, #0
 80030c2:	f04f 0c01 	mov.w	ip, #1
 80030c6:	f847 c021 	str.w	ip, [r7, r1, lsl #2]
 80030ca:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 80030ce:	4a19      	ldr	r2, [pc, #100]	; (8003134 <thinkos_mutex_unlock_svc+0xc4>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80030d0:	f44f 406d 	mov.w	r0, #60672	; 0xed00
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80030d4:	1864      	adds	r4, r4, r1
 80030d6:	0152      	lsls	r2, r2, #5

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80030d8:	f2ce 0000 	movt	r0, #57344	; 0xe000
 80030dc:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80030e0:	6233      	str	r3, [r6, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80030e2:	f884 36d0 	strb.w	r3, [r4, #1744]	; 0x6d0

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80030e6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80030ea:	6043      	str	r3, [r0, #4]
		__thinkos_wakeup(wq, th);
		/* signal the scheduler ... */
		__thinkos_defer_sched();
	}

	arg[0] = 0;
 80030ec:	2300      	movs	r3, #0
 80030ee:	602b      	str	r3, [r5, #0]
 80030f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
		DCC_LOG3(LOG_ERROR, "<%d> mutex %d is locked by <%d>!", 
 80030f2:	4811      	ldr	r0, [pc, #68]	; (8003138 <thinkos_mutex_unlock_svc+0xc8>)
 80030f4:	f001 f9f0 	bl	80044d8 <ice_trace3>
				 self, wq, thinkos_rt.lock[mutex]);
		arg[0] = THINKOS_EPERM;
 80030f8:	f06f 0305 	mvn.w	r3, #5
 80030fc:	602b      	str	r3, [r5, #0]
		return;
 80030fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8003100:	480e      	ldr	r0, [pc, #56]	; (800313c <thinkos_mutex_unlock_svc+0xcc>)
 8003102:	4611      	mov	r1, r2
 8003104:	f001 f986 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003108:	f06f 0302 	mvn.w	r3, #2
 800310c:	602b      	str	r3, [r5, #0]
		return;
 800310e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", wq);
 8003110:	480b      	ldr	r0, [pc, #44]	; (8003140 <thinkos_mutex_unlock_svc+0xd0>)
 8003112:	4611      	mov	r1, r2
 8003114:	f001 f97e 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003118:	f06f 0302 	mvn.w	r3, #2
 800311c:	602b      	str	r3, [r5, #0]
		return;
 800311e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
		/* no threads waiting on the lock, just release
		   the lock */
		DCC_LOG2(LOG_MSG, "<%d> mutex %d released", self, wq);
		thinkos_rt.lock[mutex] = -1;
 8003120:	23ff      	movs	r3, #255	; 0xff
 8003122:	f880 3b4c 	strb.w	r3, [r0, #2892]	; 0xb4c
 8003126:	e7e1      	b.n	80030ec <thinkos_mutex_unlock_svc+0x7c>
 8003128:	20000088 	.word	0x20000088
 800312c:	21100c78 	.word	0x21100c78
 8003130:	21100110 	.word	0x21100110
 8003134:	21100114 	.word	0x21100114
 8003138:	400004e0 	.word	0x400004e0
 800313c:	400004c0 	.word	0x400004c0
 8003140:	400004d0 	.word	0x400004d0

08003144 <thinkos_cond_alloc_svc>:

#if THINKOS_COND_MAX > 0

#if THINKOS_ENABLE_COND_ALLOC
void thinkos_cond_alloc_svc(int32_t * arg)
{
 8003144:	b510      	push	{r4, lr}
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.cond_alloc, 
 8003146:	2150      	movs	r1, #80	; 0x50

#if THINKOS_COND_MAX > 0

#if THINKOS_ENABLE_COND_ALLOC
void thinkos_cond_alloc_svc(int32_t * arg)
{
 8003148:	4604      	mov	r4, r0
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.cond_alloc, 
 800314a:	4805      	ldr	r0, [pc, #20]	; (8003160 <thinkos_cond_alloc_svc+0x1c>)
 800314c:	f7fe fe40 	bl	8001dd0 <thinkos_bmp_alloc>
 8003150:	2800      	cmp	r0, #0
 8003152:	db02      	blt.n	800315a <thinkos_cond_alloc_svc+0x16>
								 THINKOS_COND_MAX)) >= 0) {
		wq = idx + THINKOS_COND_BASE;
 8003154:	3052      	adds	r0, #82	; 0x52
		DCC_LOG2(LOG_INFO, "cond=%d wq=%d", idx, wq);
		arg[0] = wq;
 8003156:	6020      	str	r0, [r4, #0]
 8003158:	bd10      	pop	{r4, pc}
	} else
		arg[0] = idx;
 800315a:	6020      	str	r0, [r4, #0]
 800315c:	bd10      	pop	{r4, pc}
 800315e:	bf00      	nop
 8003160:	20000c84 	.word	0x20000c84

08003164 <thinkos_cond_free_svc>:
}

void thinkos_cond_free_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8003164:	6801      	ldr	r1, [r0, #0]
	unsigned int cond = wq - THINKOS_COND_BASE;
 8003166:	f1a1 0352 	sub.w	r3, r1, #82	; 0x52

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 800316a:	2b4f      	cmp	r3, #79	; 0x4f
	} else
		arg[0] = idx;
}

void thinkos_cond_free_svc(int32_t * arg)
{
 800316c:	b510      	push	{r4, lr}
 800316e:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int cond = wq - THINKOS_COND_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 8003170:	d805      	bhi.n	800317e <thinkos_cond_free_svc+0x1a>
 8003172:	4a06      	ldr	r2, [pc, #24]	; (800318c <thinkos_cond_free_svc+0x28>)
 8003174:	0152      	lsls	r2, r2, #5
 8003176:	2100      	movs	r1, #0
 8003178:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 800317c:	bd10      	pop	{r4, pc}
		DCC_LOG1(LOG_ERROR, "object %d is conditional variable!", wq);
 800317e:	4804      	ldr	r0, [pc, #16]	; (8003190 <thinkos_cond_free_svc+0x2c>)
 8003180:	f001 f948 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003184:	f06f 0302 	mvn.w	r3, #2
 8003188:	6023      	str	r3, [r4, #0]
		return;
 800318a:	bd10      	pop	{r4, pc}
 800318c:	21100c84 	.word	0x21100c84
 8003190:	400004f0 	.word	0x400004f0

08003194 <thinkos_cond_wait_svc>:
	__bit_mem_wr(thinkos_rt.cond_alloc, cond, 0);
}
#endif

void thinkos_cond_wait_svc(int32_t * arg)
{
 8003194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003198:	4604      	mov	r4, r0
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 800319a:	4846      	ldr	r0, [pc, #280]	; (80032b4 <thinkos_cond_wait_svc+0x120>)
}
#endif

void thinkos_cond_wait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
 800319c:	6825      	ldr	r5, [r4, #0]
	unsigned int mwq = arg[1];
 800319e:	6862      	ldr	r2, [r4, #4]
	unsigned int cond = cwq - THINKOS_COND_BASE;
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
	int self = thinkos_rt.active;
 80031a0:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84

void thinkos_cond_wait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
 80031a4:	f1a5 0652 	sub.w	r6, r5, #82	; 0x52
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
 80031a8:	1e93      	subs	r3, r2, #2
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 80031aa:	2e4f      	cmp	r6, #79	; 0x4f
 80031ac:	d84e      	bhi.n	800324c <thinkos_cond_wait_svc+0xb8>
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (mutex >= THINKOS_MUTEX_MAX) {
 80031ae:	2b4f      	cmp	r3, #79	; 0x4f
 80031b0:	d865      	bhi.n	800327e <thinkos_cond_wait_svc+0xea>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80031b2:	4f41      	ldr	r7, [pc, #260]	; (80032b8 <thinkos_cond_wait_svc+0x124>)
	return bit_addr[bit];
 80031b4:	017f      	lsls	r7, r7, #5
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
 80031b6:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
 80031ba:	2e00      	cmp	r6, #0
 80031bc:	d04f      	beq.n	800325e <thinkos_cond_wait_svc+0xca>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80031be:	4e3f      	ldr	r6, [pc, #252]	; (80032bc <thinkos_cond_wait_svc+0x128>)
	return bit_addr[bit];
 80031c0:	0176      	lsls	r6, r6, #5
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
 80031c2:	f856 6023 	ldr.w	r6, [r6, r3, lsl #2]
 80031c6:	2e00      	cmp	r6, #0
 80031c8:	d06a      	beq.n	80032a0 <thinkos_cond_wait_svc+0x10c>
#endif
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
 80031ca:	18c6      	adds	r6, r0, r3
 80031cc:	f996 3b4c 	ldrsb.w	r3, [r6, #2892]	; 0xb4c
 80031d0:	428b      	cmp	r3, r1
 80031d2:	d15d      	bne.n	8003290 <thinkos_cond_wait_svc+0xfc>
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 80031d4:	f105 0122 	add.w	r1, r5, #34	; 0x22
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80031d8:	f100 7c88 	add.w	ip, r0, #17825792	; 0x1100000
 80031dc:	eb0c 0181 	add.w	r1, ip, r1, lsl #2
	bit_addr[bit] = val;
 80031e0:	0149      	lsls	r1, r1, #5
 80031e2:	2701      	movs	r7, #1
 80031e4:	f841 7023 	str.w	r7, [r1, r3, lsl #2]
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 80031e8:	3222      	adds	r2, #34	; 0x22
static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 80031ea:	18c1      	adds	r1, r0, r3
 80031ec:	fa05 f507 	lsl.w	r5, r5, r7
 80031f0:	f881 56d0 	strb.w	r5, [r1, #1744]	; 0x6d0
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80031f4:	f850 1022 	ldr.w	r1, [r0, r2, lsl #2]
 80031f8:	fa91 f1a1 	rbit	r1, r1
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80031fc:	fab1 f181 	clz	r1, r1
	__thinkos_wq_insert(cwq, self);
	DCC_LOG3(LOG_INFO, "<%d> mutex %d unlocked, waiting on cond %d...", 
			 self, mwq, cwq);

	/* check for threads wating on the mutex wait queue */
	if ((th = __thinkos_wq_head(mwq)) == THINKOS_THREAD_NULL) {
 8003200:	2920      	cmp	r1, #32
 8003202:	d035      	beq.n	8003270 <thinkos_cond_wait_svc+0xdc>
		   the lock */
		DCC_LOG2(LOG_INFO, "<%d> mutex %d released", self, mwq);
		thinkos_rt.lock[mutex] = -1;
	} else {
		/* set the mutex ownership to the new thread */
		thinkos_rt.lock[mutex] = th;
 8003204:	f886 1b4c 	strb.w	r1, [r6, #2892]	; 0xb4c
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003208:	4e2d      	ldr	r6, [pc, #180]	; (80032c0 <thinkos_cond_wait_svc+0x12c>)
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800320a:	f850 8021 	ldr.w	r8, [r0, r1, lsl #2]
 800320e:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
	bit_addr[bit] = val;
 8003212:	0152      	lsls	r2, r2, #5
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003214:	0176      	lsls	r6, r6, #5
	bit_addr[bit] = val;
 8003216:	2500      	movs	r5, #0
 8003218:	f846 7021 	str.w	r7, [r6, r1, lsl #2]
 800321c:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 8003220:	4a28      	ldr	r2, [pc, #160]	; (80032c4 <thinkos_cond_wait_svc+0x130>)
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003222:	1840      	adds	r0, r0, r1
 8003224:	0152      	lsls	r2, r2, #5
 8003226:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 800322a:	f8c8 5020 	str.w	r5, [r8, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800322e:	f880 56d0 	strb.w	r5, [r0, #1744]	; 0x6d0

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003232:	f44f 426d 	mov.w	r2, #60672	; 0xed00
		DCC_LOG2(LOG_INFO, "<%d> mutex %d locked", th, mwq);
		/* wakeup from the mutex wait queue */
		__thinkos_wakeup(mwq, th);
	}

	arg[0] = 0;
 8003236:	2100      	movs	r1, #0
 8003238:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800323c:	6021      	str	r1, [r4, #0]
 800323e:	f846 1023 	str.w	r1, [r6, r3, lsl #2]
 8003242:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003246:	6053      	str	r3, [r2, #4]
 8003248:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 800324c:	481e      	ldr	r0, [pc, #120]	; (80032c8 <thinkos_cond_wait_svc+0x134>)
 800324e:	4629      	mov	r1, r5
 8003250:	f001 f8e0 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003254:	f06f 0302 	mvn.w	r3, #2
 8003258:	6023      	str	r3, [r4, #0]
		return;
 800325a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 800325e:	481b      	ldr	r0, [pc, #108]	; (80032cc <thinkos_cond_wait_svc+0x138>)
 8003260:	4629      	mov	r1, r5
 8003262:	f001 f8d7 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003266:	f06f 0302 	mvn.w	r3, #2
 800326a:	6023      	str	r3, [r4, #0]
		return;
 800326c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	/* check for threads wating on the mutex wait queue */
	if ((th = __thinkos_wq_head(mwq)) == THINKOS_THREAD_NULL) {
		/* no threads waiting on the lock, just release
		   the lock */
		DCC_LOG2(LOG_INFO, "<%d> mutex %d released", self, mwq);
		thinkos_rt.lock[mutex] = -1;
 8003270:	22ff      	movs	r2, #255	; 0xff
 8003272:	f886 2b4c 	strb.w	r2, [r6, #2892]	; 0xb4c
 8003276:	f10c 0688 	add.w	r6, ip, #136	; 0x88
 800327a:	0176      	lsls	r6, r6, #5
 800327c:	e7d9      	b.n	8003232 <thinkos_cond_wait_svc+0x9e>
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
 800327e:	4814      	ldr	r0, [pc, #80]	; (80032d0 <thinkos_cond_wait_svc+0x13c>)
 8003280:	4611      	mov	r1, r2
 8003282:	f001 f8c7 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003286:	f06f 0302 	mvn.w	r3, #2
 800328a:	6023      	str	r3, [r4, #0]
		return;
 800328c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
		DCC_LOG3(LOG_WARNING, "<%d> mutex %d is locked by <%d>", 
 8003290:	4810      	ldr	r0, [pc, #64]	; (80032d4 <thinkos_cond_wait_svc+0x140>)
 8003292:	f001 f921 	bl	80044d8 <ice_trace3>
				 self, mwq, thinkos_rt.lock[mutex]);
		arg[0] = THINKOS_EPERM;
 8003296:	f06f 0305 	mvn.w	r3, #5
 800329a:	6023      	str	r3, [r4, #0]
		return;
 800329c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return;
	}
#endif
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
 80032a0:	480d      	ldr	r0, [pc, #52]	; (80032d8 <thinkos_cond_wait_svc+0x144>)
 80032a2:	4611      	mov	r1, r2
 80032a4:	f001 f8b6 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80032a8:	f06f 0302 	mvn.w	r3, #2
 80032ac:	6023      	str	r3, [r4, #0]
		return;
 80032ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80032b2:	bf00      	nop
 80032b4:	20000088 	.word	0x20000088
 80032b8:	21100c84 	.word	0x21100c84
 80032bc:	21100c78 	.word	0x21100c78
 80032c0:	21100110 	.word	0x21100110
 80032c4:	21100114 	.word	0x21100114
 80032c8:	40000500 	.word	0x40000500
 80032cc:	40000520 	.word	0x40000520
 80032d0:	40000510 	.word	0x40000510
 80032d4:	40000540 	.word	0x40000540
 80032d8:	40000530 	.word	0x40000530

080032dc <thinkos_cond_timedwait_svc>:
#endif


#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_cond_timedwait_svc(int32_t * arg)
{
 80032dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032e0:	4604      	mov	r4, r0
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
	uint32_t ms = (uint32_t)arg[2];
	int self = thinkos_rt.active;
 80032e2:	484f      	ldr	r0, [pc, #316]	; (8003420 <thinkos_cond_timedwait_svc+0x144>)

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_cond_timedwait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
 80032e4:	6862      	ldr	r2, [r4, #4]


#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_cond_timedwait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
 80032e6:	6825      	ldr	r5, [r4, #0]
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
	uint32_t ms = (uint32_t)arg[2];
 80032e8:	f8d4 c008 	ldr.w	ip, [r4, #8]
	int self = thinkos_rt.active;
 80032ec:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
void thinkos_cond_timedwait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	unsigned int mutex = mwq - THINKOS_MUTEX_BASE;
 80032f0:	1e93      	subs	r3, r2, #2
	uint32_t ms = (uint32_t)arg[2];
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 80032f2:	2b4f      	cmp	r3, #79	; 0x4f
#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_cond_timedwait_svc(int32_t * arg)
{
	unsigned int cwq = arg[0];
	unsigned int mwq = arg[1];
	unsigned int cond = cwq - THINKOS_COND_BASE;
 80032f4:	f1a5 0652 	sub.w	r6, r5, #82	; 0x52
	uint32_t ms = (uint32_t)arg[2];
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
 80032f8:	d85e      	bhi.n	80033b8 <thinkos_cond_timedwait_svc+0xdc>
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (cond >= THINKOS_COND_MAX) {
 80032fa:	2e4f      	cmp	r6, #79	; 0x4f
 80032fc:	d875      	bhi.n	80033ea <thinkos_cond_timedwait_svc+0x10e>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80032fe:	4f49      	ldr	r7, [pc, #292]	; (8003424 <thinkos_cond_timedwait_svc+0x148>)
	return bit_addr[bit];
 8003300:	017f      	lsls	r7, r7, #5
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
 8003302:	f857 7023 	ldr.w	r7, [r7, r3, lsl #2]
 8003306:	2f00      	cmp	r7, #0
 8003308:	d05f      	beq.n	80033ca <thinkos_cond_timedwait_svc+0xee>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800330a:	4f47      	ldr	r7, [pc, #284]	; (8003428 <thinkos_cond_timedwait_svc+0x14c>)
	return bit_addr[bit];
 800330c:	017f      	lsls	r7, r7, #5
		arg[0] = THINKOS_EINVAL;
		return;
	}
#endif
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
 800330e:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
 8003312:	2e00      	cmp	r6, #0
 8003314:	d07a      	beq.n	800340c <thinkos_cond_timedwait_svc+0x130>
#endif
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
 8003316:	18c7      	adds	r7, r0, r3
 8003318:	f997 3b4c 	ldrsb.w	r3, [r7, #2892]	; 0xb4c
 800331c:	428b      	cmp	r3, r1
 800331e:	d16d      	bne.n	80033fc <thinkos_cond_timedwait_svc+0x120>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003320:	f100 7988 	add.w	r9, r0, #17825792	; 0x1100000
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 8003324:	f105 0a22 	add.w	sl, r5, #34	; 0x22
	bit_addr[bit] = val;
 8003328:	461e      	mov	r6, r3

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 800332a:	f8d0 16f0 	ldr.w	r1, [r0, #1776]	; 0x6f0
 800332e:	eb00 0b83 	add.w	fp, r0, r3, lsl #2
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003332:	eb09 0a8a 	add.w	sl, r9, sl, lsl #2
 8003336:	f109 038c 	add.w	r3, r9, #140	; 0x8c
 800333a:	ea4f 1843 	mov.w	r8, r3, lsl #5
	bit_addr[bit] = val;
 800333e:	ea4f 1a4a 	mov.w	sl, sl, lsl #5
 8003342:	2301      	movs	r3, #1
 8003344:	4461      	add	r1, ip
 8003346:	f8cb 16f4 	str.w	r1, [fp, #1780]	; 0x6f4
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 800334a:	fa05 f503 	lsl.w	r5, r5, r3
 800334e:	f84a 3026 	str.w	r3, [sl, r6, lsl #2]
 8003352:	1981      	adds	r1, r0, r6
 8003354:	f848 3026 	str.w	r3, [r8, r6, lsl #2]
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003358:	3222      	adds	r2, #34	; 0x22
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 800335a:	18ed      	adds	r5, r5, r3
 800335c:	f881 56d0 	strb.w	r5, [r1, #1744]	; 0x6d0
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003360:	f850 1022 	ldr.w	r1, [r0, r2, lsl #2]
 8003364:	fa91 f1a1 	rbit	r1, r1
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003368:	fab1 f181 	clz	r1, r1
	__thinkos_tmdwq_insert(cwq, self, ms);
	DCC_LOG3(LOG_INFO, "<%d> mutex %d unlocked, waiting on cond %d...", 
			 self, mwq, cwq);

	/* check for threads wating on the mutex wait queue */
	if ((th = __thinkos_wq_head(mwq)) == THINKOS_THREAD_NULL) {
 800336c:	2920      	cmp	r1, #32
 800336e:	d035      	beq.n	80033dc <thinkos_cond_timedwait_svc+0x100>
		   the lock */
		DCC_LOG2(LOG_INFO, "<%d> mutex %d released", self, mwq);
		thinkos_rt.lock[mutex] = -1;
	} else {
		/* set the mutex ownership to the new thread */
		thinkos_rt.lock[mutex] = th;
 8003370:	f887 1b4c 	strb.w	r1, [r7, #2892]	; 0xb4c
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003374:	4f2d      	ldr	r7, [pc, #180]	; (800342c <thinkos_cond_timedwait_svc+0x150>)
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003376:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
 800337a:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800337e:	017f      	lsls	r7, r7, #5
	bit_addr[bit] = val;
 8003380:	0152      	lsls	r2, r2, #5
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003382:	1840      	adds	r0, r0, r1
 8003384:	2500      	movs	r5, #0
 8003386:	f847 3021 	str.w	r3, [r7, r1, lsl #2]
 800338a:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 800338e:	f848 5021 	str.w	r5, [r8, r1, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003392:	f8cc 5020 	str.w	r5, [ip, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003396:	f880 56d0 	strb.w	r5, [r0, #1744]	; 0x6d0
		__thinkos_wakeup(mwq, th);
	}

	/* Set the default return value to timeout. The
	   sem_post call will change this to 0 */
	arg[0] = THINKOS_ETIMEDOUT;
 800339a:	f04f 32ff 	mov.w	r2, #4294967295

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 800339e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80033a2:	6022      	str	r2, [r4, #0]
 80033a4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80033a8:	2200      	movs	r2, #0
 80033aa:	f847 2026 	str.w	r2, [r7, r6, lsl #2]
 80033ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80033b2:	605a      	str	r2, [r3, #4]
 80033b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int self = thinkos_rt.active;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (mutex >= THINKOS_MUTEX_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
 80033b8:	481d      	ldr	r0, [pc, #116]	; (8003430 <thinkos_cond_timedwait_svc+0x154>)
 80033ba:	4611      	mov	r1, r2
 80033bc:	f001 f82a 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80033c0:	f06f 0302 	mvn.w	r3, #2
 80033c4:	6023      	str	r3, [r4, #0]
		return;
 80033c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_MUTEX_ALLOC
	if (__bit_mem_rd(thinkos_rt.mutex_alloc, mutex) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
 80033ca:	481a      	ldr	r0, [pc, #104]	; (8003434 <thinkos_cond_timedwait_svc+0x158>)
 80033cc:	4611      	mov	r1, r2
 80033ce:	f001 f821 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80033d2:	f06f 0302 	mvn.w	r3, #2
 80033d6:	6023      	str	r3, [r4, #0]
		return;
 80033d8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	/* check for threads wating on the mutex wait queue */
	if ((th = __thinkos_wq_head(mwq)) == THINKOS_THREAD_NULL) {
		/* no threads waiting on the lock, just release
		   the lock */
		DCC_LOG2(LOG_INFO, "<%d> mutex %d released", self, mwq);
		thinkos_rt.lock[mutex] = -1;
 80033dc:	23ff      	movs	r3, #255	; 0xff
 80033de:	f887 3b4c 	strb.w	r3, [r7, #2892]	; 0xb4c
 80033e2:	f109 0788 	add.w	r7, r9, #136	; 0x88
 80033e6:	017f      	lsls	r7, r7, #5
 80033e8:	e7d7      	b.n	800339a <thinkos_cond_timedwait_svc+0xbe>
		DCC_LOG1(LOG_ERROR, "invalid mutex %d!", mwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (cond >= THINKOS_COND_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 80033ea:	4813      	ldr	r0, [pc, #76]	; (8003438 <thinkos_cond_timedwait_svc+0x15c>)
 80033ec:	4629      	mov	r1, r5
 80033ee:	f001 f811 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80033f2:	f06f 0302 	mvn.w	r3, #2
 80033f6:	6023      	str	r3, [r4, #0]
		return;
 80033f8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif

	/* sanity check: avoid unlock the mutex by a thread that 
	   does not own the lock */
	if (thinkos_rt.lock[mutex] != self) {
		DCC_LOG3(LOG_WARNING, "<%d> mutex %d is locked by <%d>", 
 80033fc:	480f      	ldr	r0, [pc, #60]	; (800343c <thinkos_cond_timedwait_svc+0x160>)
 80033fe:	f001 f86b 	bl	80044d8 <ice_trace3>
				 self, mwq, thinkos_rt.lock[mutex]);
		arg[0] = THINKOS_EPERM;
 8003402:	f06f 0305 	mvn.w	r3, #5
 8003406:	6023      	str	r3, [r4, #0]
		return;
 8003408:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;
	}
#endif
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 800340c:	480c      	ldr	r0, [pc, #48]	; (8003440 <thinkos_cond_timedwait_svc+0x164>)
 800340e:	4629      	mov	r1, r5
 8003410:	f001 f800 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003414:	f06f 0302 	mvn.w	r3, #2
 8003418:	6023      	str	r3, [r4, #0]
		return;
 800341a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800341e:	bf00      	nop
 8003420:	20000088 	.word	0x20000088
 8003424:	21100c78 	.word	0x21100c78
 8003428:	21100c84 	.word	0x21100c84
 800342c:	21100110 	.word	0x21100110
 8003430:	40000550 	.word	0x40000550
 8003434:	40000570 	.word	0x40000570
 8003438:	40000560 	.word	0x40000560
 800343c:	40000590 	.word	0x40000590
 8003440:	40000580 	.word	0x40000580

08003444 <thinkos_cond_signal_svc>:
}
#endif

void thinkos_cond_signal_svc(int32_t * arg)
{	
	unsigned int cwq = arg[0];
 8003444:	6801      	ldr	r1, [r0, #0]
	__thinkos_wait(self);
}
#endif

void thinkos_cond_signal_svc(int32_t * arg)
{	
 8003446:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int cwq = arg[0];
	unsigned int cond = cwq - THINKOS_COND_BASE;
 8003448:	f1a1 0352 	sub.w	r3, r1, #82	; 0x52
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 800344c:	2b4f      	cmp	r3, #79	; 0x4f
	__thinkos_wait(self);
}
#endif

void thinkos_cond_signal_svc(int32_t * arg)
{	
 800344e:	4604      	mov	r4, r0
	unsigned int cwq = arg[0];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 8003450:	d831      	bhi.n	80034b6 <thinkos_cond_signal_svc+0x72>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003452:	4a20      	ldr	r2, [pc, #128]	; (80034d4 <thinkos_cond_signal_svc+0x90>)
	return bit_addr[bit];
 8003454:	0152      	lsls	r2, r2, #5
		arg[0] = THINKOS_EINVAL;
		return;
	}

#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
 8003456:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800345a:	2b00      	cmp	r3, #0
 800345c:	d032      	beq.n	80034c4 <thinkos_cond_signal_svc+0x80>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 800345e:	4a1e      	ldr	r2, [pc, #120]	; (80034d8 <thinkos_cond_signal_svc+0x94>)
 8003460:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003462:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8003466:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 800346a:	fab3 f383 	clz	r3, r3
	/* XXX: NEW experimental implementation:
	   the cond_wait() and cond_timedwait() user
	   calls invoque the mutex_lock() before returning */

	/* insert all remaining threads into mutex wait queue */
	if ((th = __thinkos_wq_head(cwq)) != THINKOS_THREAD_NULL) {
 800346e:	2b20      	cmp	r3, #32
 8003470:	d01e      	beq.n	80034b0 <thinkos_cond_signal_svc+0x6c>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003472:	f102 7088 	add.w	r0, r2, #17825792	; 0x1100000
	bit_addr[bit] = val;
 8003476:	4f19      	ldr	r7, [pc, #100]	; (80034dc <thinkos_cond_signal_svc+0x98>)
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003478:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800347c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	bit_addr[bit] = val;
 8003480:	0149      	lsls	r1, r1, #5
 8003482:	017f      	lsls	r7, r7, #5
 8003484:	2000      	movs	r0, #0
 8003486:	f04f 0c01 	mov.w	ip, #1
 800348a:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
 800348e:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
 8003492:	4913      	ldr	r1, [pc, #76]	; (80034e0 <thinkos_cond_signal_svc+0x9c>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003494:	f44f 456d 	mov.w	r5, #60672	; 0xed00
 8003498:	0149      	lsls	r1, r1, #5
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800349a:	18d2      	adds	r2, r2, r3

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 800349c:	f2ce 0500 	movt	r5, #57344	; 0xe000
 80034a0:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
 80034a4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80034a8:	6230      	str	r0, [r6, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80034aa:	f882 06d0 	strb.w	r0, [r2, #1744]	; 0x6d0

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80034ae:	606b      	str	r3, [r5, #4]
			__thinkos_wq_insert(mwq, th);
			DCC_LOG2(LOG_INFO, "<%d> waiting on mutex %d...", th, mwq);
		}
	}
#endif
	arg[0] = 0;
 80034b0:	2300      	movs	r3, #0
 80034b2:	6023      	str	r3, [r4, #0]
 80034b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int cond = cwq - THINKOS_COND_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 80034b6:	480b      	ldr	r0, [pc, #44]	; (80034e4 <thinkos_cond_signal_svc+0xa0>)
 80034b8:	f000 ffac 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80034bc:	f06f 0302 	mvn.w	r3, #2
 80034c0:	6023      	str	r3, [r4, #0]
		return;
 80034c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 80034c4:	4808      	ldr	r0, [pc, #32]	; (80034e8 <thinkos_cond_signal_svc+0xa4>)
 80034c6:	f000 ffa5 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80034ca:	f06f 0302 	mvn.w	r3, #2
 80034ce:	6023      	str	r3, [r4, #0]
		return;
 80034d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80034d2:	bf00      	nop
 80034d4:	21100c84 	.word	0x21100c84
 80034d8:	20000088 	.word	0x20000088
 80034dc:	21100110 	.word	0x21100110
 80034e0:	21100114 	.word	0x21100114
 80034e4:	400005a0 	.word	0x400005a0
 80034e8:	400005b0 	.word	0x400005b0

080034ec <thinkos_cond_broadcast_svc>:
	arg[0] = 0;
}

void thinkos_cond_broadcast_svc(int32_t * arg)
{	
	unsigned int cwq = arg[0];
 80034ec:	6801      	ldr	r1, [r0, #0]
#endif
	arg[0] = 0;
}

void thinkos_cond_broadcast_svc(int32_t * arg)
{	
 80034ee:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	unsigned int cwq = arg[0];
	unsigned int cond = cwq - THINKOS_COND_BASE;
 80034f2:	f1a1 0352 	sub.w	r3, r1, #82	; 0x52
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 80034f6:	2b4f      	cmp	r3, #79	; 0x4f
#endif
	arg[0] = 0;
}

void thinkos_cond_broadcast_svc(int32_t * arg)
{	
 80034f8:	4680      	mov	r8, r0
	unsigned int cwq = arg[0];
	unsigned int cond = cwq - THINKOS_COND_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
 80034fa:	d852      	bhi.n	80035a2 <thinkos_cond_broadcast_svc+0xb6>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80034fc:	4a32      	ldr	r2, [pc, #200]	; (80035c8 <thinkos_cond_broadcast_svc+0xdc>)
	return bit_addr[bit];
 80034fe:	0152      	lsls	r2, r2, #5
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
 8003500:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003504:	2b00      	cmp	r3, #0
 8003506:	d055      	beq.n	80035b4 <thinkos_cond_broadcast_svc+0xc8>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003508:	4c30      	ldr	r4, [pc, #192]	; (80035cc <thinkos_cond_broadcast_svc+0xe0>)
 800350a:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 800350c:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 8003510:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003514:	fab3 f383 	clz	r3, r3
	/* XXX: NEW experimental implementation:
	   the cond_wait() and cond_timedwait() user
	   calls invoque the mutex_lock() before returning */

	/* insert all remaining threads into mutex wait queue */
	if ((th = __thinkos_wq_head(cwq)) != THINKOS_THREAD_NULL) {
 8003518:	2b20      	cmp	r3, #32
 800351a:	d03d      	beq.n	8003598 <thinkos_cond_broadcast_svc+0xac>
static void inline __attribute__((always_inline)) 
__thinkos_wakeup(unsigned int wq, unsigned int th) {
	/* insert the thread into ready queue */
	__bit_mem_wr(&thinkos_rt.wq_ready, th, 1);
	/* remove from the wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
 800351c:	eb04 0c81 	add.w	ip, r4, r1, lsl #2
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003520:	4f2b      	ldr	r7, [pc, #172]	; (80035d0 <thinkos_cond_broadcast_svc+0xe4>)
 8003522:	482c      	ldr	r0, [pc, #176]	; (80035d4 <thinkos_cond_broadcast_svc+0xe8>)
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003524:	f854 9023 	ldr.w	r9, [r4, r3, lsl #2]
 8003528:	f10c 7c88 	add.w	ip, ip, #17825792	; 0x1100000
 800352c:	017f      	lsls	r7, r7, #5
 800352e:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 8003532:	0140      	lsls	r0, r0, #5
	bit_addr[bit] = val;
 8003534:	2200      	movs	r2, #0
 8003536:	2501      	movs	r5, #1
 8003538:	f847 5023 	str.w	r5, [r7, r3, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800353c:	18e6      	adds	r6, r4, r3
 800353e:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
 8003542:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003546:	f8c9 2020 	str.w	r2, [r9, #32]
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 800354a:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800354e:	f886 26d0 	strb.w	r2, [r6, #1744]	; 0x6d0
 8003552:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003556:	fab3 f383 	clz	r3, r3
		DCC_LOG2(LOG_INFO, "<%d> wakeup from cond %d.", th, cwq);
		/* wakeup from the mutex wait queue */
		__thinkos_wakeup(cwq, th);
		/* insert all remaining threads into mutex wait queue */
		while ((th = __thinkos_wq_head(cwq)) != THINKOS_THREAD_NULL) {
 800355a:	2b20      	cmp	r3, #32

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 800355c:	bf18      	it	ne
 800355e:	46a9      	movne	r9, r5
 8003560:	d013      	beq.n	800358a <thinkos_cond_broadcast_svc+0x9e>
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003562:	f854 6023 	ldr.w	r6, [r4, r3, lsl #2]
 8003566:	f847 9023 	str.w	r9, [r7, r3, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800356a:	18e5      	adds	r5, r4, r3
 800356c:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
 8003570:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 8003574:	6232      	str	r2, [r6, #32]
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003576:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 800357a:	f885 26d0 	strb.w	r2, [r5, #1744]	; 0x6d0
 800357e:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003582:	fab3 f383 	clz	r3, r3
 8003586:	2b20      	cmp	r3, #32
 8003588:	d1eb      	bne.n	8003562 <thinkos_cond_broadcast_svc+0x76>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 800358a:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800358e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003592:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003596:	605a      	str	r2, [r3, #4]
			__thinkos_wq_insert(mwq, th);
			DCC_LOG2(LOG_INFO, "<%d> waiting on mutex %d...", th, mwq);
		}
	}
#endif
	arg[0] = 0;
 8003598:	2300      	movs	r3, #0
 800359a:	f8c8 3000 	str.w	r3, [r8]
 800359e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	unsigned int cond = cwq - THINKOS_COND_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (cond >= THINKOS_COND_MAX) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 80035a2:	480d      	ldr	r0, [pc, #52]	; (80035d8 <thinkos_cond_broadcast_svc+0xec>)
 80035a4:	f000 ff36 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80035a8:	f06f 0302 	mvn.w	r3, #2
 80035ac:	f8c8 3000 	str.w	r3, [r8]
		return;
 80035b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	}
#if THINKOS_ENABLE_COND_ALLOC
	if (__bit_mem_rd(thinkos_rt.cond_alloc, cond) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid conditional variable %d!", cwq);
 80035b4:	4809      	ldr	r0, [pc, #36]	; (80035dc <thinkos_cond_broadcast_svc+0xf0>)
 80035b6:	f000 ff2d 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80035ba:	f06f 0302 	mvn.w	r3, #2
 80035be:	f8c8 3000 	str.w	r3, [r8]
		return;
 80035c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80035c6:	bf00      	nop
 80035c8:	21100c84 	.word	0x21100c84
 80035cc:	20000088 	.word	0x20000088
 80035d0:	21100110 	.word	0x21100110
 80035d4:	21100114 	.word	0x21100114
 80035d8:	400005c0 	.word	0x400005c0
 80035dc:	400005d0 	.word	0x400005d0

080035e0 <thinkos_sem_alloc_svc>:

#if THINKOS_SEMAPHORE_MAX > 0

#if THINKOS_ENABLE_SEM_ALLOC
void thinkos_sem_alloc_svc(int32_t * arg)
{	
 80035e0:	b570      	push	{r4, r5, r6, lr}
 80035e2:	4604      	mov	r4, r0
	unsigned int wq;
	uint32_t value = (uint32_t)arg[0];
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
 80035e4:	2150      	movs	r1, #80	; 0x50
 80035e6:	480a      	ldr	r0, [pc, #40]	; (8003610 <thinkos_sem_alloc_svc+0x30>)

#if THINKOS_ENABLE_SEM_ALLOC
void thinkos_sem_alloc_svc(int32_t * arg)
{	
	unsigned int wq;
	uint32_t value = (uint32_t)arg[0];
 80035e8:	6825      	ldr	r5, [r4, #0]
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
 80035ea:	f7fe fbf1 	bl	8001dd0 <thinkos_bmp_alloc>
 80035ee:	1e01      	subs	r1, r0, #0
 80035f0:	da01      	bge.n	80035f6 <thinkos_sem_alloc_svc+0x16>
		thinkos_rt.sem_val[idx] = value;
		wq = idx + THINKOS_SEM_BASE;
		DCC_LOG2(LOG_TRACE, "sem=%d wq=%d", idx, wq);
		arg[0] = wq;
	} else
		arg[0] = idx;
 80035f2:	6021      	str	r1, [r4, #0]
 80035f4:	bd70      	pop	{r4, r5, r6, pc}
	uint32_t value = (uint32_t)arg[0];
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
								 THINKOS_SEMAPHORE_MAX )) >= 0) {
		thinkos_rt.sem_val[idx] = value;
 80035f6:	4b07      	ldr	r3, [pc, #28]	; (8003614 <thinkos_sem_alloc_svc+0x34>)
		wq = idx + THINKOS_SEM_BASE;
		DCC_LOG2(LOG_TRACE, "sem=%d wq=%d", idx, wq);
 80035f8:	4807      	ldr	r0, [pc, #28]	; (8003618 <thinkos_sem_alloc_svc+0x38>)
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
								 THINKOS_SEMAPHORE_MAX )) >= 0) {
		thinkos_rt.sem_val[idx] = value;
		wq = idx + THINKOS_SEM_BASE;
 80035fa:	f101 06a2 	add.w	r6, r1, #162	; 0xa2
	uint32_t value = (uint32_t)arg[0];
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
								 THINKOS_SEMAPHORE_MAX )) >= 0) {
		thinkos_rt.sem_val[idx] = value;
 80035fe:	eb03 0381 	add.w	r3, r3, r1, lsl #2
		wq = idx + THINKOS_SEM_BASE;
		DCC_LOG2(LOG_TRACE, "sem=%d wq=%d", idx, wq);
 8003602:	4632      	mov	r2, r6
	uint32_t value = (uint32_t)arg[0];
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.sem_alloc, 
								 THINKOS_SEMAPHORE_MAX )) >= 0) {
		thinkos_rt.sem_val[idx] = value;
 8003604:	f8c3 5774 	str.w	r5, [r3, #1908]	; 0x774
		wq = idx + THINKOS_SEM_BASE;
		DCC_LOG2(LOG_TRACE, "sem=%d wq=%d", idx, wq);
 8003608:	f000 ff32 	bl	8004470 <ice_trace2>
		arg[0] = wq;
 800360c:	6026      	str	r6, [r4, #0]
 800360e:	bd70      	pop	{r4, r5, r6, pc}
 8003610:	20000c90 	.word	0x20000c90
 8003614:	20000088 	.word	0x20000088
 8003618:	400005e0 	.word	0x400005e0

0800361c <thinkos_sem_free_svc>:
		arg[0] = idx;
}

void thinkos_sem_free_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
 800361c:	6801      	ldr	r1, [r0, #0]
	unsigned int idx = wq - THINKOS_SEM_BASE;
 800361e:	f1a1 03a2 	sub.w	r3, r1, #162	; 0xa2

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_SEMAPHORE_MAX) {
 8003622:	2b4f      	cmp	r3, #79	; 0x4f
	} else
		arg[0] = idx;
}

void thinkos_sem_free_svc(int32_t * arg)
{	
 8003624:	b510      	push	{r4, lr}
 8003626:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int idx = wq - THINKOS_SEM_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (idx >= THINKOS_SEMAPHORE_MAX) {
 8003628:	d805      	bhi.n	8003636 <thinkos_sem_free_svc+0x1a>

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 800362a:	4a06      	ldr	r2, [pc, #24]	; (8003644 <thinkos_sem_free_svc+0x28>)
 800362c:	0152      	lsls	r2, r2, #5
 800362e:	2100      	movs	r1, #0
 8003630:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8003634:	bd10      	pop	{r4, pc}
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 8003636:	4804      	ldr	r0, [pc, #16]	; (8003648 <thinkos_sem_free_svc+0x2c>)
 8003638:	f000 feec 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800363c:	f06f 0302 	mvn.w	r3, #2
 8003640:	6023      	str	r3, [r4, #0]
		return;
 8003642:	bd10      	pop	{r4, pc}
 8003644:	21100c90 	.word	0x21100c90
 8003648:	400005f0 	.word	0x400005f0

0800364c <thinkos_sem_init_svc>:
	__bit_mem_wr(thinkos_rt.sem_alloc, idx, 0);
}
#endif

void thinkos_sem_init_svc(int32_t * arg)
{	
 800364c:	b570      	push	{r4, r5, r6, lr}
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	uint32_t value = (uint32_t)arg[1];
 800364e:	e890 0060 	ldmia.w	r0, {r5, r6}
#endif

void thinkos_sem_init_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
 8003652:	f1a5 01a2 	sub.w	r1, r5, #162	; 0xa2
	uint32_t value = (uint32_t)arg[1];

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 8003656:	294f      	cmp	r1, #79	; 0x4f
	__bit_mem_wr(thinkos_rt.sem_alloc, idx, 0);
}
#endif

void thinkos_sem_init_svc(int32_t * arg)
{	
 8003658:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	uint32_t value = (uint32_t)arg[1];

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 800365a:	d818      	bhi.n	800368e <thinkos_sem_init_svc+0x42>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 800365c:	4a10      	ldr	r2, [pc, #64]	; (80036a0 <thinkos_sem_init_svc+0x54>)
	return bit_addr[bit];
 800365e:	0152      	lsls	r2, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
 8003660:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8003664:	b15a      	cbz	r2, 800367e <thinkos_sem_init_svc+0x32>
		return;
	}
#endif
#endif

	DCC_LOG2(LOG_TRACE, "sem[%d] <= %d", sem, value);
 8003666:	480f      	ldr	r0, [pc, #60]	; (80036a4 <thinkos_sem_init_svc+0x58>)
 8003668:	4632      	mov	r2, r6
 800366a:	f000 ff01 	bl	8004470 <ice_trace2>

	thinkos_rt.sem_val[sem] = value;
 800366e:	4b0e      	ldr	r3, [pc, #56]	; (80036a8 <thinkos_sem_init_svc+0x5c>)
 8003670:	eb03 0585 	add.w	r5, r3, r5, lsl #2
	arg[0] = 0;
 8003674:	2300      	movs	r3, #0
#endif
#endif

	DCC_LOG2(LOG_TRACE, "sem[%d] <= %d", sem, value);

	thinkos_rt.sem_val[sem] = value;
 8003676:	f8c5 64ec 	str.w	r6, [r5, #1260]	; 0x4ec
	arg[0] = 0;
 800367a:	6023      	str	r3, [r4, #0]
 800367c:	bd70      	pop	{r4, r5, r6, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid semaphore %d!", wq);
 800367e:	480b      	ldr	r0, [pc, #44]	; (80036ac <thinkos_sem_init_svc+0x60>)
 8003680:	4629      	mov	r1, r5
 8003682:	f000 fec7 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003686:	f06f 0302 	mvn.w	r3, #2
 800368a:	6023      	str	r3, [r4, #0]
		return;
 800368c:	bd70      	pop	{r4, r5, r6, pc}
	unsigned int sem = wq - THINKOS_SEM_BASE;
	uint32_t value = (uint32_t)arg[1];

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 800368e:	4808      	ldr	r0, [pc, #32]	; (80036b0 <thinkos_sem_init_svc+0x64>)
 8003690:	4629      	mov	r1, r5
 8003692:	f000 febf 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003696:	f06f 0302 	mvn.w	r3, #2
 800369a:	6023      	str	r3, [r4, #0]
		return;
 800369c:	bd70      	pop	{r4, r5, r6, pc}
 800369e:	bf00      	nop
 80036a0:	21100c90 	.word	0x21100c90
 80036a4:	40000620 	.word	0x40000620
 80036a8:	20000088 	.word	0x20000088
 80036ac:	40000610 	.word	0x40000610
 80036b0:	40000600 	.word	0x40000600

080036b4 <thinkos_sem_wait_svc>:
	arg[0] = 0;
}

void thinkos_sem_wait_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
 80036b4:	6801      	ldr	r1, [r0, #0]
	thinkos_rt.sem_val[sem] = value;
	arg[0] = 0;
}

void thinkos_sem_wait_svc(int32_t * arg)
{	
 80036b6:	b538      	push	{r3, r4, r5, lr}
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
 80036b8:	f1a1 02a2 	sub.w	r2, r1, #162	; 0xa2
	int self = thinkos_rt.active;
 80036bc:	4b20      	ldr	r3, [pc, #128]	; (8003740 <thinkos_sem_wait_svc+0x8c>)

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 80036be:	2a4f      	cmp	r2, #79	; 0x4f
	thinkos_rt.sem_val[sem] = value;
	arg[0] = 0;
}

void thinkos_sem_wait_svc(int32_t * arg)
{	
 80036c0:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	int self = thinkos_rt.active;
 80036c2:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 80036c6:	d82d      	bhi.n	8003724 <thinkos_sem_wait_svc+0x70>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80036c8:	4d1e      	ldr	r5, [pc, #120]	; (8003744 <thinkos_sem_wait_svc+0x90>)
	return bit_addr[bit];
 80036ca:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
 80036cc:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80036d0:	2a00      	cmp	r2, #0
 80036d2:	d02e      	beq.n	8003732 <thinkos_sem_wait_svc+0x7e>
		return;
	}
#endif
#endif

	arg[0] = 0;
 80036d4:	2200      	movs	r2, #0
 80036d6:	6022      	str	r2, [r4, #0]
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80036d8:	b672      	cpsid	i
	   inside interrupt handlers */
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
 80036da:	f501 749d 	add.w	r4, r1, #314	; 0x13a
 80036de:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80036e2:	6862      	ldr	r2, [r4, #4]
 80036e4:	b9d2      	cbnz	r2, 800371c <thinkos_sem_wait_svc+0x68>
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 80036e6:	f101 0522 	add.w	r5, r1, #34	; 0x22
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80036ea:	f103 7488 	add.w	r4, r3, #17825792	; 0x1100000
 80036ee:	eb04 0485 	add.w	r4, r4, r5, lsl #2
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 80036f2:	181b      	adds	r3, r3, r0
	bit_addr[bit] = val;
 80036f4:	0164      	lsls	r4, r4, #5
 80036f6:	0049      	lsls	r1, r1, #1
 80036f8:	2501      	movs	r5, #1
 80036fa:	f844 5020 	str.w	r5, [r4, r0, lsl #2]
 80036fe:	f883 16d0 	strb.w	r1, [r3, #1744]	; 0x6d0
 8003702:	4b11      	ldr	r3, [pc, #68]	; (8003748 <thinkos_sem_wait_svc+0x94>)
 8003704:	015b      	lsls	r3, r3, #5
 8003706:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 800370a:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 800370c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003710:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003714:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003718:	605a      	str	r2, [r3, #4]
 800371a:	bd38      	pop	{r3, r4, r5, pc}
		thinkos_rt.sem_val[sem]--;
 800371c:	3a01      	subs	r2, #1
 800371e:	6062      	str	r2, [r4, #4]
 8003720:	b662      	cpsie	i
 8003722:	bd38      	pop	{r3, r4, r5, pc}
	unsigned int sem = wq - THINKOS_SEM_BASE;
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 8003724:	4809      	ldr	r0, [pc, #36]	; (800374c <thinkos_sem_wait_svc+0x98>)
 8003726:	f000 fe75 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 800372a:	f06f 0302 	mvn.w	r3, #2
 800372e:	6023      	str	r3, [r4, #0]
		return;
 8003730:	bd38      	pop	{r3, r4, r5, pc}
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid semaphore %d!", wq);
 8003732:	4807      	ldr	r0, [pc, #28]	; (8003750 <thinkos_sem_wait_svc+0x9c>)
 8003734:	f000 fe6e 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003738:	f06f 0302 	mvn.w	r3, #2
 800373c:	6023      	str	r3, [r4, #0]
		return;
 800373e:	bd38      	pop	{r3, r4, r5, pc}
 8003740:	20000088 	.word	0x20000088
 8003744:	21100c90 	.word	0x21100c90
 8003748:	21100110 	.word	0x21100110
 800374c:	40000630 	.word	0x40000630
 8003750:	40000640 	.word	0x40000640

08003754 <thinkos_sem_trywait_svc>:
	__thinkos_defer_sched();
}

void thinkos_sem_trywait_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
 8003754:	6801      	ldr	r1, [r0, #0]
	unsigned int sem = wq - THINKOS_SEM_BASE;
 8003756:	f1a1 03a2 	sub.w	r3, r1, #162	; 0xa2

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 800375a:	2b4f      	cmp	r3, #79	; 0x4f
	/* signal the scheduler ... */
	__thinkos_defer_sched();
}

void thinkos_sem_trywait_svc(int32_t * arg)
{	
 800375c:	b510      	push	{r4, lr}
 800375e:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 8003760:	d816      	bhi.n	8003790 <thinkos_sem_trywait_svc+0x3c>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003762:	4a12      	ldr	r2, [pc, #72]	; (80037ac <thinkos_sem_trywait_svc+0x58>)
	return bit_addr[bit];
 8003764:	0152      	lsls	r2, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
 8003766:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800376a:	b1c3      	cbz	r3, 800379e <thinkos_sem_trywait_svc+0x4a>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 800376c:	b672      	cpsid	i
	   inside interrupt handlers */
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
 800376e:	4b10      	ldr	r3, [pc, #64]	; (80037b0 <thinkos_sem_trywait_svc+0x5c>)
 8003770:	f501 719d 	add.w	r1, r1, #314	; 0x13a
 8003774:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8003778:	684b      	ldr	r3, [r1, #4]
 800377a:	b923      	cbnz	r3, 8003786 <thinkos_sem_trywait_svc+0x32>
		thinkos_rt.sem_val[sem]--;
		arg[0] = 0;
	} else {
		arg[0] = THINKOS_EAGAIN;
 800377c:	f06f 0303 	mvn.w	r3, #3
 8003780:	6003      	str	r3, [r0, #0]
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003782:	b662      	cpsie	i
 8003784:	bd10      	pop	{r4, pc}
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
		thinkos_rt.sem_val[sem]--;
 8003786:	3b01      	subs	r3, #1
 8003788:	604b      	str	r3, [r1, #4]
		arg[0] = 0;
 800378a:	2300      	movs	r3, #0
 800378c:	6003      	str	r3, [r0, #0]
 800378e:	e7f8      	b.n	8003782 <thinkos_sem_trywait_svc+0x2e>
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 8003790:	4808      	ldr	r0, [pc, #32]	; (80037b4 <thinkos_sem_trywait_svc+0x60>)
 8003792:	f000 fe3f 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003796:	f06f 0302 	mvn.w	r3, #2
 800379a:	6023      	str	r3, [r4, #0]
		return;
 800379c:	bd10      	pop	{r4, pc}
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid semaphore %d!", wq);
 800379e:	4806      	ldr	r0, [pc, #24]	; (80037b8 <thinkos_sem_trywait_svc+0x64>)
 80037a0:	f000 fe38 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 80037a4:	f06f 0302 	mvn.w	r3, #2
 80037a8:	6023      	str	r3, [r4, #0]
		return;
 80037aa:	bd10      	pop	{r4, pc}
 80037ac:	21100c90 	.word	0x21100c90
 80037b0:	20000088 	.word	0x20000088
 80037b4:	40000650 	.word	0x40000650
 80037b8:	40000660 	.word	0x40000660

080037bc <thinkos_sem_timedwait_svc>:
	cm3_cpsie_i();
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_sem_timedwait_svc(int32_t * arg)
{	
 80037bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	uint32_t ms = (uint32_t)arg[1];
 80037c0:	e890 0042 	ldmia.w	r0, {r1, r6}
	int self = thinkos_rt.active;
 80037c4:	4b2a      	ldr	r3, [pc, #168]	; (8003870 <thinkos_sem_timedwait_svc+0xb4>)

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_sem_timedwait_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
 80037c6:	f1a1 02a2 	sub.w	r2, r1, #162	; 0xa2
	uint32_t ms = (uint32_t)arg[1];
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 80037ca:	2a4f      	cmp	r2, #79	; 0x4f
	cm3_cpsie_i();
}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_sem_timedwait_svc(int32_t * arg)
{	
 80037cc:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	uint32_t ms = (uint32_t)arg[1];
	int self = thinkos_rt.active;
 80037ce:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 80037d2:	d83c      	bhi.n	800384e <thinkos_sem_timedwait_svc+0x92>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80037d4:	4d27      	ldr	r5, [pc, #156]	; (8003874 <thinkos_sem_timedwait_svc+0xb8>)
	return bit_addr[bit];
 80037d6:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
 80037d8:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80037dc:	2a00      	cmp	r2, #0
 80037de:	d03e      	beq.n	800385e <thinkos_sem_timedwait_svc+0xa2>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80037e0:	b672      	cpsid	i
	   inside interrupt handlers */
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
 80037e2:	f501 759d 	add.w	r5, r1, #314	; 0x13a
 80037e6:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80037ea:	686a      	ldr	r2, [r5, #4]
 80037ec:	bb52      	cbnz	r2, 8003844 <thinkos_sem_timedwait_svc+0x88>

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 80037ee:	f8d3 86f0 	ldr.w	r8, [r3, #1776]	; 0x6f0
 80037f2:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 80037f6:	4446      	add	r6, r8
 80037f8:	f8cc 66f4 	str.w	r6, [ip, #1780]	; 0x6f4
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80037fc:	f103 7588 	add.w	r5, r3, #17825792	; 0x1100000
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 8003800:	f101 0722 	add.w	r7, r1, #34	; 0x22
	bit_addr[bit] = val;
 8003804:	4e1c      	ldr	r6, [pc, #112]	; (8003878 <thinkos_sem_timedwait_svc+0xbc>)
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003806:	eb05 0787 	add.w	r7, r5, r7, lsl #2
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 800380a:	181b      	adds	r3, r3, r0
	bit_addr[bit] = val;
 800380c:	2501      	movs	r5, #1
 800380e:	017f      	lsls	r7, r7, #5
 8003810:	0049      	lsls	r1, r1, #1
 8003812:	0176      	lsls	r6, r6, #5
 8003814:	1949      	adds	r1, r1, r5
 8003816:	f847 5020 	str.w	r5, [r7, r0, lsl #2]
 800381a:	f846 5020 	str.w	r5, [r6, r0, lsl #2]
 800381e:	f883 16d0 	strb.w	r1, [r3, #1744]	; 0x6d0
 8003822:	4b16      	ldr	r3, [pc, #88]	; (800387c <thinkos_sem_timedwait_svc+0xc0>)
 8003824:	015b      	lsls	r3, r3, #5
 8003826:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
			thinkos_rt.wq_tmshare = 0;
		}
#endif
		/* Set the default return value to timeout. The
		   sem_post call will change this to 0 */
		arg[0] = THINKOS_ETIMEDOUT;
 800382a:	f04f 33ff 	mov.w	r3, #4294967295
 800382e:	6023      	str	r3, [r4, #0]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003830:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003832:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003836:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800383a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800383e:	605a      	str	r2, [r3, #4]
 8003840:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
		thinkos_rt.sem_val[sem]--;
 8003844:	3a01      	subs	r2, #1
		arg[0] = 0;
 8003846:	2300      	movs	r3, #0
	/* TODO: study the possibility of using exclusive access instead of 
	   disabling interrupts. */
	cm3_cpsid_i();

	if (thinkos_rt.sem_val[sem] > 0) {
		thinkos_rt.sem_val[sem]--;
 8003848:	606a      	str	r2, [r5, #4]
		arg[0] = 0;
 800384a:	6023      	str	r3, [r4, #0]
 800384c:	e7f0      	b.n	8003830 <thinkos_sem_timedwait_svc+0x74>
	uint32_t ms = (uint32_t)arg[1];
	int self = thinkos_rt.active;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 800384e:	480c      	ldr	r0, [pc, #48]	; (8003880 <thinkos_sem_timedwait_svc+0xc4>)
 8003850:	f000 fde0 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003854:	f06f 0302 	mvn.w	r3, #2
 8003858:	6023      	str	r3, [r4, #0]
		return;
 800385a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid semaphore %d!", wq);
 800385e:	4809      	ldr	r0, [pc, #36]	; (8003884 <thinkos_sem_timedwait_svc+0xc8>)
 8003860:	f000 fdd8 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003864:	f06f 0302 	mvn.w	r3, #2
 8003868:	6023      	str	r3, [r4, #0]
		return;
 800386a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800386e:	bf00      	nop
 8003870:	20000088 	.word	0x20000088
 8003874:	21100c90 	.word	0x21100c90
 8003878:	21100114 	.word	0x21100114
 800387c:	21100110 	.word	0x21100110
 8003880:	40000670 	.word	0x40000670
 8003884:	40000680 	.word	0x40000680

08003888 <thinkos_sem_post_svc>:
}
#endif

void thinkos_sem_post_svc(int32_t * arg)
{	
	unsigned int wq = arg[0];
 8003888:	6801      	ldr	r1, [r0, #0]
	__thinkos_defer_sched();
}
#endif

void thinkos_sem_post_svc(int32_t * arg)
{	
 800388a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
 800388c:	f1a1 03a2 	sub.w	r3, r1, #162	; 0xa2
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 8003890:	2b4f      	cmp	r3, #79	; 0x4f
	__thinkos_defer_sched();
}
#endif

void thinkos_sem_post_svc(int32_t * arg)
{	
 8003892:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int sem = wq - THINKOS_SEM_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
 8003894:	d832      	bhi.n	80038fc <thinkos_sem_post_svc+0x74>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003896:	4a24      	ldr	r2, [pc, #144]	; (8003928 <thinkos_sem_post_svc+0xa0>)
	return bit_addr[bit];
 8003898:	0152      	lsls	r2, r2, #5
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
 800389a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800389e:	2b00      	cmp	r3, #0
 80038a0:	d03b      	beq.n	800391a <thinkos_sem_post_svc+0x92>
		return;
	}
#endif
#endif

	arg[0] = 0;
 80038a2:	2200      	movs	r2, #0
 80038a4:	6002      	str	r2, [r0, #0]
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80038a6:	b672      	cpsid	i
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 80038a8:	4820      	ldr	r0, [pc, #128]	; (800392c <thinkos_sem_post_svc+0xa4>)
 80038aa:	f101 0422 	add.w	r4, r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80038ae:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
 80038b2:	fa93 f3a3 	rbit	r3, r3
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80038b6:	fab3 f383 	clz	r3, r3

	cm3_cpsid_i();
	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
 80038ba:	2b20      	cmp	r3, #32
 80038bc:	d025      	beq.n	800390a <thinkos_sem_post_svc+0x82>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80038be:	f100 7588 	add.w	r5, r0, #17825792	; 0x1100000
	bit_addr[bit] = val;
 80038c2:	4e1b      	ldr	r6, [pc, #108]	; (8003930 <thinkos_sem_post_svc+0xa8>)
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80038c4:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80038c8:	eb05 0484 	add.w	r4, r5, r4, lsl #2
	bit_addr[bit] = val;
 80038cc:	0164      	lsls	r4, r4, #5
 80038ce:	0176      	lsls	r6, r6, #5
 80038d0:	2701      	movs	r7, #1
 80038d2:	f846 7023 	str.w	r7, [r6, r3, lsl #2]
 80038d6:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
 80038da:	4c16      	ldr	r4, [pc, #88]	; (8003934 <thinkos_sem_post_svc+0xac>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80038dc:	f44f 456d 	mov.w	r5, #60672	; 0xed00
 80038e0:	0164      	lsls	r4, r4, #5
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80038e2:	18c0      	adds	r0, r0, r3

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80038e4:	f2ce 0500 	movt	r5, #57344	; 0xe000
 80038e8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
 80038ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
#if THINKOS_ENABLE_TIMED_CALLS
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = 0;
 80038f0:	620a      	str	r2, [r1, #32]
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 80038f2:	f880 26d0 	strb.w	r2, [r0, #1744]	; 0x6d0

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 80038f6:	606b      	str	r3, [r5, #4]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 80038f8:	b662      	cpsie	i
 80038fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int sem = wq - THINKOS_SEM_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (sem >= THINKOS_SEMAPHORE_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not a semaphore!", wq);
 80038fc:	480e      	ldr	r0, [pc, #56]	; (8003938 <thinkos_sem_post_svc+0xb0>)
 80038fe:	f000 fd89 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003902:	f06f 0302 	mvn.w	r3, #2
 8003906:	6023      	str	r3, [r4, #0]
		return;
 8003908:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	arg[0] = 0;

	cm3_cpsid_i();
	if ((th = __thinkos_wq_head(wq)) == THINKOS_THREAD_NULL) {
		/* no threads waiting on the semaphore, increment. */ 
		thinkos_rt.sem_val[sem]++;
 800390a:	f501 719d 	add.w	r1, r1, #314	; 0x13a
 800390e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8003912:	6843      	ldr	r3, [r0, #4]
 8003914:	3301      	adds	r3, #1
 8003916:	6043      	str	r3, [r0, #4]
 8003918:	e7ee      	b.n	80038f8 <thinkos_sem_post_svc+0x70>
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_SEM_ALLOC
	if (__bit_mem_rd(thinkos_rt.sem_alloc, sem) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid semaphore %d!", wq);
 800391a:	4808      	ldr	r0, [pc, #32]	; (800393c <thinkos_sem_post_svc+0xb4>)
 800391c:	f000 fd7a 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003920:	f06f 0302 	mvn.w	r3, #2
 8003924:	6023      	str	r3, [r4, #0]
		return;
 8003926:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003928:	21100c90 	.word	0x21100c90
 800392c:	20000088 	.word	0x20000088
 8003930:	21100110 	.word	0x21100110
 8003934:	21100114 	.word	0x21100114
 8003938:	40000690 	.word	0x40000690
 800393c:	400006a0 	.word	0x400006a0

08003940 <thinkos_ev_alloc_svc>:

#if THINKOS_EVENT_MAX > 0

#if THINKOS_ENABLE_EVENT_ALLOC
void thinkos_ev_alloc_svc(int32_t * arg)
{
 8003940:	b510      	push	{r4, lr}
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.ev_alloc, 
 8003942:	2150      	movs	r1, #80	; 0x50

#if THINKOS_EVENT_MAX > 0

#if THINKOS_ENABLE_EVENT_ALLOC
void thinkos_ev_alloc_svc(int32_t * arg)
{
 8003944:	4604      	mov	r4, r0
	unsigned int wq;
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.ev_alloc, 
 8003946:	480a      	ldr	r0, [pc, #40]	; (8003970 <thinkos_ev_alloc_svc+0x30>)
 8003948:	f7fe fa42 	bl	8001dd0 <thinkos_bmp_alloc>
 800394c:	2800      	cmp	r0, #0
 800394e:	db0d      	blt.n	800396c <thinkos_ev_alloc_svc+0x2c>
								 THINKOS_EVENT_MAX)) >= 0) {
		thinkos_rt.ev[idx].mask = 0xffffffff;
 8003950:	4a08      	ldr	r2, [pc, #32]	; (8003974 <thinkos_ev_alloc_svc+0x34>)
 8003952:	f500 718b 	add.w	r1, r0, #278	; 0x116
 8003956:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800395a:	f04f 31ff 	mov.w	r1, #4294967295
 800395e:	6091      	str	r1, [r2, #8]
		thinkos_rt.ev[idx].pend = 0;
		wq = idx + THINKOS_EVENT_BASE;
 8003960:	f100 03f2 	add.w	r3, r0, #242	; 0xf2
	int idx;

	if ((idx = thinkos_bmp_alloc(thinkos_rt.ev_alloc, 
								 THINKOS_EVENT_MAX)) >= 0) {
		thinkos_rt.ev[idx].mask = 0xffffffff;
		thinkos_rt.ev[idx].pend = 0;
 8003964:	2100      	movs	r1, #0
 8003966:	6051      	str	r1, [r2, #4]
		wq = idx + THINKOS_EVENT_BASE;
		DCC_LOG2(LOG_MSG, "event set=%d wq=%d", idx, wq);
		arg[0] = wq;
 8003968:	6023      	str	r3, [r4, #0]
 800396a:	bd10      	pop	{r4, pc}
	} else 
		arg[0] = idx;
 800396c:	6020      	str	r0, [r4, #0]
 800396e:	bd10      	pop	{r4, pc}
 8003970:	20000c9c 	.word	0x20000c9c
 8003974:	20000088 	.word	0x20000088

08003978 <thinkos_ev_free_svc>:
}

void thinkos_ev_free_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 8003978:	6801      	ldr	r1, [r0, #0]

#if THINKOS_ENABLE_ARG_CHECK
	if ((wq < THINKOS_EVENT_BASE) || 
 800397a:	f1a1 03f2 	sub.w	r3, r1, #242	; 0xf2
 800397e:	2b4f      	cmp	r3, #79	; 0x4f
	} else 
		arg[0] = idx;
}

void thinkos_ev_free_svc(int32_t * arg)
{
 8003980:	b510      	push	{r4, lr}
 8003982:	4604      	mov	r4, r0
	unsigned int wq = arg[0];

#if THINKOS_ENABLE_ARG_CHECK
	if ((wq < THINKOS_EVENT_BASE) || 
 8003984:	d805      	bhi.n	8003992 <thinkos_ev_free_svc+0x1a>

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8003986:	4a06      	ldr	r2, [pc, #24]	; (80039a0 <thinkos_ev_free_svc+0x28>)
 8003988:	0152      	lsls	r2, r2, #5
 800398a:	2100      	movs	r1, #0
 800398c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8003990:	bd10      	pop	{r4, pc}
		(wq >= (THINKOS_EVENT_BASE + THINKOS_EVENT_MAX))) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003992:	4804      	ldr	r0, [pc, #16]	; (80039a4 <thinkos_ev_free_svc+0x2c>)
 8003994:	f000 fd3e 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003998:	f06f 0302 	mvn.w	r3, #2
 800399c:	6023      	str	r3, [r4, #0]
		return;
 800399e:	bd10      	pop	{r4, pc}
 80039a0:	21100c9c 	.word	0x21100c9c
 80039a4:	400006b0 	.word	0x400006b0

080039a8 <thinkos_ev_wait_svc>:
}
#endif

void thinkos_ev_wait_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
 80039a8:	6801      	ldr	r1, [r0, #0]
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int self = thinkos_rt.active;
 80039aa:	4b29      	ldr	r3, [pc, #164]	; (8003a50 <thinkos_ev_wait_svc+0xa8>)
#endif

void thinkos_ev_wait_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	unsigned int no = wq - THINKOS_EVENT_BASE;
 80039ac:	f1a1 02f2 	sub.w	r2, r1, #242	; 0xf2
	int self = thinkos_rt.active;
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
 80039b0:	2a4f      	cmp	r2, #79	; 0x4f
	__bit_mem_wr(&thinkos_rt.ev_alloc, wq - THINKOS_EVENT_BASE, 0);
}
#endif

void thinkos_ev_wait_svc(int32_t * arg)
{
 80039b2:	b570      	push	{r4, r5, r6, lr}
 80039b4:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int self = thinkos_rt.active;
 80039b6:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
 80039ba:	d83b      	bhi.n	8003a34 <thinkos_ev_wait_svc+0x8c>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80039bc:	4d25      	ldr	r5, [pc, #148]	; (8003a54 <thinkos_ev_wait_svc+0xac>)
	return bit_addr[bit];
 80039be:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
 80039c0:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80039c4:	2a00      	cmp	r2, #0
 80039c6:	d03c      	beq.n	8003a42 <thinkos_ev_wait_svc+0x9a>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 80039c8:	b672      	cpsid	i

	cm3_cpsid_i();

	/* check for any pending unmasked event */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & 
						   thinkos_rt.ev[no].mask))) < 32) {
 80039ca:	f101 0524 	add.w	r5, r1, #36	; 0x24
 80039ce:	00ed      	lsls	r5, r5, #3
 80039d0:	195a      	adds	r2, r3, r5
#endif

	cm3_cpsid_i();

	/* check for any pending unmasked event */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & 
 80039d2:	6896      	ldr	r6, [r2, #8]
 80039d4:	6852      	ldr	r2, [r2, #4]
 80039d6:	4032      	ands	r2, r6
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 80039d8:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 80039dc:	fab2 f282 	clz	r2, r2
 80039e0:	2a1f      	cmp	r2, #31
 80039e2:	d91e      	bls.n	8003a22 <thinkos_ev_wait_svc+0x7a>
}

static void inline __attribute__((always_inline)) 
__thinkos_wq_insert(unsigned int wq, unsigned int th) {
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);  
 80039e4:	f101 0422 	add.w	r4, r1, #34	; 0x22
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 80039e8:	f103 7288 	add.w	r2, r3, #17825792	; 0x1100000
 80039ec:	eb02 0284 	add.w	r2, r2, r4, lsl #2
	bit_addr[bit] = val;
 80039f0:	0152      	lsls	r2, r2, #5
 80039f2:	2401      	movs	r4, #1
 80039f4:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
 80039f8:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
#if THINKOS_ENABLE_THREAD_STAT
	thinkos_rt.th_stat[th] = wq << 1;
 80039fc:	181b      	adds	r3, r3, r0
 80039fe:	fa01 f104 	lsl.w	r1, r1, r4
 8003a02:	f883 16d0 	strb.w	r1, [r3, #1744]	; 0x6d0
 8003a06:	4b14      	ldr	r3, [pc, #80]	; (8003a58 <thinkos_ev_wait_svc+0xb0>)
 8003a08:	015b      	lsls	r3, r3, #5
 8003a0a:	2100      	movs	r1, #0
 8003a0c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003a10:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003a12:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003a16:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003a1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003a1e:	605a      	str	r2, [r3, #4]
 8003a20:	bd70      	pop	{r4, r5, r6, pc}
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003a22:	4b0e      	ldr	r3, [pc, #56]	; (8003a5c <thinkos_ev_wait_svc+0xb4>)
 8003a24:	18ed      	adds	r5, r5, r3
	bit_addr[bit] = val;
 8003a26:	016d      	lsls	r5, r5, #5
 8003a28:	2300      	movs	r3, #0
 8003a2a:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
						   thinkos_rt.ev[no].mask))) < 32) {
		DCC_LOG2(LOG_MSG, "set=0x%08x msk=0x%08x", 
				 thinkos_rt.ev[no].pend, thinkos_rt.ev[no].mask);
		__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 0);  
		DCC_LOG2(LOG_INFO, "pending event %d.%d!", wq, ev);
		arg[0] = ev;
 8003a2e:	6022      	str	r2, [r4, #0]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003a30:	b662      	cpsie	i
 8003a32:	bd70      	pop	{r4, r5, r6, pc}
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003a34:	480a      	ldr	r0, [pc, #40]	; (8003a60 <thinkos_ev_wait_svc+0xb8>)
 8003a36:	f000 fced 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003a3a:	f06f 0302 	mvn.w	r3, #2
 8003a3e:	6023      	str	r3, [r4, #0]
		return;
 8003a40:	bd70      	pop	{r4, r5, r6, pc}
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid event set %d!", wq);
 8003a42:	4808      	ldr	r0, [pc, #32]	; (8003a64 <thinkos_ev_wait_svc+0xbc>)
 8003a44:	f000 fce6 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003a48:	f06f 0302 	mvn.w	r3, #2
 8003a4c:	6023      	str	r3, [r4, #0]
		return;
 8003a4e:	bd70      	pop	{r4, r5, r6, pc}
 8003a50:	20000088 	.word	0x20000088
 8003a54:	21100c9c 	.word	0x21100c9c
 8003a58:	21100110 	.word	0x21100110
 8003a5c:	2110008c 	.word	0x2110008c
 8003a60:	400006c0 	.word	0x400006c0
 8003a64:	400006d0 	.word	0x400006d0

08003a68 <thinkos_ev_timedwait_svc>:

}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_ev_timedwait_svc(int32_t * arg)
{
 8003a68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
 8003a6a:	e890 0042 	ldmia.w	r0, {r1, r6}
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int self = thinkos_rt.active;
 8003a6e:	4b30      	ldr	r3, [pc, #192]	; (8003b30 <thinkos_ev_timedwait_svc+0xc8>)
#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_ev_timedwait_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;
 8003a70:	f1a1 02f2 	sub.w	r2, r1, #242	; 0xf2
	int self = thinkos_rt.active;
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
 8003a74:	2a4f      	cmp	r2, #79	; 0x4f

}

#if THINKOS_ENABLE_TIMED_CALLS
void thinkos_ev_timedwait_svc(int32_t * arg)
{
 8003a76:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t ms = (uint32_t)arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int self = thinkos_rt.active;
 8003a78:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
 8003a7c:	d849      	bhi.n	8003b12 <thinkos_ev_timedwait_svc+0xaa>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003a7e:	4d2d      	ldr	r5, [pc, #180]	; (8003b34 <thinkos_ev_timedwait_svc+0xcc>)
	return bit_addr[bit];
 8003a80:	016d      	lsls	r5, r5, #5
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
 8003a82:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8003a86:	2a00      	cmp	r2, #0
 8003a88:	d04a      	beq.n	8003b20 <thinkos_ev_timedwait_svc+0xb8>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8003a8a:	b672      	cpsid	i

	cm3_cpsid_i();

	/* check for any pending unmasked event */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & 
						   thinkos_rt.ev[no].mask))) < 32) {
 8003a8c:	f101 0524 	add.w	r5, r1, #36	; 0x24
 8003a90:	00ed      	lsls	r5, r5, #3
 8003a92:	195a      	adds	r2, r3, r5
#endif

	cm3_cpsid_i();

	/* check for any pending unmasked event */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & 
 8003a94:	6897      	ldr	r7, [r2, #8]
 8003a96:	6852      	ldr	r2, [r2, #4]
 8003a98:	403a      	ands	r2, r7
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003a9a:	fa92 f2a2 	rbit	r2, r2
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003a9e:	fab2 f282 	clz	r2, r2
 8003aa2:	2a1f      	cmp	r2, #31
 8003aa4:	d92c      	bls.n	8003b00 <thinkos_ev_timedwait_svc+0x98>

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 8003aa6:	f8d3 56f0 	ldr.w	r5, [r3, #1776]	; 0x6f0
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003aaa:	f103 7288 	add.w	r2, r3, #17825792	; 0x1100000
 8003aae:	1976      	adds	r6, r6, r5
	/* insert into the event wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
 8003ab0:	f101 0722 	add.w	r7, r1, #34	; 0x22
	bit_addr[bit] = val;
 8003ab4:	4d20      	ldr	r5, [pc, #128]	; (8003b38 <thinkos_ev_timedwait_svc+0xd0>)
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003ab6:	eb02 0787 	add.w	r7, r2, r7, lsl #2

#if THINKOS_ENABLE_TIMED_CALLS
static void inline __attribute__((always_inline)) 
__thinkos_tmdwq_insert(unsigned int wq, unsigned int th, unsigned int ms) {
	/* set the clock */
	thinkos_rt.clock[th] = thinkos_rt.ticks + ms;
 8003aba:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	bit_addr[bit] = val;
 8003abe:	017f      	lsls	r7, r7, #5
 8003ac0:	016d      	lsls	r5, r5, #5
 8003ac2:	2201      	movs	r2, #1
 8003ac4:	f8cc 66f4 	str.w	r6, [ip, #1780]	; 0x6f4
 8003ac8:	f847 2020 	str.w	r2, [r7, r0, lsl #2]
 8003acc:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 1);
	/* insert into the clock wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 1);  
#if THINKOS_ENABLE_THREAD_STAT
	/* update status, mark the thread clock enable bit */
	thinkos_rt.th_stat[th] = (wq << 1) + 1;
 8003ad0:	1818      	adds	r0, r3, r0
 8003ad2:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8003ad6:	4b19      	ldr	r3, [pc, #100]	; (8003b3c <thinkos_ev_timedwait_svc+0xd4>)
 8003ad8:	0049      	lsls	r1, r1, #1
 8003ada:	3101      	adds	r1, #1
 8003adc:	015b      	lsls	r3, r3, #5
 8003ade:	f880 16d0 	strb.w	r1, [r0, #1744]	; 0x6d0
 8003ae2:	2100      	movs	r1, #0
 8003ae4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		thinkos_rt.wq_tmshare = 0;
	}
#endif
	/* Set the default return value to timeout. The
	   ev_rise() call will change it to the active event */
	arg[0] = THINKOS_ETIMEDOUT;
 8003ae8:	f04f 33ff 	mov.w	r3, #4294967295
 8003aec:	6023      	str	r3, [r4, #0]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003aee:	b662      	cpsie	i

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003af0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003af4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003af8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003afc:	605a      	str	r2, [r3, #4]
 8003afe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003b00:	4b0f      	ldr	r3, [pc, #60]	; (8003b40 <thinkos_ev_timedwait_svc+0xd8>)
 8003b02:	18ed      	adds	r5, r5, r3
	bit_addr[bit] = val;
 8003b04:	016d      	lsls	r5, r5, #5
 8003b06:	2300      	movs	r3, #0
 8003b08:	f845 3022 	str.w	r3, [r5, r2, lsl #2]

	/* check for any pending unmasked event */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & 
						   thinkos_rt.ev[no].mask))) < 32) {
		__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 0);  
		arg[0] = ev;
 8003b0c:	6022      	str	r2, [r4, #0]
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003b0e:	b662      	cpsie	i
 8003b10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int ev;

#if THINKOS_ENABLE_ARG_CHECK

	if (no >= THINKOS_EVENT_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003b12:	480c      	ldr	r0, [pc, #48]	; (8003b44 <thinkos_ev_timedwait_svc+0xdc>)
 8003b14:	f000 fc7e 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003b18:	f06f 0302 	mvn.w	r3, #2
 8003b1c:	6023      	str	r3, [r4, #0]
		return;
 8003b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid event set %d!", wq);
 8003b20:	4809      	ldr	r0, [pc, #36]	; (8003b48 <thinkos_ev_timedwait_svc+0xe0>)
 8003b22:	f000 fc77 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003b26:	f06f 0302 	mvn.w	r3, #2
 8003b2a:	6023      	str	r3, [r4, #0]
		return;
 8003b2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003b2e:	bf00      	nop
 8003b30:	20000088 	.word	0x20000088
 8003b34:	21100c9c 	.word	0x21100c9c
 8003b38:	21100114 	.word	0x21100114
 8003b3c:	21100110 	.word	0x21100110
 8003b40:	2110008c 	.word	0x2110008c
 8003b44:	400006e0 	.word	0x400006e0
 8003b48:	400006f0 	.word	0x400006f0

08003b4c <thinkos_ev_raise_svc>:

}
#endif

void thinkos_ev_raise_svc(int32_t * arg)
{
 8003b4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int wq = arg[0];
	unsigned int ev = arg[1];
 8003b4e:	e890 000a 	ldmia.w	r0, {r1, r3}
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (ev > 31) {
 8003b52:	2b1f      	cmp	r3, #31

}
#endif

void thinkos_ev_raise_svc(int32_t * arg)
{
 8003b54:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	unsigned int ev = arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;
 8003b56:	f1a1 02f2 	sub.w	r2, r1, #242	; 0xf2
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (ev > 31) {
 8003b5a:	d843      	bhi.n	8003be4 <thinkos_ev_raise_svc+0x98>
		DCC_LOG1(LOG_ERROR, "event %d is invalid!", ev);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (no >= THINKOS_EVENT_MAX) {
 8003b5c:	2a4f      	cmp	r2, #79	; 0x4f
 8003b5e:	d850      	bhi.n	8003c02 <thinkos_ev_raise_svc+0xb6>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003b60:	482b      	ldr	r0, [pc, #172]	; (8003c10 <thinkos_ev_raise_svc+0xc4>)
	return bit_addr[bit];
 8003b62:	0145      	lsls	r5, r0, #5
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
 8003b64:	f855 5022 	ldr.w	r5, [r5, r2, lsl #2]
 8003b68:	2d00      	cmp	r5, #0
 8003b6a:	d043      	beq.n	8003bf4 <thinkos_ev_raise_svc+0xa8>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003b6c:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
 8003b70:	f6a0 20ec 	subw	r0, r0, #2796	; 0xaec
	return bit_addr[bit];
 8003b74:	0140      	lsls	r0, r0, #5
		return;
	}
#endif
#endif

	if ((__bit_mem_rd(&thinkos_rt.ev[no].mask, ev)) &&  
 8003b76:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8003b7a:	b348      	cbz	r0, 8003bd0 <thinkos_ev_raise_svc+0x84>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003b7c:	4c25      	ldr	r4, [pc, #148]	; (8003c14 <thinkos_ev_raise_svc+0xc8>)
 8003b7e:	3122      	adds	r1, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003b80:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
 8003b84:	fa90 f0a0 	rbit	r0, r0
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003b88:	fab0 f080 	clz	r0, r0
 8003b8c:	2820      	cmp	r0, #32
 8003b8e:	d01f      	beq.n	8003bd0 <thinkos_ev_raise_svc+0x84>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003b90:	f104 7288 	add.w	r2, r4, #17825792	; 0x1100000
	bit_addr[bit] = val;
 8003b94:	4f20      	ldr	r7, [pc, #128]	; (8003c18 <thinkos_ev_raise_svc+0xcc>)
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003b96:	f854 6020 	ldr.w	r6, [r4, r0, lsl #2]
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003b9a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	bit_addr[bit] = val;
 8003b9e:	0149      	lsls	r1, r1, #5
 8003ba0:	017f      	lsls	r7, r7, #5
 8003ba2:	2200      	movs	r2, #0
 8003ba4:	f04f 0c01 	mov.w	ip, #1
 8003ba8:	f847 c020 	str.w	ip, [r7, r0, lsl #2]
 8003bac:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
 8003bb0:	491a      	ldr	r1, [pc, #104]	; (8003c1c <thinkos_ev_raise_svc+0xd0>)

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003bb2:	f44f 456d 	mov.w	r5, #60672	; 0xed00
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003bb6:	1824      	adds	r4, r4, r0
 8003bb8:	0149      	lsls	r1, r1, #5

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003bba:	f2ce 0500 	movt	r5, #57344	; 0xe000
 8003bbe:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003bc2:	f884 26d0 	strb.w	r2, [r4, #1744]	; 0x6d0
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003bc6:	6233      	str	r3, [r6, #32]

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003bc8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003bcc:	606b      	str	r3, [r5, #4]
 8003bce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003bd0:	4913      	ldr	r1, [pc, #76]	; (8003c20 <thinkos_ev_raise_svc+0xd4>)
		/* signal the scheduler ... */
		__thinkos_defer_sched();
	} else {
		/* event is maksed or no thread is waiting ont hte event set
		   , set the event as pending */
		__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 1);  
 8003bd2:	f502 728b 	add.w	r2, r2, #278	; 0x116
 8003bd6:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
	bit_addr[bit] = val;
 8003bda:	0152      	lsls	r2, r2, #5
 8003bdc:	2101      	movs	r1, #1
 8003bde:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8003be2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned int no = wq - THINKOS_EVENT_BASE;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (ev > 31) {
		DCC_LOG1(LOG_ERROR, "event %d is invalid!", ev);
 8003be4:	4619      	mov	r1, r3
 8003be6:	480f      	ldr	r0, [pc, #60]	; (8003c24 <thinkos_ev_raise_svc+0xd8>)
 8003be8:	f000 fc14 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003bec:	f06f 0302 	mvn.w	r3, #2
 8003bf0:	6023      	str	r3, [r4, #0]
		return;
 8003bf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid event set %d!", wq);
 8003bf4:	480c      	ldr	r0, [pc, #48]	; (8003c28 <thinkos_ev_raise_svc+0xdc>)
 8003bf6:	f000 fc0d 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003bfa:	f06f 0302 	mvn.w	r3, #2
 8003bfe:	6023      	str	r3, [r4, #0]
		return;
 8003c00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		DCC_LOG1(LOG_ERROR, "event %d is invalid!", ev);
		arg[0] = THINKOS_EINVAL;
		return;
	}
	if (no >= THINKOS_EVENT_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003c02:	480a      	ldr	r0, [pc, #40]	; (8003c2c <thinkos_ev_raise_svc+0xe0>)
 8003c04:	f000 fc06 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003c08:	f06f 0302 	mvn.w	r3, #2
 8003c0c:	6023      	str	r3, [r4, #0]
		return;
 8003c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c10:	21100c9c 	.word	0x21100c9c
 8003c14:	20000088 	.word	0x20000088
 8003c18:	21100110 	.word	0x21100110
 8003c1c:	21100114 	.word	0x21100114
 8003c20:	2110008c 	.word	0x2110008c
 8003c24:	40000700 	.word	0x40000700
 8003c28:	40000720 	.word	0x40000720
 8003c2c:	40000710 	.word	0x40000710

08003c30 <thinkos_ev_mask_svc>:
}

void thinkos_ev_mask_svc(int32_t * arg)
{
	unsigned int wq = arg[0];
	uint32_t mask = arg[1];
 8003c30:	e890 0006 	ldmia.w	r0, {r1, r2}
	unsigned int no = wq - THINKOS_EVENT_BASE;
 8003c34:	f1a1 03f2 	sub.w	r3, r1, #242	; 0xf2

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
 8003c38:	2b4f      	cmp	r3, #79	; 0x4f
				 thinkos_rt.ev[no].pend, thinkos_rt.ev[no].mask);
	}
}

void thinkos_ev_mask_svc(int32_t * arg)
{
 8003c3a:	b510      	push	{r4, lr}
 8003c3c:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t mask = arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
 8003c3e:	d80d      	bhi.n	8003c5c <thinkos_ev_mask_svc+0x2c>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003c40:	480d      	ldr	r0, [pc, #52]	; (8003c78 <thinkos_ev_mask_svc+0x48>)
	return bit_addr[bit];
 8003c42:	0140      	lsls	r0, r0, #5
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
 8003c44:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8003c48:	b17b      	cbz	r3, 8003c6a <thinkos_ev_mask_svc+0x3a>
	}
#endif
#endif

	/* mask the events on the mask bitmap */
	thinkos_rt.ev[no].mask &= ~mask;
 8003c4a:	4b0c      	ldr	r3, [pc, #48]	; (8003c7c <thinkos_ev_mask_svc+0x4c>)
 8003c4c:	3124      	adds	r1, #36	; 0x24
 8003c4e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8003c52:	688b      	ldr	r3, [r1, #8]
 8003c54:	ea23 0202 	bic.w	r2, r3, r2
 8003c58:	608a      	str	r2, [r1, #8]
 8003c5a:	bd10      	pop	{r4, pc}
	uint32_t mask = arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003c5c:	4808      	ldr	r0, [pc, #32]	; (8003c80 <thinkos_ev_mask_svc+0x50>)
 8003c5e:	f000 fbd9 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003c62:	f06f 0302 	mvn.w	r3, #2
 8003c66:	6023      	str	r3, [r4, #0]
		return;
 8003c68:	bd10      	pop	{r4, pc}
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid event set %d!", wq);
 8003c6a:	4806      	ldr	r0, [pc, #24]	; (8003c84 <thinkos_ev_mask_svc+0x54>)
 8003c6c:	f000 fbd2 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003c70:	f06f 0302 	mvn.w	r3, #2
 8003c74:	6023      	str	r3, [r4, #0]
		return;
 8003c76:	bd10      	pop	{r4, pc}
 8003c78:	21100c9c 	.word	0x21100c9c
 8003c7c:	20000088 	.word	0x20000088
 8003c80:	40000730 	.word	0x40000730
 8003c84:	40000740 	.word	0x40000740

08003c88 <thinkos_ev_unmask_svc>:
	/* mask the events on the mask bitmap */
	thinkos_rt.ev[no].mask &= ~mask;
}

void thinkos_ev_unmask_svc(int32_t * arg)
{
 8003c88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int wq = arg[0];
 8003c8c:	f8d0 8000 	ldr.w	r8, [r0]
	uint32_t mask = arg[1];
 8003c90:	6841      	ldr	r1, [r0, #4]
	/* mask the events on the mask bitmap */
	thinkos_rt.ev[no].mask &= ~mask;
}

void thinkos_ev_unmask_svc(int32_t * arg)
{
 8003c92:	b087      	sub	sp, #28
	unsigned int wq = arg[0];
	uint32_t mask = arg[1];
	unsigned int no = wq - THINKOS_EVENT_BASE;
 8003c94:	f1a8 0bf2 	sub.w	fp, r8, #242	; 0xf2
	unsigned int ev;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
 8003c98:	f1bb 0f4f 	cmp.w	fp, #79	; 0x4f
	/* mask the events on the mask bitmap */
	thinkos_rt.ev[no].mask &= ~mask;
}

void thinkos_ev_unmask_svc(int32_t * arg)
{
 8003c9c:	4604      	mov	r4, r0
	unsigned int wq = arg[0];
	uint32_t mask = arg[1];
 8003c9e:	9101      	str	r1, [sp, #4]
	unsigned int no = wq - THINKOS_EVENT_BASE;
	unsigned int ev;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
 8003ca0:	f200 80b2 	bhi.w	8003e08 <thinkos_ev_unmask_svc+0x180>
}

/* read a bit from a bitbang memory region */
static uint32_t inline __attribute__((always_inline)) __bit_mem_rd(void * ptr, int32_t bit) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003ca4:	4b60      	ldr	r3, [pc, #384]	; (8003e28 <thinkos_ev_unmask_svc+0x1a0>)
	return bit_addr[bit];
 8003ca6:	015b      	lsls	r3, r3, #5
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
		arg[0] = THINKOS_EINVAL;
		return;
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
 8003ca8:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8003cac:	2b00      	cmp	r3, #0
 8003cae:	f000 80b3 	beq.w	8003e18 <thinkos_ev_unmask_svc+0x190>
	return ipsr;
}

/* disable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsid_i(void) {
	asm volatile ("cpsid i\n");
 8003cb2:	b672      	cpsid	i
#endif

	cm3_cpsid_i();

	/* unmask the events on the mask bitmap */
	thinkos_rt.ev[no].mask |= mask;
 8003cb4:	4f5d      	ldr	r7, [pc, #372]	; (8003e2c <thinkos_ev_unmask_svc+0x1a4>)
 8003cb6:	9901      	ldr	r1, [sp, #4]
 8003cb8:	f108 0224 	add.w	r2, r8, #36	; 0x24
 8003cbc:	00d2      	lsls	r2, r2, #3
 8003cbe:	18bc      	adds	r4, r7, r2
 8003cc0:	68a3      	ldr	r3, [r4, #8]

	/* wake up the first unmasked thread if any. */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & mask))) < 32) {
 8003cc2:	6865      	ldr	r5, [r4, #4]
#endif

	cm3_cpsid_i();

	/* unmask the events on the mask bitmap */
	thinkos_rt.ev[no].mask |= mask;
 8003cc4:	430b      	orrs	r3, r1
 8003cc6:	60a3      	str	r3, [r4, #8]

	/* wake up the first unmasked thread if any. */
	if ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & mask))) < 32) {
 8003cc8:	400d      	ands	r5, r1
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003cca:	fa95 f6a5 	rbit	r6, r5
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003cce:	fab6 f686 	clz	r6, r6
 8003cd2:	2e1f      	cmp	r6, #31
 8003cd4:	d83d      	bhi.n	8003d52 <thinkos_ev_unmask_svc+0xca>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003cd6:	f108 0322 	add.w	r3, r8, #34	; 0x22
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003cda:	f857 5023 	ldr.w	r5, [r7, r3, lsl #2]
 8003cde:	fa95 f5a5 	rbit	r5, r5
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003ce2:	fab5 f585 	clz	r5, r5
		if ((th = __thinkos_wq_head(wq)) != THINKOS_THREAD_NULL) {
 8003ce6:	2d20      	cmp	r5, #32
 8003ce8:	f000 808a 	beq.w	8003e00 <thinkos_ev_unmask_svc+0x178>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003cec:	f107 7188 	add.w	r1, r7, #17825792	; 0x1100000
 8003cf0:	f101 0e04 	add.w	lr, r1, #4
 8003cf4:	4472      	add	r2, lr
	bit_addr[bit] = val;
 8003cf6:	0152      	lsls	r2, r2, #5
 8003cf8:	f04f 0e00 	mov.w	lr, #0
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003cfc:	f857 a025 	ldr.w	sl, [r7, r5, lsl #2]
 8003d00:	f842 e026 	str.w	lr, [r2, r6, lsl #2]
 8003d04:	4a4a      	ldr	r2, [pc, #296]	; (8003e30 <thinkos_ev_unmask_svc+0x1a8>)
			   wakes up the thread. */
			__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 0);  
			/* wakeup from the event wait queue, set the return of
			   the thread to the event */
			__thinkos_wakeup_return(wq, th, ev);
			DCC_LOG3(LOG_TRACE, "<%d> waked up with event %d.%d", th, wq, ev);
 8003d06:	484b      	ldr	r0, [pc, #300]	; (8003e34 <thinkos_ev_unmask_svc+0x1ac>)
 8003d08:	0152      	lsls	r2, r2, #5
 8003d0a:	f04f 0901 	mov.w	r9, #1
 8003d0e:	f842 9025 	str.w	r9, [r2, r5, lsl #2]
 8003d12:	f8df 9124 	ldr.w	r9, [pc, #292]	; 8003e38 <thinkos_ev_unmask_svc+0x1b0>
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003d16:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003d1a:	eb07 0c05 	add.w	ip, r7, r5
	bit_addr[bit] = val;
 8003d1e:	015b      	lsls	r3, r3, #5
 8003d20:	ea4f 1949 	mov.w	r9, r9, lsl #5
 8003d24:	f843 e025 	str.w	lr, [r3, r5, lsl #2]
 8003d28:	4629      	mov	r1, r5
 8003d2a:	f849 e025 	str.w	lr, [r9, r5, lsl #2]
 8003d2e:	4642      	mov	r2, r8
 8003d30:	4633      	mov	r3, r6
 8003d32:	f88c e6d0 	strb.w	lr, [ip, #1744]	; 0x6d0
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003d36:	f8ca 6020 	str.w	r6, [sl, #32]
 8003d3a:	f000 fbcd 	bl	80044d8 <ice_trace3>

/* flags a deferred execution of the scheduler */
static void inline __attribute__((always_inline)) __thinkos_defer_sched(void) {
	struct cm3_scb * scb = CM3_SCB;
	/* rise a pending service interrupt */
	scb->icsr = SCB_ICSR_PENDSVSET;
 8003d3e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003d42:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003d46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003d4a:	605a      	str	r2, [r3, #4]
 8003d4c:	6865      	ldr	r5, [r4, #4]
 8003d4e:	9a01      	ldr	r2, [sp, #4]
 8003d50:	4015      	ands	r5, r2
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003d52:	fa95 f5a5 	rbit	r5, r5
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003d56:	fab5 f585 	clz	r5, r5
			return;
		}
	}

	/* wake up as many other threads as possible */
	while ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & mask))) < 32) {
 8003d5a:	2d1f      	cmp	r5, #31
 8003d5c:	d850      	bhi.n	8003e00 <thinkos_ev_unmask_svc+0x178>
}

static int inline __attribute__((always_inline)) 
__thinkos_wq_head(unsigned int wq) {
	/* get a thread from the queue bitmap */
	return __clz(__rbit(thinkos_rt.wq_lst[wq]));
 8003d5e:	f108 0922 	add.w	r9, r8, #34	; 0x22
 8003d62:	4b32      	ldr	r3, [pc, #200]	; (8003e2c <thinkos_ev_unmask_svc+0x1a4>)
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003d64:	f857 4029 	ldr.w	r4, [r7, r9, lsl #2]
 8003d68:	fa94 f4a4 	rbit	r4, r4
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003d6c:	fab4 f484 	clz	r4, r4
		if ((th = __thinkos_wq_head(wq)) != THINKOS_THREAD_NULL) {
 8003d70:	2c20      	cmp	r4, #32
 8003d72:	d045      	beq.n	8003e00 <thinkos_ev_unmask_svc+0x178>
 8003d74:	482e      	ldr	r0, [pc, #184]	; (8003e30 <thinkos_ev_unmask_svc+0x1a8>)
			/* a pending event was unmaksed and there is a thread waiting on 
			   the queue, clear the event pending flag and 
			   wakes up the thread. */
			__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 0);  
 8003d76:	f50b 7b8b 	add.w	fp, fp, #278	; 0x116
 8003d7a:	0140      	lsls	r0, r0, #5
 8003d7c:	eb03 0bcb 	add.w	fp, r3, fp, lsl #3
 8003d80:	f10b 0104 	add.w	r1, fp, #4
static void inline __attribute__((always_inline)) 
__thinkos_wakeup_return(unsigned int wq, unsigned int th, int ret) {
	/* insert the thread into ready queue */
	__bit_mem_wr(&thinkos_rt.wq_ready, th, 1);
	/* remove from the wait queue */
	__bit_mem_wr(&thinkos_rt.wq_lst[wq], th, 0);  
 8003d84:	eb03 0289 	add.w	r2, r3, r9, lsl #2
 8003d88:	9004      	str	r0, [sp, #16]
 8003d8a:	482b      	ldr	r0, [pc, #172]	; (8003e38 <thinkos_ev_unmask_svc+0x1b0>)
}

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
 8003d8c:	f101 7188 	add.w	r1, r1, #17825792	; 0x1100000
 8003d90:	f102 7288 	add.w	r2, r2, #17825792	; 0x1100000
 8003d94:	0140      	lsls	r0, r0, #5
 8003d96:	0149      	lsls	r1, r1, #5
 8003d98:	0152      	lsls	r2, r2, #5
 8003d9a:	9005      	str	r0, [sp, #20]
 8003d9c:	9102      	str	r1, [sp, #8]
 8003d9e:	9203      	str	r2, [sp, #12]
	bit_addr[bit] = val;
 8003da0:	2600      	movs	r6, #0
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003da2:	469a      	mov	sl, r3
 8003da4:	e007      	b.n	8003db6 <thinkos_ev_unmask_svc+0x12e>
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003da6:	f85a 4029 	ldr.w	r4, [sl, r9, lsl #2]
 8003daa:	fa94 f4a4 	rbit	r4, r4
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003dae:	fab4 f484 	clz	r4, r4
		}
	}

	/* wake up as many other threads as possible */
	while ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & mask))) < 32) {
		if ((th = __thinkos_wq_head(wq)) != THINKOS_THREAD_NULL) {
 8003db2:	2c20      	cmp	r4, #32
 8003db4:	d024      	beq.n	8003e00 <thinkos_ev_unmask_svc+0x178>

/* write a bit into a bitbang memory region */
static inline void __attribute__((always_inline)) __bit_mem_wr(void * ptr, int32_t bit, uint32_t val) {
	/* get the bitband bit address */
	uint32_t * bit_addr = CM3_BITBAND_MEM(ptr, 0);
	bit_addr[bit] = val;
 8003db6:	9b02      	ldr	r3, [sp, #8]
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003db8:	f857 e024 	ldr.w	lr, [r7, r4, lsl #2]
 8003dbc:	9a04      	ldr	r2, [sp, #16]
 8003dbe:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
 8003dc2:	9b03      	ldr	r3, [sp, #12]
			   wakes up the thread. */
			__bit_mem_wr(&thinkos_rt.ev[no].pend, ev, 0);  
			/* wakeup from the event wait queue, set the return of
			   the thread to the event */
			__thinkos_wakeup_return(wq, th, ev);
			DCC_LOG3(LOG_TRACE, "<%d> waked up with event %d.%d", th, wq, ev);
 8003dc4:	481d      	ldr	r0, [pc, #116]	; (8003e3c <thinkos_ev_unmask_svc+0x1b4>)
 8003dc6:	2101      	movs	r1, #1
 8003dc8:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
	/* possibly remove from the time wait queue */
	__bit_mem_wr(&thinkos_rt.wq_clock, th, 0);  
#endif
#if THINKOS_ENABLE_THREAD_STAT
	/* update status */
	thinkos_rt.th_stat[th] = 0;
 8003dcc:	eb07 0c04 	add.w	ip, r7, r4
 8003dd0:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
 8003dd4:	9b05      	ldr	r3, [sp, #20]
 8003dd6:	4621      	mov	r1, r4
 8003dd8:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
 8003ddc:	4642      	mov	r2, r8
 8003dde:	462b      	mov	r3, r5
 8003de0:	f88c 66d0 	strb.w	r6, [ip, #1744]	; 0x6d0
#endif
	/* set the thread's return value */
	thinkos_rt.ctx[th]->r0 = ret;
 8003de4:	f8ce 5020 	str.w	r5, [lr, #32]
 8003de8:	f000 fb76 	bl	80044d8 <ice_trace3>
			return;
		}
	}

	/* wake up as many other threads as possible */
	while ((ev = __clz(__rbit(thinkos_rt.ev[no].pend & mask))) < 32) {
 8003dec:	f8db 5004 	ldr.w	r5, [fp, #4]
 8003df0:	9901      	ldr	r1, [sp, #4]
 8003df2:	400d      	ands	r5, r1
	return ret;
}

static inline uint32_t __attribute__((always_inline)) __rbit(uint32_t val) {
	register uint32_t ret;
	asm volatile ("rbit %0, %1\n" : "=r" (ret) : "r" (val));
 8003df4:	fa95 f5a5 	rbit	r5, r5
	asm volatile ("mov lr, %0\n" : "=r" (lr));
}

static inline uint32_t __attribute__((always_inline)) __clz(uint32_t val) {
	register uint32_t ret;
	asm volatile ("clz %0, %1\n" : "=r" (ret) : "r" (val));
 8003df8:	fab5 f585 	clz	r5, r5
 8003dfc:	2d1f      	cmp	r5, #31
 8003dfe:	d9d2      	bls.n	8003da6 <thinkos_ev_unmask_svc+0x11e>
	asm volatile ("cpsid i\n");
}

/* enable interrupts */
static inline void __attribute__((always_inline)) cm3_cpsie_i(void) {
	asm volatile ("cpsie i\n");
 8003e00:	b662      	cpsie	i
			break;
		}
	}

	cm3_cpsie_i();
}
 8003e02:	b007      	add	sp, #28
 8003e04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	unsigned int ev;
	int th;

#if THINKOS_ENABLE_ARG_CHECK
	if (no >= THINKOS_EVENT_MAX) {
		DCC_LOG1(LOG_ERROR, "object %d is not an event set!", wq);
 8003e08:	480d      	ldr	r0, [pc, #52]	; (8003e40 <thinkos_ev_unmask_svc+0x1b8>)
 8003e0a:	4641      	mov	r1, r8
 8003e0c:	f000 fb02 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003e10:	f06f 0302 	mvn.w	r3, #2
 8003e14:	6023      	str	r3, [r4, #0]
		return;
 8003e16:	e7f4      	b.n	8003e02 <thinkos_ev_unmask_svc+0x17a>
	}
#if THINKOS_ENABLE_EVENT_ALLOC
	if (__bit_mem_rd(&thinkos_rt.ev_alloc, no) == 0) {
		DCC_LOG1(LOG_ERROR, "invalid event set %d!", wq);
 8003e18:	480a      	ldr	r0, [pc, #40]	; (8003e44 <thinkos_ev_unmask_svc+0x1bc>)
 8003e1a:	4641      	mov	r1, r8
 8003e1c:	f000 fafa 	bl	8004414 <ice_trace1>
		arg[0] = THINKOS_EINVAL;
 8003e20:	f06f 0302 	mvn.w	r3, #2
 8003e24:	6023      	str	r3, [r4, #0]
		return;
 8003e26:	e7ec      	b.n	8003e02 <thinkos_ev_unmask_svc+0x17a>
 8003e28:	21100c9c 	.word	0x21100c9c
 8003e2c:	20000088 	.word	0x20000088
 8003e30:	21100110 	.word	0x21100110
 8003e34:	40000770 	.word	0x40000770
 8003e38:	21100114 	.word	0x21100114
 8003e3c:	40000780 	.word	0x40000780
 8003e40:	40000750 	.word	0x40000750
 8003e44:	40000760 	.word	0x40000760

08003e48 <printf>:

#include <stddef.h>
#include <stdio.h>

int printf(const char * fmt, ...)
{
 8003e48:	b40f      	push	{r0, r1, r2, r3}
 8003e4a:	b500      	push	{lr}
 8003e4c:	b083      	sub	sp, #12
 8003e4e:	aa04      	add	r2, sp, #16
	va_list ap;
	int n;

	va_start(ap, fmt);
	n = vfprintf(stdout, fmt, ap);
 8003e50:	f640 63cc 	movw	r3, #3788	; 0xecc
 8003e54:	f2c2 0300 	movt	r3, #8192	; 0x2000

#include <stddef.h>
#include <stdio.h>

int printf(const char * fmt, ...)
{
 8003e58:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list ap;
	int n;

	va_start(ap, fmt);
	n = vfprintf(stdout, fmt, ap);
 8003e5c:	6818      	ldr	r0, [r3, #0]
int printf(const char * fmt, ...)
{
	va_list ap;
	int n;

	va_start(ap, fmt);
 8003e5e:	9201      	str	r2, [sp, #4]
	n = vfprintf(stdout, fmt, ap);
 8003e60:	f000 f834 	bl	8003ecc <vfprintf>
	va_end(ap);

	return n;
}
 8003e64:	b003      	add	sp, #12
 8003e66:	f85d eb04 	ldr.w	lr, [sp], #4
 8003e6a:	b004      	add	sp, #16
 8003e6c:	4770      	bx	lr
 8003e6e:	bf00      	nop

08003e70 <putchar>:

#include <stdio.h>

int putchar(int c)
{
	return fputc(c, stdout);
 8003e70:	f640 63cc 	movw	r3, #3788	; 0xecc
 8003e74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e78:	6819      	ldr	r1, [r3, #0]
 8003e7a:	f000 b9bd 	b.w	80041f8 <fputc>
 8003e7e:	bf00      	nop

08003e80 <puts>:
#include <stdio.h>
#include <string.h>
#include <sys/file.h>

int puts(const char * s)
{
 8003e80:	b538      	push	{r3, r4, r5, lr}
	FILE * f = stdout;
 8003e82:	f640 63cc 	movw	r3, #3788	; 0xecc
 8003e86:	f2c2 0300 	movt	r3, #8192	; 0x2000
#include <stdio.h>
#include <string.h>
#include <sys/file.h>

int puts(const char * s)
{
 8003e8a:	4605      	mov	r5, r0
	FILE * f = stdout;
 8003e8c:	681c      	ldr	r4, [r3, #0]
	int n;

	n = f->op->write(f->data, s, strlen(s));
 8003e8e:	f000 f813 	bl	8003eb8 <strlen>
 8003e92:	4602      	mov	r2, r0
 8003e94:	e894 0009 	ldmia.w	r4, {r0, r3}
 8003e98:	4629      	mov	r1, r5
 8003e9a:	681b      	ldr	r3, [r3, #0]
 8003e9c:	4798      	blx	r3
 8003e9e:	4605      	mov	r5, r0
	n += f->op->write(f->data, "\n", 1);
 8003ea0:	e894 0009 	ldmia.w	r4, {r0, r3}
 8003ea4:	f644 1154 	movw	r1, #18772	; 0x4954
 8003ea8:	681b      	ldr	r3, [r3, #0]
 8003eaa:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003eae:	2201      	movs	r2, #1
 8003eb0:	4798      	blx	r3

	return n;
}
 8003eb2:	1940      	adds	r0, r0, r5
 8003eb4:	bd38      	pop	{r3, r4, r5, pc}
 8003eb6:	bf00      	nop

08003eb8 <strlen>:
	int n = 0;

	if (!cp)
		return 0;

	while (*cp++)
 8003eb8:	7803      	ldrb	r3, [r0, #0]
 8003eba:	b123      	cbz	r3, 8003ec6 <strlen+0xe>
 8003ebc:	2300      	movs	r3, #0
		n++;
 8003ebe:	3301      	adds	r3, #1
	int n = 0;

	if (!cp)
		return 0;

	while (*cp++)
 8003ec0:	5cc2      	ldrb	r2, [r0, r3]
 8003ec2:	2a00      	cmp	r2, #0
 8003ec4:	d1fb      	bne.n	8003ebe <strlen+0x6>
 8003ec6:	4618      	mov	r0, r3
		n++;

	return n;
}
 8003ec8:	4770      	bx	lr
 8003eca:	bf00      	nop

08003ecc <vfprintf>:
#endif
	' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
	' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };

int vfprintf(struct file * f, const char * fmt, va_list ap)
{
 8003ecc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		unsigned long long ull;
		long long ll;
#endif
	} val;

	n = 0;
 8003ed0:	2400      	movs	r4, #0
#endif
	' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
	' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };

int vfprintf(struct file * f, const char * fmt, va_list ap)
{
 8003ed2:	b089      	sub	sp, #36	; 0x24
 8003ed4:	460e      	mov	r6, r1
 8003ed6:	4682      	mov	sl, r0
 8003ed8:	4693      	mov	fp, r2

	n = 0;
	w = 0;
	cnt = 0;
#if (PRINTF_ENABLE_FAST)
	cp = (char *)fmt;
 8003eda:	460d      	mov	r5, r1
		long long ll;
#endif
	} val;

	n = 0;
	w = 0;
 8003edc:	46a0      	mov	r8, r4
	cnt = 0;
 8003ede:	46a1      	mov	r9, r4
#if (PRINTF_ENABLE_FAST)
	cp = (char *)fmt;
#endif
	for (flags = 0; (c = *fmt++); ) {
 8003ee0:	4627      	mov	r7, r4
 8003ee2:	f816 3b01 	ldrb.w	r3, [r6], #1
 8003ee6:	461a      	mov	r2, r3
 8003ee8:	b143      	cbz	r3, 8003efc <vfprintf+0x30>
		if (flags == 0) {
 8003eea:	b99f      	cbnz	r7, 8003f14 <vfprintf+0x48>
			if (c == '%') {
 8003eec:	2b25      	cmp	r3, #37	; 0x25
 8003eee:	d075      	beq.n	8003fdc <vfprintf+0x110>
	w = 0;
	cnt = 0;
#if (PRINTF_ENABLE_FAST)
	cp = (char *)fmt;
#endif
	for (flags = 0; (c = *fmt++); ) {
 8003ef0:	f816 3b01 	ldrb.w	r3, [r6], #1
#endif
				continue;
			}

#if (PRINTF_ENABLE_FAST)
			n++;
 8003ef4:	3401      	adds	r4, #1
	w = 0;
	cnt = 0;
#if (PRINTF_ENABLE_FAST)
	cp = (char *)fmt;
#endif
	for (flags = 0; (c = *fmt++); ) {
 8003ef6:	461a      	mov	r2, r3
 8003ef8:	2b00      	cmp	r3, #0
 8003efa:	d1f6      	bne.n	8003eea <vfprintf+0x1e>
		n = 0;
#endif
	}

#if (PRINTF_ENABLE_FAST)
	if (n) {
 8003efc:	b134      	cbz	r4, 8003f0c <vfprintf+0x40>
		r = f->op->write(f->data, cp, n);
 8003efe:	e89a 0009 	ldmia.w	sl, {r0, r3}
 8003f02:	4629      	mov	r1, r5
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	4622      	mov	r2, r4
 8003f08:	4798      	blx	r3
		cnt+= r;;
 8003f0a:	4481      	add	r9, r0
	}
#endif

	return cnt;
}
 8003f0c:	4648      	mov	r0, r9
 8003f0e:	b009      	add	sp, #36	; 0x24
 8003f10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cnt += f->op->write(f->data, buf, 1);
#endif
			continue;
		}

		if ((c >= '0') && (c <= '9')) {
 8003f14:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8003f18:	2909      	cmp	r1, #9
 8003f1a:	d80d      	bhi.n	8003f38 <vfprintf+0x6c>
			if (!(flags & WIDTH)) {
 8003f1c:	07ba      	lsls	r2, r7, #30
 8003f1e:	d406      	bmi.n	8003f2e <vfprintf+0x62>
				flags |= WIDTH;
				if (c == '0') {
 8003f20:	2b30      	cmp	r3, #48	; 0x30
			continue;
		}

		if ((c >= '0') && (c <= '9')) {
			if (!(flags & WIDTH)) {
				flags |= WIDTH;
 8003f22:	bf14      	ite	ne
 8003f24:	f047 0702 	orrne.w	r7, r7, #2
				if (c == '0') {
					flags |= ZERO;
 8003f28:	f047 0706 	orreq.w	r7, r7, #6
		}

		if ((c >= '0') && (c <= '9')) {
			if (!(flags & WIDTH)) {
				flags |= WIDTH;
				if (c == '0') {
 8003f2c:	d0d9      	beq.n	8003ee2 <vfprintf+0x16>
					flags |= ZERO;
					continue;
				}
			}
			/* w = w * 10 + c - '0' */
			w = (((w << 2) + w) << 1) + (c - '0');
 8003f2e:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8003f32:	eb01 0848 	add.w	r8, r1, r8, lsl #1
			continue;
 8003f36:	e7d4      	b.n	8003ee2 <vfprintf+0x16>
		}

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if (c == '-') {
 8003f38:	2b2d      	cmp	r3, #45	; 0x2d
			flags |= LEFT;
 8003f3a:	bf08      	it	eq
 8003f3c:	f047 0708 	orreq.w	r7, r7, #8
			w = (((w << 2) + w) << 1) + (c - '0');
			continue;
		}

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if (c == '-') {
 8003f40:	d0cf      	beq.n	8003ee2 <vfprintf+0x16>
		if (c == '-')
			continue;
#endif

#if (PRINTF_ENABLE_ARG_WIDTH)
		if (c == '*') {
 8003f42:	2b2a      	cmp	r3, #42	; 0x2a
 8003f44:	d04e      	beq.n	8003fe4 <vfprintf+0x118>
			continue;
		}
#endif

#if (PRINTF_ENABLE_LONG)
		if (c == 'l') {
 8003f46:	2b6c      	cmp	r3, #108	; 0x6c
 8003f48:	d05d      	beq.n	8004006 <vfprintf+0x13a>
			flags |= (flags & LONG) ? LONG2 : LONG;
			continue;
		}
#endif

		if (c == 'c') {
 8003f4a:	2a63      	cmp	r2, #99	; 0x63
 8003f4c:	d062      	beq.n	8004014 <vfprintf+0x148>
			c = va_arg(ap, int);
			goto print_char;
		}

		if (c == 'd') {
 8003f4e:	2b64      	cmp	r3, #100	; 0x64
 8003f50:	d07e      	beq.n	8004050 <vfprintf+0x184>
				n = uint2dec(cp, val.n);
			}
			goto print_buf;
		}

		if (c == 'x') {
 8003f52:	2b78      	cmp	r3, #120	; 0x78
 8003f54:	f000 80ba 	beq.w	80040cc <vfprintf+0x200>
				n = uint2hex(cp, val.n);
			}
			goto print_buf;
		}

		if (c == 's') {
 8003f58:	2b73      	cmp	r3, #115	; 0x73
 8003f5a:	f000 80d5 	beq.w	8004108 <vfprintf+0x23c>
			n = strlen(cp);
			goto print_buf;
		}

#if (PRINTF_ENABLE_UNSIGNED)
		if (c == 'u') {
 8003f5e:	2b75      	cmp	r3, #117	; 0x75
 8003f60:	f000 8092 	beq.w	8004088 <vfprintf+0x1bc>
			goto print_buf;
		}
#endif

#if (PRINTF_ENABLE_POINTER)
		if (c == 'p') {
 8003f64:	2b70      	cmp	r3, #112	; 0x70
 8003f66:	f000 80ef 	beq.w	8004148 <vfprintf+0x27c>
 8003f6a:	2300      	movs	r3, #0
			goto hexadecimal;
		}
#endif
	
		flags = 0;
		w = 0;
 8003f6c:	4698      	mov	r8, r3
			goto print_buf;
		}
#endif

#if (PRINTF_ENABLE_POINTER)
		if (c == 'p') {
 8003f6e:	461c      	mov	r4, r3
			flags |= ZERO;
			goto hexadecimal;
		}
#endif
	
		flags = 0;
 8003f70:	461f      	mov	r7, r3
		w = 0;

print_char:
		cp = buf;
		buf[0] = c;
 8003f72:	f88d 2008 	strb.w	r2, [sp, #8]
	
		flags = 0;
		w = 0;

print_char:
		cp = buf;
 8003f76:	ad02      	add	r5, sp, #8
		buf[0] = c;
		n = 1;
 8003f78:	f04f 0c01 	mov.w	ip, #1

print_buf:
#if (PRINTF_ENABLE_LEFT_ALIGN)
		if (!(flags & LEFT) && (w > n)) {
 8003f7c:	b9b4      	cbnz	r4, 8003fac <vfprintf+0xe0>
 8003f7e:	45e0      	cmp	r8, ip
 8003f80:	dd14      	ble.n	8003fac <vfprintf+0xe0>
#else
		if (w > n) {
#endif
			if (flags & ZERO) {
 8003f82:	077a      	lsls	r2, r7, #29
 8003f84:	f140 8094 	bpl.w	80040b0 <vfprintf+0x1e4>
				if (flags & SIGN) {
 8003f88:	2b00      	cmp	r3, #0
 8003f8a:	f040 80f4 	bne.w	8004176 <vfprintf+0x2aa>
 8003f8e:	461c      	mov	r4, r3
					flags &= ~SIGN;
					cnt += f->op->write(f->data, buf, 1);
				}
				r = f->op->write(f->data, __zeros, w - n);
 8003f90:	e89a 0005 	ldmia.w	sl, {r0, r2}
 8003f94:	4995      	ldr	r1, [pc, #596]	; (80041ec <vfprintf+0x320>)
 8003f96:	6817      	ldr	r7, [r2, #0]
 8003f98:	9301      	str	r3, [sp, #4]
 8003f9a:	ebcc 0208 	rsb	r2, ip, r8
 8003f9e:	f8cd c000 	str.w	ip, [sp]
 8003fa2:	47b8      	blx	r7
 8003fa4:	9b01      	ldr	r3, [sp, #4]
 8003fa6:	f8dd c000 	ldr.w	ip, [sp]
			} else {
				r = f->op->write(f->data, __blanks, w - n);
			}
			cnt += r;
 8003faa:	4481      	add	r9, r0
		}

		if (flags & SIGN) {
 8003fac:	2b00      	cmp	r3, #0
 8003fae:	d143      	bne.n	8004038 <vfprintf+0x16c>
			cnt += f->op->write(f->data, buf, 1);
		}

		cnt += f->op->write(f->data, cp, n);
 8003fb0:	e89a 0009 	ldmia.w	sl, {r0, r3}
 8003fb4:	4662      	mov	r2, ip
 8003fb6:	681b      	ldr	r3, [r3, #0]
 8003fb8:	f8cd c000 	str.w	ip, [sp]
 8003fbc:	4629      	mov	r1, r5
 8003fbe:	4798      	blx	r3

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if ((flags & LEFT) && (w > n)) {
 8003fc0:	f8dd c000 	ldr.w	ip, [sp]

		if (flags & SIGN) {
			cnt += f->op->write(f->data, buf, 1);
		}

		cnt += f->op->write(f->data, cp, n);
 8003fc4:	4481      	add	r9, r0

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if ((flags & LEFT) && (w > n)) {
 8003fc6:	2c00      	cmp	r4, #0
 8003fc8:	d032      	beq.n	8004030 <vfprintf+0x164>
 8003fca:	45e0      	cmp	r8, ip
 8003fcc:	f300 808e 	bgt.w	80040ec <vfprintf+0x220>
		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
		n = 0;
 8003fd0:	f04f 0800 	mov.w	r8, #0

		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
 8003fd4:	4635      	mov	r5, r6
			cnt += r;
		}
#endif

		flags = 0;
		w = 0;
 8003fd6:	4644      	mov	r4, r8
			r = f->op->write(f->data, __blanks, w - n);
			cnt += r;
		}
#endif

		flags = 0;
 8003fd8:	4647      	mov	r7, r8
 8003fda:	e782      	b.n	8003ee2 <vfprintf+0x16>
		if (flags == 0) {
			if (c == '%') {
				w = 0;
				flags = PERCENT;
#if (PRINTF_ENABLE_FAST)
				if (n) {
 8003fdc:	b93c      	cbnz	r4, 8003fee <vfprintf+0x122>
	cp = (char *)fmt;
#endif
	for (flags = 0; (c = *fmt++); ) {
		if (flags == 0) {
			if (c == '%') {
				w = 0;
 8003fde:	46a0      	mov	r8, r4
				flags = PERCENT;
 8003fe0:	2701      	movs	r7, #1
 8003fe2:	e77e      	b.n	8003ee2 <vfprintf+0x16>
			continue;
#endif

#if (PRINTF_ENABLE_ARG_WIDTH)
		if (c == '*') {
			w = va_arg(ap, int);
 8003fe4:	f8db 8000 	ldr.w	r8, [fp]
 8003fe8:	f10b 0b04 	add.w	fp, fp, #4
			continue;
 8003fec:	e779      	b.n	8003ee2 <vfprintf+0x16>
			if (c == '%') {
				w = 0;
				flags = PERCENT;
#if (PRINTF_ENABLE_FAST)
				if (n) {
					n = f->op->write(f->data, cp, n);
 8003fee:	e89a 0009 	ldmia.w	sl, {r0, r3}
 8003ff2:	4629      	mov	r1, r5
 8003ff4:	4622      	mov	r2, r4
 8003ff6:	681b      	ldr	r3, [r3, #0]
 8003ff8:	4798      	blx	r3
					cp = (char *)fmt;
					cnt += n;;
					n = 0;
 8003ffa:	463c      	mov	r4, r7
	cp = (char *)fmt;
#endif
	for (flags = 0; (c = *fmt++); ) {
		if (flags == 0) {
			if (c == '%') {
				w = 0;
 8003ffc:	46b8      	mov	r8, r7
				flags = PERCENT;
#if (PRINTF_ENABLE_FAST)
				if (n) {
					n = f->op->write(f->data, cp, n);
					cp = (char *)fmt;
					cnt += n;;
 8003ffe:	4481      	add	r9, r0
				w = 0;
				flags = PERCENT;
#if (PRINTF_ENABLE_FAST)
				if (n) {
					n = f->op->write(f->data, cp, n);
					cp = (char *)fmt;
 8004000:	4635      	mov	r5, r6
#endif
	for (flags = 0; (c = *fmt++); ) {
		if (flags == 0) {
			if (c == '%') {
				w = 0;
				flags = PERCENT;
 8004002:	2701      	movs	r7, #1
 8004004:	e76d      	b.n	8003ee2 <vfprintf+0x16>
		}
#endif

#if (PRINTF_ENABLE_LONG)
		if (c == 'l') {
			flags |= (flags & LONG) ? LONG2 : LONG;
 8004006:	f017 0f20 	tst.w	r7, #32
 800400a:	bf0c      	ite	eq
 800400c:	2320      	moveq	r3, #32
 800400e:	2340      	movne	r3, #64	; 0x40
 8004010:	431f      	orrs	r7, r3
			continue;
 8004012:	e766      	b.n	8003ee2 <vfprintf+0x16>
		}
#endif

		if (c == 'c') {
			c = va_arg(ap, int);
 8004014:	f8db 2000 	ldr.w	r2, [fp]
 8004018:	f007 0408 	and.w	r4, r7, #8
 800401c:	f007 0310 	and.w	r3, r7, #16
 8004020:	f10b 0b04 	add.w	fp, fp, #4
		flags = 0;
		w = 0;

print_char:
		cp = buf;
		buf[0] = c;
 8004024:	f88d 2008 	strb.w	r2, [sp, #8]
	
		flags = 0;
		w = 0;

print_char:
		cp = buf;
 8004028:	ad02      	add	r5, sp, #8
		buf[0] = c;
		n = 1;
 800402a:	f04f 0c01 	mov.w	ip, #1
 800402e:	e7a5      	b.n	8003f7c <vfprintf+0xb0>
		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
		n = 0;
 8004030:	46a0      	mov	r8, r4

		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
 8004032:	4635      	mov	r5, r6
			r = f->op->write(f->data, __blanks, w - n);
			cnt += r;
		}
#endif

		flags = 0;
 8004034:	4647      	mov	r7, r8
 8004036:	e754      	b.n	8003ee2 <vfprintf+0x16>
			}
			cnt += r;
		}

		if (flags & SIGN) {
			cnt += f->op->write(f->data, buf, 1);
 8004038:	e89a 0009 	ldmia.w	sl, {r0, r3}
 800403c:	a902      	add	r1, sp, #8
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	f8cd c000 	str.w	ip, [sp]
 8004044:	2201      	movs	r2, #1
 8004046:	4798      	blx	r3
 8004048:	f8dd c000 	ldr.w	ip, [sp]
 800404c:	4481      	add	r9, r0
 800404e:	e7af      	b.n	8003fb0 <vfprintf+0xe4>
		}

		if (c == 'd') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
 8004050:	067c      	lsls	r4, r7, #25
 8004052:	d566      	bpl.n	8004122 <vfprintf+0x256>
				val.ll = va_arg(ap, long long);
 8004054:	f10b 0b07 	add.w	fp, fp, #7
 8004058:	f02b 0b07 	bic.w	fp, fp, #7
 800405c:	e9db 4500 	ldrd	r4, r5, [fp]
				if (val.ll < 0) {
 8004060:	2c00      	cmp	r4, #0
 8004062:	f175 0100 	sbcs.w	r1, r5, #0

		if (c == 'd') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ll = va_arg(ap, long long);
 8004066:	462b      	mov	r3, r5
 8004068:	f10b 0b08 	add.w	fp, fp, #8
 800406c:	4622      	mov	r2, r4
			c = va_arg(ap, int);
			goto print_char;
		}

		if (c == 'd') {
			cp = buf;
 800406e:	bfa8      	it	ge
 8004070:	ad02      	addge	r5, sp, #8
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ll = va_arg(ap, long long);
				if (val.ll < 0) {
 8004072:	f2c0 80a1 	blt.w	80041b8 <vfprintf+0x2ec>
					val.ll = -val.ll;
					flags |= SIGN;
					cp++;
					w--;
				}
				n = ull2dec(cp, val.ull);
 8004076:	4628      	mov	r0, r5
 8004078:	f000 f8f8 	bl	800426c <ull2dec>
 800407c:	f007 0408 	and.w	r4, r7, #8
 8004080:	4684      	mov	ip, r0
 8004082:	f007 0310 	and.w	r3, r7, #16
 8004086:	e779      	b.n	8003f7c <vfprintf+0xb0>

#if (PRINTF_ENABLE_UNSIGNED)
		if (c == 'u') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
 8004088:	0679      	lsls	r1, r7, #25
 800408a:	d566      	bpl.n	800415a <vfprintf+0x28e>
				val.ull = va_arg(ap, unsigned long long);
 800408c:	f10b 0b07 	add.w	fp, fp, #7
 8004090:	f02b 0b07 	bic.w	fp, fp, #7
				n = ull2dec(cp, val.ull);
 8004094:	e9db 2300 	ldrd	r2, r3, [fp]
 8004098:	a802      	add	r0, sp, #8
 800409a:	f000 f8e7 	bl	800426c <ull2dec>
#if (PRINTF_ENABLE_UNSIGNED)
		if (c == 'u') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ull = va_arg(ap, unsigned long long);
 800409e:	f10b 0b08 	add.w	fp, fp, #8
 80040a2:	f007 0408 	and.w	r4, r7, #8
				n = ull2dec(cp, val.ull);
 80040a6:	4684      	mov	ip, r0
 80040a8:	f007 0310 	and.w	r3, r7, #16
			goto print_buf;
		}

#if (PRINTF_ENABLE_UNSIGNED)
		if (c == 'u') {
			cp = buf;
 80040ac:	ad02      	add	r5, sp, #8
 80040ae:	e765      	b.n	8003f7c <vfprintf+0xb0>
					flags &= ~SIGN;
					cnt += f->op->write(f->data, buf, 1);
				}
				r = f->op->write(f->data, __zeros, w - n);
			} else {
				r = f->op->write(f->data, __blanks, w - n);
 80040b0:	e89a 0005 	ldmia.w	sl, {r0, r2}
 80040b4:	494e      	ldr	r1, [pc, #312]	; (80041f0 <vfprintf+0x324>)
 80040b6:	6817      	ldr	r7, [r2, #0]
 80040b8:	9301      	str	r3, [sp, #4]
 80040ba:	ebcc 0208 	rsb	r2, ip, r8
 80040be:	f8cd c000 	str.w	ip, [sp]
 80040c2:	47b8      	blx	r7
 80040c4:	f8dd c000 	ldr.w	ip, [sp]
 80040c8:	9b01      	ldr	r3, [sp, #4]
 80040ca:	e76e      	b.n	8003faa <vfprintf+0xde>
		}

		if (c == 'x') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
 80040cc:	0678      	lsls	r0, r7, #25
 80040ce:	d461      	bmi.n	8004194 <vfprintf+0x2c8>
				val.ull = va_arg(ap, unsigned long long);
				n = ull2hex(cp, val.ull);
			} else
#endif
			{
				val.n = va_arg(ap, unsigned int);
 80040d0:	f8db 1000 	ldr.w	r1, [fp]
			}
			goto print_buf;
		}

		if (c == 'x') {
			cp = buf;
 80040d4:	ad02      	add	r5, sp, #8
				val.ull = va_arg(ap, unsigned long long);
				n = ull2hex(cp, val.ull);
			} else
#endif
			{
				val.n = va_arg(ap, unsigned int);
 80040d6:	f10b 0b04 	add.w	fp, fp, #4
#if (PRINTF_ENABLE_POINTER)
hexadecimal:
#endif
				n = uint2hex(cp, val.n);
 80040da:	4628      	mov	r0, r5
 80040dc:	f000 f8fe 	bl	80042dc <uint2hex>
 80040e0:	f007 0408 	and.w	r4, r7, #8
 80040e4:	4684      	mov	ip, r0
 80040e6:	f007 0310 	and.w	r3, r7, #16
 80040ea:	e747      	b.n	8003f7c <vfprintf+0xb0>

		cnt += f->op->write(f->data, cp, n);

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if ((flags & LEFT) && (w > n)) {
			r = f->op->write(f->data, __blanks, w - n);
 80040ec:	e89a 0009 	ldmia.w	sl, {r0, r3}
 80040f0:	ebcc 0208 	rsb	r2, ip, r8
 80040f4:	681b      	ldr	r3, [r3, #0]
 80040f6:	493e      	ldr	r1, [pc, #248]	; (80041f0 <vfprintf+0x324>)
 80040f8:	4798      	blx	r3
		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
		n = 0;
 80040fa:	f04f 0800 	mov.w	r8, #0
		cnt += f->op->write(f->data, cp, n);

#if (PRINTF_ENABLE_LEFT_ALIGN)
		if ((flags & LEFT) && (w > n)) {
			r = f->op->write(f->data, __blanks, w - n);
			cnt += r;
 80040fe:	4481      	add	r9, r0

		flags = 0;
		w = 0;

#if (PRINTF_ENABLE_FAST)
		cp = (char *)fmt;
 8004100:	4635      	mov	r5, r6
			cnt += r;
		}
#endif

		flags = 0;
		w = 0;
 8004102:	4644      	mov	r4, r8
			r = f->op->write(f->data, __blanks, w - n);
			cnt += r;
		}
#endif

		flags = 0;
 8004104:	4647      	mov	r7, r8
 8004106:	e6ec      	b.n	8003ee2 <vfprintf+0x16>
			}
			goto print_buf;
		}

		if (c == 's') {
			cp = va_arg(ap, char *);
 8004108:	f8db 5000 	ldr.w	r5, [fp]
			n = strlen(cp);
 800410c:	4628      	mov	r0, r5
 800410e:	f7ff fed3 	bl	8003eb8 <strlen>
			}
			goto print_buf;
		}

		if (c == 's') {
			cp = va_arg(ap, char *);
 8004112:	f10b 0b04 	add.w	fp, fp, #4
			n = strlen(cp);
 8004116:	4684      	mov	ip, r0
 8004118:	f007 0408 	and.w	r4, r7, #8
 800411c:	f007 0310 	and.w	r3, r7, #16
			goto print_buf;
 8004120:	e72c      	b.n	8003f7c <vfprintf+0xb0>
				}
				n = ull2dec(cp, val.ull);
			} else
#endif
			{
				val.i = va_arg(ap, int);
 8004122:	f8db 3000 	ldr.w	r3, [fp]
				if (val.i < 0) {
 8004126:	2b00      	cmp	r3, #0
				}
				n = ull2dec(cp, val.ull);
			} else
#endif
			{
				val.i = va_arg(ap, int);
 8004128:	f10b 0b04 	add.w	fp, fp, #4
 800412c:	461a      	mov	r2, r3
			c = va_arg(ap, int);
			goto print_char;
		}

		if (c == 'd') {
			cp = buf;
 800412e:	bfa8      	it	ge
 8004130:	ad02      	addge	r5, sp, #8
				n = ull2dec(cp, val.ull);
			} else
#endif
			{
				val.i = va_arg(ap, int);
				if (val.i < 0) {
 8004132:	db50      	blt.n	80041d6 <vfprintf+0x30a>
					val.i = -val.i;
					flags |= SIGN;
					cp++;
					w--;
				}
				n = uint2dec(cp, val.n);
 8004134:	4628      	mov	r0, r5
 8004136:	4611      	mov	r1, r2
 8004138:	f000 f86e 	bl	8004218 <uint2dec>
 800413c:	f007 0408 	and.w	r4, r7, #8
 8004140:	4684      	mov	ip, r0
 8004142:	f007 0310 	and.w	r3, r7, #16
 8004146:	e719      	b.n	8003f7c <vfprintf+0xb0>
 8004148:	f8db 1000 	ldr.w	r1, [fp]

#if (PRINTF_ENABLE_POINTER)
		if (c == 'p') {
			val.ptr = va_arg(ap, void *);
			w = 8;
			flags |= ZERO;
 800414c:	f047 0704 	orr.w	r7, r7, #4
		}
#endif

#if (PRINTF_ENABLE_POINTER)
		if (c == 'p') {
			val.ptr = va_arg(ap, void *);
 8004150:	f10b 0b04 	add.w	fp, fp, #4
			w = 8;
 8004154:	f04f 0808 	mov.w	r8, #8
			flags |= ZERO;
			goto hexadecimal;
 8004158:	e7bf      	b.n	80040da <vfprintf+0x20e>
				n = ull2dec(cp, val.ull);
			} else
#endif
			{
				val.n = va_arg(ap, unsigned int);
				n = uint2dec(cp, val.n);
 800415a:	f8db 1000 	ldr.w	r1, [fp]
 800415e:	a802      	add	r0, sp, #8
 8004160:	f000 f85a 	bl	8004218 <uint2dec>
				val.ull = va_arg(ap, unsigned long long);
				n = ull2dec(cp, val.ull);
			} else
#endif
			{
				val.n = va_arg(ap, unsigned int);
 8004164:	f10b 0b04 	add.w	fp, fp, #4
				n = uint2dec(cp, val.n);
 8004168:	4684      	mov	ip, r0
 800416a:	f007 0408 	and.w	r4, r7, #8
 800416e:	f007 0310 	and.w	r3, r7, #16
			goto print_buf;
		}

#if (PRINTF_ENABLE_UNSIGNED)
		if (c == 'u') {
			cp = buf;
 8004172:	ad02      	add	r5, sp, #8
 8004174:	e702      	b.n	8003f7c <vfprintf+0xb0>
		if (w > n) {
#endif
			if (flags & ZERO) {
				if (flags & SIGN) {
					flags &= ~SIGN;
					cnt += f->op->write(f->data, buf, 1);
 8004176:	e89a 0009 	ldmia.w	sl, {r0, r3}
 800417a:	a902      	add	r1, sp, #8
 800417c:	681b      	ldr	r3, [r3, #0]
 800417e:	f8cd c000 	str.w	ip, [sp]
 8004182:	2201      	movs	r2, #1
 8004184:	4798      	blx	r3
 8004186:	4623      	mov	r3, r4
 8004188:	4481      	add	r9, r0
 800418a:	f007 0408 	and.w	r4, r7, #8
 800418e:	f8dd c000 	ldr.w	ip, [sp]
 8004192:	e6fd      	b.n	8003f90 <vfprintf+0xc4>

		if (c == 'x') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ull = va_arg(ap, unsigned long long);
 8004194:	f10b 0b07 	add.w	fp, fp, #7
 8004198:	f02b 0b07 	bic.w	fp, fp, #7
				n = ull2hex(cp, val.ull);
 800419c:	e9db 2300 	ldrd	r2, r3, [fp]
 80041a0:	a802      	add	r0, sp, #8
 80041a2:	f000 f8b7 	bl	8004314 <ull2hex>

		if (c == 'x') {
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ull = va_arg(ap, unsigned long long);
 80041a6:	f10b 0b08 	add.w	fp, fp, #8
 80041aa:	f007 0408 	and.w	r4, r7, #8
				n = ull2hex(cp, val.ull);
 80041ae:	4684      	mov	ip, r0
 80041b0:	f007 0310 	and.w	r3, r7, #16
			}
			goto print_buf;
		}

		if (c == 'x') {
			cp = buf;
 80041b4:	ad02      	add	r5, sp, #8
 80041b6:	e6e1      	b.n	8003f7c <vfprintf+0xb0>
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ll = va_arg(ap, long long);
				if (val.ll < 0) {
					buf[0] = '-';
					val.ll = -val.ll;
 80041b8:	4264      	negs	r4, r4
 80041ba:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
			cp = buf;
#if PRINTF_ENABLE_LONG
			if (flags & LONG2) {
				val.ll = va_arg(ap, long long);
				if (val.ll < 0) {
					buf[0] = '-';
 80041be:	232d      	movs	r3, #45	; 0x2d
 80041c0:	f88d 3008 	strb.w	r3, [sp, #8]
					val.ll = -val.ll;
 80041c4:	4622      	mov	r2, r4
 80041c6:	462b      	mov	r3, r5
					flags |= SIGN;
 80041c8:	f047 0710 	orr.w	r7, r7, #16
					cp++;
					w--;
 80041cc:	f108 38ff 	add.w	r8, r8, #4294967295
				val.ll = va_arg(ap, long long);
				if (val.ll < 0) {
					buf[0] = '-';
					val.ll = -val.ll;
					flags |= SIGN;
					cp++;
 80041d0:	f10d 0509 	add.w	r5, sp, #9
 80041d4:	e74f      	b.n	8004076 <vfprintf+0x1aa>
			} else
#endif
			{
				val.i = va_arg(ap, int);
				if (val.i < 0) {
					buf[0] = '-';
 80041d6:	222d      	movs	r2, #45	; 0x2d
 80041d8:	f88d 2008 	strb.w	r2, [sp, #8]
					val.i = -val.i;
					flags |= SIGN;
 80041dc:	f047 0710 	orr.w	r7, r7, #16
#endif
			{
				val.i = va_arg(ap, int);
				if (val.i < 0) {
					buf[0] = '-';
					val.i = -val.i;
 80041e0:	425a      	negs	r2, r3
					flags |= SIGN;
					cp++;
					w--;
 80041e2:	f108 38ff 	add.w	r8, r8, #4294967295
				val.i = va_arg(ap, int);
				if (val.i < 0) {
					buf[0] = '-';
					val.i = -val.i;
					flags |= SIGN;
					cp++;
 80041e6:	f10d 0509 	add.w	r5, sp, #9
 80041ea:	e7a3      	b.n	8004134 <vfprintf+0x268>
 80041ec:	080053c4 	.word	0x080053c4
 80041f0:	080053e4 	.word	0x080053e4

080041f4 <abort>:
 */ 

#include <stdlib.h>

void abort(void)
{
 80041f4:	e7fe      	b.n	80041f4 <abort>
 80041f6:	bf00      	nop

080041f8 <fputc>:

#include <stdio.h>
#include <sys/file.h>

int fputc(int c, FILE * f)
{
 80041f8:	b530      	push	{r4, r5, lr}
 80041fa:	b083      	sub	sp, #12
	char buf[1];

	buf[0] = c;
 80041fc:	ab02      	add	r3, sp, #8

#include <stdio.h>
#include <sys/file.h>

int fputc(int c, FILE * f)
{
 80041fe:	4604      	mov	r4, r0
	char buf[1];

	buf[0] = c;
 8004200:	f803 0d04 	strb.w	r0, [r3, #-4]!

	f->op->write(f->data, (void *)buf, sizeof(char));
 8004204:	e891 0005 	ldmia.w	r1, {r0, r2}
 8004208:	4619      	mov	r1, r3
 800420a:	6815      	ldr	r5, [r2, #0]
 800420c:	2201      	movs	r2, #1
 800420e:	47a8      	blx	r5

	return c;
}
 8004210:	4620      	mov	r0, r4
 8004212:	b003      	add	sp, #12
 8004214:	bd30      	pop	{r4, r5, pc}
 8004216:	bf00      	nop

08004218 <uint2dec>:
	80, 
	8, 
	0 };

int uint2dec(char * s, unsigned int val)
{
 8004218:	b470      	push	{r4, r5, r6}
 800421a:	4606      	mov	r6, r0
	unsigned int dv;
	int n;
	int c;
	int i;

	if (!val) {
 800421c:	b1f9      	cbz	r1, 800425e <uint2dec+0x46>
	800, 
	80, 
	8, 
	0 };

int uint2dec(char * s, unsigned int val)
 800421e:	4d12      	ldr	r5, [pc, #72]	; (8004268 <uint2dec+0x50>)

	dvp = (unsigned int *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 8004220:	f855 3f04 	ldr.w	r3, [r5, #4]!
	unsigned int dv;
	int n;
	int c;
	int i;

	if (!val) {
 8004224:	2204      	movs	r2, #4
 8004226:	2000      	movs	r0, #0

	dvp = (unsigned int *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 8004228:	b1b3      	cbz	r3, 8004258 <uint2dec+0x40>
 800422a:	2400      	movs	r4, #0
		c = 0;
		for (; (i); i >>= 1) {
			if (val >= dv) {
 800422c:	428b      	cmp	r3, r1
				val -= dv;
 800422e:	bf9c      	itt	ls
 8004230:	ebc3 0101 	rsbls	r1, r3, r1
				c += i;
 8004234:	18a4      	addls	r4, r4, r2
			}
			dv >>= 1;
 8004236:	085b      	lsrs	r3, r3, #1
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
		c = 0;
		for (; (i); i >>= 1) {
 8004238:	1052      	asrs	r2, r2, #1
 800423a:	d1f7      	bne.n	800422c <uint2dec+0x14>
				val -= dv;
				c += i;
			}
			dv >>= 1;
		}
		if ((c) || (n)) {
 800423c:	ea54 0300 	orrs.w	r3, r4, r0
 8004240:	bf08      	it	eq
 8004242:	4610      	moveq	r0, r2
 8004244:	d003      	beq.n	800424e <uint2dec+0x36>
			*s++ = c + '0';
 8004246:	3430      	adds	r4, #48	; 0x30
 8004248:	f806 4b01 	strb.w	r4, [r6], #1
			n++;
 800424c:	3001      	adds	r0, #1

	dvp = (unsigned int *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 800424e:	f855 3f04 	ldr.w	r3, [r5, #4]!
 8004252:	2208      	movs	r2, #8
 8004254:	2b00      	cmp	r3, #0
 8004256:	d1e8      	bne.n	800422a <uint2dec+0x12>
			*s++ = c + '0';
			n++;
		}
		i = 8;
	};
	*s = '\0';
 8004258:	7033      	strb	r3, [r6, #0]

	return n;
}
 800425a:	bc70      	pop	{r4, r5, r6}
 800425c:	4770      	bx	lr
	int n;
	int c;
	int i;

	if (!val) {
		*s++ = '0';
 800425e:	2330      	movs	r3, #48	; 0x30
 8004260:	7003      	strb	r3, [r0, #0]
		*s = '\0';
 8004262:	7041      	strb	r1, [r0, #1]
		return 1;
 8004264:	2001      	movs	r0, #1
 8004266:	e7f8      	b.n	800425a <uint2dec+0x42>
 8004268:	08005420 	.word	0x08005420

0800426c <ull2dec>:
	unsigned long long dv;
	int n;
	int c;
	int i;

	if (!val) {
 800426c:	ea52 0103 	orrs.w	r1, r2, r3
	80LL, 
	8LL, 
	0LL };

int ull2dec(char * s, unsigned long long val)
{
 8004270:	b4f0      	push	{r4, r5, r6, r7}
 8004272:	4684      	mov	ip, r0
	unsigned long long dv;
	int n;
	int c;
	int i;

	if (!val) {
 8004274:	d029      	beq.n	80042ca <ull2dec+0x5e>
	800LL, 
	80LL, 
	8LL, 
	0LL };

int ull2dec(char * s, unsigned long long val)
 8004276:	4f18      	ldr	r7, [pc, #96]	; (80042d8 <ull2dec+0x6c>)

	dvp = (unsigned long long *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 8004278:	e9f7 4502 	ldrd	r4, r5, [r7, #8]!
	unsigned long long dv;
	int n;
	int c;
	int i;

	if (!val) {
 800427c:	2104      	movs	r1, #4
 800427e:	2000      	movs	r0, #0

	dvp = (unsigned long long *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 8004280:	ea54 0605 	orrs.w	r6, r4, r5
 8004284:	d01c      	beq.n	80042c0 <ull2dec+0x54>
 8004286:	2600      	movs	r6, #0
		c = 0;
		for (; (i); i >>= 1) {
			if (val >= dv) {
 8004288:	42ab      	cmp	r3, r5
 800428a:	bf08      	it	eq
 800428c:	42a2      	cmpeq	r2, r4
 800428e:	d303      	bcc.n	8004298 <ull2dec+0x2c>
				val -= dv;
 8004290:	1b12      	subs	r2, r2, r4
 8004292:	eb63 0305 	sbc.w	r3, r3, r5
				c += i;
 8004296:	1876      	adds	r6, r6, r1
			}
			dv >>= 1;
 8004298:	086d      	lsrs	r5, r5, #1
 800429a:	ea4f 0434 	mov.w	r4, r4, rrx
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
		c = 0;
		for (; (i); i >>= 1) {
 800429e:	1049      	asrs	r1, r1, #1
 80042a0:	d1f2      	bne.n	8004288 <ull2dec+0x1c>
				val -= dv;
				c += i;
			}
			dv >>= 1;
		}
		if ((c) || (n)) {
 80042a2:	ea56 0400 	orrs.w	r4, r6, r0
 80042a6:	bf08      	it	eq
 80042a8:	4608      	moveq	r0, r1
 80042aa:	d003      	beq.n	80042b4 <ull2dec+0x48>
			*s++ = c + '0';
 80042ac:	3630      	adds	r6, #48	; 0x30
 80042ae:	f80c 6b01 	strb.w	r6, [ip], #1
			n++;
 80042b2:	3001      	adds	r0, #1

	dvp = (unsigned long long *)__div_tab;
	n = 0;
	c = 0;
	i = 4;
	while ((dv = *dvp++)) {	
 80042b4:	e9f7 4502 	ldrd	r4, r5, [r7, #8]!
 80042b8:	2108      	movs	r1, #8
 80042ba:	ea54 0605 	orrs.w	r6, r4, r5
 80042be:	d1e2      	bne.n	8004286 <ull2dec+0x1a>
			*s++ = c + '0';
			n++;
		}
		i = 8;
	};
	*s = '\0';
 80042c0:	2300      	movs	r3, #0
 80042c2:	f88c 3000 	strb.w	r3, [ip]

	return n;
}
 80042c6:	bcf0      	pop	{r4, r5, r6, r7}
 80042c8:	4770      	bx	lr
	int n;
	int c;
	int i;

	if (!val) {
		*s++ = '0';
 80042ca:	2330      	movs	r3, #48	; 0x30
 80042cc:	7003      	strb	r3, [r0, #0]
		*s = '\0';
 80042ce:	2300      	movs	r3, #0
 80042d0:	7043      	strb	r3, [r0, #1]
		return 1;
 80042d2:	2001      	movs	r0, #1
 80042d4:	e7f7      	b.n	80042c6 <ull2dec+0x5a>
 80042d6:	bf00      	nop
 80042d8:	08005448 	.word	0x08005448

080042dc <uint2hex>:
const char __hextab[] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

int uint2hex(char * s, unsigned int val)
{
 80042dc:	b470      	push	{r4, r5, r6}
	int n;
	int c;
	int i;

	/* value is zero ? */
	if (!val) {
 80042de:	b189      	cbz	r1, 8004304 <uint2hex+0x28>
	n = 0;
	for (i = 0; i < (sizeof(unsigned int) * 2); i++) {
		c = val >> ((sizeof(unsigned int) * 8) - 4);
		val <<= 4;
		if ((c != 0) || (n != 0)) {
			s[n++] = __hextab[c];
 80042e0:	4e0b      	ldr	r6, [pc, #44]	; (8004310 <uint2hex+0x34>)
	int n;
	int c;
	int i;

	/* value is zero ? */
	if (!val) {
 80042e2:	2408      	movs	r4, #8
 80042e4:	2300      	movs	r3, #0
		return 1;
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned int) * 2); i++) {
		c = val >> ((sizeof(unsigned int) * 8) - 4);
 80042e6:	0f0a      	lsrs	r2, r1, #28
		val <<= 4;
 80042e8:	0109      	lsls	r1, r1, #4
		if ((c != 0) || (n != 0)) {
 80042ea:	ea52 0503 	orrs.w	r5, r2, r3
			s[n++] = __hextab[c];
 80042ee:	bf17      	itett	ne
 80042f0:	5cb2      	ldrbne	r2, [r6, r2]

	n = 0;
	for (i = 0; i < (sizeof(unsigned int) * 2); i++) {
		c = val >> ((sizeof(unsigned int) * 8) - 4);
		val <<= 4;
		if ((c != 0) || (n != 0)) {
 80042f2:	462b      	moveq	r3, r5
			s[n++] = __hextab[c];
 80042f4:	54c2      	strbne	r2, [r0, r3]
 80042f6:	3301      	addne	r3, #1
		*s = '\0';
		return 1;
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned int) * 2); i++) {
 80042f8:	3c01      	subs	r4, #1
 80042fa:	d1f4      	bne.n	80042e6 <uint2hex+0xa>
		if ((c != 0) || (n != 0)) {
			s[n++] = __hextab[c];
		}
	}

	s[n] = '\0';
 80042fc:	54c4      	strb	r4, [r0, r3]

	return n;
}
 80042fe:	4618      	mov	r0, r3
 8004300:	bc70      	pop	{r4, r5, r6}
 8004302:	4770      	bx	lr
	int c;
	int i;

	/* value is zero ? */
	if (!val) {
		*s++ = '0';
 8004304:	2330      	movs	r3, #48	; 0x30
 8004306:	7003      	strb	r3, [r0, #0]
		*s = '\0';
 8004308:	7041      	strb	r1, [r0, #1]
		return 1;
 800430a:	2301      	movs	r3, #1
 800430c:	e7f7      	b.n	80042fe <uint2hex+0x22>
 800430e:	bf00      	nop
 8004310:	080054f8 	.word	0x080054f8

08004314 <ull2hex>:
	int n;
	int c;
	int i;

	/* value is zero ? */
	if (val == 0) {
 8004314:	ea52 0103 	orrs.w	r1, r2, r3
 */ 

extern const char __hextab[];

int ull2hex(char * s, unsigned long long val)
{
 8004318:	b4f0      	push	{r4, r5, r6, r7}
	int n;
	int c;
	int i;

	/* value is zero ? */
	if (val == 0) {
 800431a:	d018      	beq.n	800434e <ull2hex+0x3a>
	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
		c = val >> ((sizeof(unsigned long long) * 8) - 4);
		val <<= 4;
		if ((c != 0) || (n != 0)) {
			s[n++] = __hextab[c];
 800431c:	f8df c03c 	ldr.w	ip, [pc, #60]	; 800435c <ull2hex+0x48>
	int n;
	int c;
	int i;

	/* value is zero ? */
	if (val == 0) {
 8004320:	2610      	movs	r6, #16
 8004322:	2100      	movs	r1, #0
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
		c = val >> ((sizeof(unsigned long long) * 8) - 4);
		val <<= 4;
 8004324:	011c      	lsls	r4, r3, #4
		return 1;
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
		c = val >> ((sizeof(unsigned long long) * 8) - 4);
 8004326:	0f1d      	lsrs	r5, r3, #28
		val <<= 4;
 8004328:	ea44 7412 	orr.w	r4, r4, r2, lsr #28
 800432c:	0117      	lsls	r7, r2, #4
 800432e:	4623      	mov	r3, r4
		if ((c != 0) || (n != 0)) {
 8004330:	ea55 0401 	orrs.w	r4, r5, r1
			s[n++] = __hextab[c];
 8004334:	bf17      	itett	ne
 8004336:	f81c 4005 	ldrbne.w	r4, [ip, r5]

	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
		c = val >> ((sizeof(unsigned long long) * 8) - 4);
		val <<= 4;
		if ((c != 0) || (n != 0)) {
 800433a:	4621      	moveq	r1, r4
			s[n++] = __hextab[c];
 800433c:	5444      	strbne	r4, [r0, r1]
 800433e:	3101      	addne	r1, #1
		*s = '\0';
		return 1;
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
 8004340:	3e01      	subs	r6, #1
		c = val >> ((sizeof(unsigned long long) * 8) - 4);
		val <<= 4;
 8004342:	463a      	mov	r2, r7
		*s = '\0';
		return 1;
	}

	n = 0;
	for (i = 0; i < (sizeof(unsigned long long) * 2); i++) {
 8004344:	d1ee      	bne.n	8004324 <ull2hex+0x10>
		if ((c != 0) || (n != 0)) {
			s[n++] = __hextab[c];
		}
	}

	s[n] = '\0';
 8004346:	5446      	strb	r6, [r0, r1]

	return n;
}
 8004348:	4608      	mov	r0, r1
 800434a:	bcf0      	pop	{r4, r5, r6, r7}
 800434c:	4770      	bx	lr
	int c;
	int i;

	/* value is zero ? */
	if (val == 0) {
		*s++ = '0';
 800434e:	2330      	movs	r3, #48	; 0x30
 8004350:	7003      	strb	r3, [r0, #0]
		*s = '\0';
 8004352:	2300      	movs	r3, #0
 8004354:	7043      	strb	r3, [r0, #1]
		return 1;
 8004356:	2101      	movs	r1, #1
 8004358:	e7f6      	b.n	8004348 <ull2hex+0x34>
 800435a:	bf00      	nop
 800435c:	080054f8 	.word	0x080054f8

08004360 <ice_comm_sync>:
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 8004360:	f3ef 8113 	mrs	r1, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 8004364:	b671      	cpsid	f
{
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */

	cm3_cpsid_f(); /* disable interrupts and faults */

	ice_comm_blk.dev = DEV_SYNC;
 8004366:	f640 63d4 	movw	r3, #3796	; 0xed4
 800436a:	f2c2 0300 	movt	r3, #8192	; 0x2000
	ice_comm_blk.tx_head = 0;
 800436e:	2200      	movs	r2, #0
{
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */

	cm3_cpsid_f(); /* disable interrupts and faults */

	ice_comm_blk.dev = DEV_SYNC;
 8004370:	2043      	movs	r0, #67	; 0x43
 8004372:	70d8      	strb	r0, [r3, #3]
	ice_comm_blk.tx_head = 0;
 8004374:	801a      	strh	r2, [r3, #0]
	ice_comm_blk.tx_tail = 0;
 8004376:	809a      	strh	r2, [r3, #4]
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 8004378:	f381 8813 	msr	FAULTMASK, r1
 800437c:	4770      	bx	lr
 800437e:	bf00      	nop

08004380 <ice_comm_connect>:

	cm3_faultmask_set(fm);  /* restore fault mask */
}

void ice_comm_connect(void) 
{
 8004380:	b410      	push	{r4}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 8004382:	f3ef 8413 	mrs	r4, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 8004386:	b671      	cpsid	f
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */

	cm3_cpsid_f(); /* disable interrupts and faults */
	ice_comm_blk.dev = DEV_SYNC;
 8004388:	4a08      	ldr	r2, [pc, #32]	; (80043ac <ice_comm_connect+0x2c>)
 800438a:	2343      	movs	r3, #67	; 0x43
 800438c:	70d3      	strb	r3, [r2, #3]
	while (ice_comm_blk.dbg != DBG_CONNECTED) {
 800438e:	4611      	mov	r1, r2
		if (ice_comm_blk.dbg == DBG_SYNC) {
			ice_comm_blk.dev = DEV_CONNECTED;
 8004390:	2065      	movs	r0, #101	; 0x65
{
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */

	cm3_cpsid_f(); /* disable interrupts and faults */
	ice_comm_blk.dev = DEV_SYNC;
	while (ice_comm_blk.dbg != DBG_CONNECTED) {
 8004392:	e003      	b.n	800439c <ice_comm_connect+0x1c>
		if (ice_comm_blk.dbg == DBG_SYNC) {
 8004394:	79cb      	ldrb	r3, [r1, #7]
 8004396:	2b02      	cmp	r3, #2
			ice_comm_blk.dev = DEV_CONNECTED;
 8004398:	bf08      	it	eq
 800439a:	70c8      	strbeq	r0, [r1, #3]
{
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */

	cm3_cpsid_f(); /* disable interrupts and faults */
	ice_comm_blk.dev = DEV_SYNC;
	while (ice_comm_blk.dbg != DBG_CONNECTED) {
 800439c:	79d3      	ldrb	r3, [r2, #7]
 800439e:	2b01      	cmp	r3, #1
 80043a0:	d1f8      	bne.n	8004394 <ice_comm_connect+0x14>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80043a2:	f384 8813 	msr	FAULTMASK, r4
		if (ice_comm_blk.dbg == DBG_SYNC) {
			ice_comm_blk.dev = DEV_CONNECTED;
		}
	}
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 80043a6:	bc10      	pop	{r4}
 80043a8:	4770      	bx	lr
 80043aa:	bf00      	nop
 80043ac:	20000ed4 	.word	0x20000ed4

080043b0 <ice_trace_init>:
#include <sys/ice-comm.h>
#include <sys/dcclog.h>
#include <arch/cortex-m3.h>

void ice_trace_init(void)
{
 80043b0:	b508      	push	{r3, lr}
			0, 
			__FUNCTION__,
			_m
		};

	ice_comm_sync();
 80043b2:	f7ff ffd5 	bl	8004360 <ice_comm_sync>
	ice_comm_w32((uint32_t)&log_entry);
 80043b6:	f240 7090 	movw	r0, #1936	; 0x790
 80043ba:	f2c4 0000 	movt	r0, #16384	; 0x4000
}
 80043be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			__FUNCTION__,
			_m
		};

	ice_comm_sync();
	ice_comm_w32((uint32_t)&log_entry);
 80043c2:	f000 ba05 	b.w	80047d0 <ice_comm_w32>
 80043c6:	bf00      	nop

080043c8 <ice_trace0>:
#include <sys/ice-comm.h>
#include <arch/cortex-m3.h>
#include <sys/dcclog.h>

void ice_trace0(const struct trace_entry * __entry)
{
 80043c8:	b430      	push	{r4, r5}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 80043ca:	f3ef 8513 	mrs	r5, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 80043ce:	b671      	cpsid	f
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */
	unsigned int head;
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 80043d0:	4b0f      	ldr	r3, [pc, #60]	; (8004410 <ice_trace0+0x48>)
 80043d2:	79da      	ldrb	r2, [r3, #7]
 80043d4:	2a01      	cmp	r2, #1
 80043d6:	d006      	beq.n	80043e6 <ice_trace0+0x1e>
		if (ice_comm_blk.dbg == DBG_SYNC)
 80043d8:	79da      	ldrb	r2, [r3, #7]
 80043da:	2a02      	cmp	r2, #2
 80043dc:	d014      	beq.n	8004408 <ice_trace0+0x40>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80043de:	f385 8813 	msr	FAULTMASK, r5
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 1);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (uint32_t)__entry;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 80043e2:	bc30      	pop	{r4, r5}
 80043e4:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 80043e6:	8819      	ldrh	r1, [r3, #0]
 80043e8:	b289      	uxth	r1, r1
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 1);
 80043ea:	889a      	ldrh	r2, [r3, #4]
 80043ec:	4c08      	ldr	r4, [pc, #32]	; (8004410 <ice_trace0+0x48>)
 80043ee:	1a8a      	subs	r2, r1, r2
 80043f0:	b292      	uxth	r2, r2
 80043f2:	2a10      	cmp	r2, #16
 80043f4:	d0f9      	beq.n	80043ea <ice_trace0+0x22>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (uint32_t)__entry;
 80043f6:	f001 030f 	and.w	r3, r1, #15
 80043fa:	3302      	adds	r3, #2
 80043fc:	3101      	adds	r1, #1
	ice_comm_blk.tx_head = head;
 80043fe:	b289      	uxth	r1, r1
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 1);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (uint32_t)__entry;
 8004400:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
	ice_comm_blk.tx_head = head;
 8004404:	8021      	strh	r1, [r4, #0]
 8004406:	e7ea      	b.n	80043de <ice_trace0+0x16>
	unsigned int head;
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 8004408:	2265      	movs	r2, #101	; 0x65
 800440a:	70da      	strb	r2, [r3, #3]
 800440c:	e7e7      	b.n	80043de <ice_trace0+0x16>
 800440e:	bf00      	nop
 8004410:	20000ed4 	.word	0x20000ed4

08004414 <ice_trace1>:
#include <sys/ice-comm.h>
#include <arch/cortex-m3.h>
#include <sys/dcclog.h>

void ice_trace1(const struct trace_entry * __entry, int __a)
{
 8004414:	b470      	push	{r4, r5, r6}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 8004416:	f3ef 8613 	mrs	r6, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 800441a:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 800441c:	4b13      	ldr	r3, [pc, #76]	; (800446c <ice_trace1+0x58>)
 800441e:	79da      	ldrb	r2, [r3, #7]
 8004420:	2a01      	cmp	r2, #1
 8004422:	d006      	beq.n	8004432 <ice_trace1+0x1e>
		if (ice_comm_blk.dbg == DBG_SYNC)
 8004424:	79da      	ldrb	r2, [r3, #7]
 8004426:	2a02      	cmp	r2, #2
 8004428:	d01c      	beq.n	8004464 <ice_trace1+0x50>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 800442a:	f386 8813 	msr	FAULTMASK, r6
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 800442e:	bc70      	pop	{r4, r5, r6}
 8004430:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 8004432:	881c      	ldrh	r4, [r3, #0]
 8004434:	b2a4      	uxth	r4, r4
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 2);
 8004436:	889a      	ldrh	r2, [r3, #4]
 8004438:	4d0c      	ldr	r5, [pc, #48]	; (800446c <ice_trace1+0x58>)
 800443a:	1aa2      	subs	r2, r4, r2
 800443c:	b292      	uxth	r2, r2
 800443e:	f1c2 0210 	rsb	r2, r2, #16
 8004442:	2a01      	cmp	r2, #1
 8004444:	d9f7      	bls.n	8004436 <ice_trace1+0x22>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004446:	1c63      	adds	r3, r4, #1
 8004448:	f004 020f 	and.w	r2, r4, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800444c:	f003 030f 	and.w	r3, r3, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 2);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004450:	3202      	adds	r2, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004452:	3302      	adds	r3, #2
 8004454:	3402      	adds	r4, #2
	ice_comm_blk.tx_head = head;
 8004456:	b2a4      	uxth	r4, r4
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 2);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004458:	f845 0022 	str.w	r0, [r5, r2, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_head = head;
 800445c:	802c      	strh	r4, [r5, #0]
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 2);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800445e:	f845 1023 	str.w	r1, [r5, r3, lsl #2]
 8004462:	e7e2      	b.n	800442a <ice_trace1+0x16>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 8004464:	2265      	movs	r2, #101	; 0x65
 8004466:	70da      	strb	r2, [r3, #3]
 8004468:	e7df      	b.n	800442a <ice_trace1+0x16>
 800446a:	bf00      	nop
 800446c:	20000ed4 	.word	0x20000ed4

08004470 <ice_trace2>:
#include <sys/ice-comm.h>
#include <arch/cortex-m3.h>
#include <sys/dcclog.h>

void ice_trace2(const struct trace_entry * __entry, int __a, int __b)
{
 8004470:	b4f0      	push	{r4, r5, r6, r7}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 8004472:	f3ef 8713 	mrs	r7, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 8004476:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 8004478:	4b16      	ldr	r3, [pc, #88]	; (80044d4 <ice_trace2+0x64>)
 800447a:	79dc      	ldrb	r4, [r3, #7]
 800447c:	2c01      	cmp	r4, #1
 800447e:	d006      	beq.n	800448e <ice_trace2+0x1e>
		if (ice_comm_blk.dbg == DBG_SYNC)
 8004480:	79da      	ldrb	r2, [r3, #7]
 8004482:	2a02      	cmp	r2, #2
 8004484:	d023      	beq.n	80044ce <ice_trace2+0x5e>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 8004486:	f387 8813 	msr	FAULTMASK, r7
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 800448a:	bcf0      	pop	{r4, r5, r6, r7}
 800448c:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 800448e:	881d      	ldrh	r5, [r3, #0]
 8004490:	b2ad      	uxth	r5, r5
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 3);
 8004492:	889c      	ldrh	r4, [r3, #4]
 8004494:	4e0f      	ldr	r6, [pc, #60]	; (80044d4 <ice_trace2+0x64>)
 8004496:	1b2c      	subs	r4, r5, r4
 8004498:	b2a4      	uxth	r4, r4
 800449a:	f1c4 0410 	rsb	r4, r4, #16
 800449e:	2c02      	cmp	r4, #2
 80044a0:	d9f7      	bls.n	8004492 <ice_trace2+0x22>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80044a2:	1c6c      	adds	r4, r5, #1
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80044a4:	1cab      	adds	r3, r5, #2
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 3);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80044a6:	f005 0c0f 	and.w	ip, r5, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80044aa:	f004 040f 	and.w	r4, r4, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 80044ae:	f003 030f 	and.w	r3, r3, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 3);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80044b2:	f10c 0c02 	add.w	ip, ip, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80044b6:	3402      	adds	r4, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 80044b8:	3302      	adds	r3, #2
 80044ba:	3503      	adds	r5, #3
	ice_comm_blk.tx_head = head;
 80044bc:	b2ad      	uxth	r5, r5
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 3);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80044be:	f846 002c 	str.w	r0, [r6, ip, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_head = head;
 80044c2:	8035      	strh	r5, [r6, #0]
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 3);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80044c4:	f846 1024 	str.w	r1, [r6, r4, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 80044c8:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
 80044cc:	e7db      	b.n	8004486 <ice_trace2+0x16>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 80044ce:	2265      	movs	r2, #101	; 0x65
 80044d0:	70da      	strb	r2, [r3, #3]
 80044d2:	e7d8      	b.n	8004486 <ice_trace2+0x16>
 80044d4:	20000ed4 	.word	0x20000ed4

080044d8 <ice_trace3>:
#include <arch/cortex-m3.h>
#include <sys/dcclog.h>

void ice_trace3(const struct trace_entry * __entry, int __a, 
				int __b, int __c)
{
 80044d8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 80044dc:	f3ef 8c13 	mrs	ip, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 80044e0:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 80044e2:	4c1b      	ldr	r4, [pc, #108]	; (8004550 <ice_trace3+0x78>)
 80044e4:	79e5      	ldrb	r5, [r4, #7]
 80044e6:	2d01      	cmp	r5, #1
 80044e8:	d007      	beq.n	80044fa <ice_trace3+0x22>
		if (ice_comm_blk.dbg == DBG_SYNC)
 80044ea:	79e3      	ldrb	r3, [r4, #7]
 80044ec:	2b02      	cmp	r3, #2
 80044ee:	d02c      	beq.n	800454a <ice_trace3+0x72>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80044f0:	f38c 8813 	msr	FAULTMASK, ip
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 80044f4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80044f8:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 80044fa:	8826      	ldrh	r6, [r4, #0]
 80044fc:	b2b6      	uxth	r6, r6
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 4);
 80044fe:	88a5      	ldrh	r5, [r4, #4]
 8004500:	4f13      	ldr	r7, [pc, #76]	; (8004550 <ice_trace3+0x78>)
 8004502:	1b75      	subs	r5, r6, r5
 8004504:	b2ad      	uxth	r5, r5
 8004506:	f1c5 0510 	rsb	r5, r5, #16
 800450a:	2d03      	cmp	r5, #3
 800450c:	d9f7      	bls.n	80044fe <ice_trace3+0x26>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800450e:	f106 0801 	add.w	r8, r6, #1
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004512:	1cb5      	adds	r5, r6, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004514:	1cf4      	adds	r4, r6, #3
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 4);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004516:	f006 090f 	and.w	r9, r6, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800451a:	f008 080f 	and.w	r8, r8, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 800451e:	f005 050f 	and.w	r5, r5, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004522:	f004 040f 	and.w	r4, r4, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 4);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004526:	f109 0902 	add.w	r9, r9, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800452a:	f108 0802 	add.w	r8, r8, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 800452e:	3502      	adds	r5, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004530:	3402      	adds	r4, #2
 8004532:	3604      	adds	r6, #4
	ice_comm_blk.tx_head = head;
 8004534:	b2b6      	uxth	r6, r6
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 4);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004536:	f847 0029 	str.w	r0, [r7, r9, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_head = head;
 800453a:	803e      	strh	r6, [r7, #0]
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 4);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800453c:	f847 1028 	str.w	r1, [r7, r8, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004540:	f847 2025 	str.w	r2, [r7, r5, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004544:	f847 3024 	str.w	r3, [r7, r4, lsl #2]
 8004548:	e7d2      	b.n	80044f0 <ice_trace3+0x18>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 800454a:	2365      	movs	r3, #101	; 0x65
 800454c:	70e3      	strb	r3, [r4, #3]
 800454e:	e7cf      	b.n	80044f0 <ice_trace3+0x18>
 8004550:	20000ed4 	.word	0x20000ed4

08004554 <ice_trace4>:
#include <arch/cortex-m3.h>
#include <sys/dcclog.h>

void ice_trace4(const struct trace_entry * __entry, int __a, 
				int __b, int __c, int __d)
{
 8004554:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 8004558:	f3ef 8c13 	mrs	ip, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 800455c:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 800455e:	4c20      	ldr	r4, [pc, #128]	; (80045e0 <ice_trace4+0x8c>)
 8004560:	79e5      	ldrb	r5, [r4, #7]
 8004562:	2d01      	cmp	r5, #1
 8004564:	d007      	beq.n	8004576 <ice_trace4+0x22>
		if (ice_comm_blk.dbg == DBG_SYNC)
 8004566:	79e3      	ldrb	r3, [r4, #7]
 8004568:	2b02      	cmp	r3, #2
 800456a:	d035      	beq.n	80045d8 <ice_trace4+0x84>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 800456c:	f38c 8813 	msr	FAULTMASK, ip
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 8004570:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8004574:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 8004576:	8826      	ldrh	r6, [r4, #0]
 8004578:	b2b6      	uxth	r6, r6
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
 800457a:	88a5      	ldrh	r5, [r4, #4]
 800457c:	4f18      	ldr	r7, [pc, #96]	; (80045e0 <ice_trace4+0x8c>)
 800457e:	1b75      	subs	r5, r6, r5
 8004580:	b2ad      	uxth	r5, r5
 8004582:	f1c5 0510 	rsb	r5, r5, #16
 8004586:	2d04      	cmp	r5, #4
 8004588:	d9f7      	bls.n	800457a <ice_trace4+0x26>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800458a:	f106 0901 	add.w	r9, r6, #1
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800458e:	f106 0802 	add.w	r8, r6, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004592:	1cf5      	adds	r5, r6, #3
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004594:	f006 0a0f 	and.w	sl, r6, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004598:	f009 090f 	and.w	r9, r9, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 800459c:	f008 080f 	and.w	r8, r8, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 80045a0:	f005 050f 	and.w	r5, r5, #15
 80045a4:	1d34      	adds	r4, r6, #4
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80045a6:	f10a 0a02 	add.w	sl, sl, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80045aa:	f109 0902 	add.w	r9, r9, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 80045ae:	f108 0802 	add.w	r8, r8, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 80045b2:	3502      	adds	r5, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80045b4:	f004 040f 	and.w	r4, r4, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 80045b8:	f847 002a 	str.w	r0, [r7, sl, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80045bc:	3402      	adds	r4, #2
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 80045be:	f847 1029 	str.w	r1, [r7, r9, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80045c2:	3605      	adds	r6, #5
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 80045c4:	f847 2028 	str.w	r2, [r7, r8, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 80045c8:	f847 3025 	str.w	r3, [r7, r5, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80045cc:	9b07      	ldr	r3, [sp, #28]
	ice_comm_blk.tx_head = head;
 80045ce:	b2b6      	uxth	r6, r6
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 5);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80045d0:	f847 3024 	str.w	r3, [r7, r4, lsl #2]
	ice_comm_blk.tx_head = head;
 80045d4:	803e      	strh	r6, [r7, #0]
 80045d6:	e7c9      	b.n	800456c <ice_trace4+0x18>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 80045d8:	2365      	movs	r3, #101	; 0x65
 80045da:	70e3      	strb	r3, [r4, #3]
 80045dc:	e7c6      	b.n	800456c <ice_trace4+0x18>
 80045de:	bf00      	nop
 80045e0:	20000ed4 	.word	0x20000ed4

080045e4 <ice_trace6>:
#include <sys/dcclog.h>

void ice_trace6(const struct trace_entry * __entry, int __a, 
				int __b, int __c, int __d, int __e, 
				int __f)
{
 80045e4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80045e8:	b084      	sub	sp, #16
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 80045ea:	f3ef 8613 	mrs	r6, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 80045ee:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 80045f0:	4f34      	ldr	r7, [pc, #208]	; (80046c4 <ice_trace6+0xe0>)
 80045f2:	79fc      	ldrb	r4, [r7, #7]
 80045f4:	2c01      	cmp	r4, #1
 80045f6:	d008      	beq.n	800460a <ice_trace6+0x26>
		if (ice_comm_blk.dbg == DBG_SYNC)
 80045f8:	79fb      	ldrb	r3, [r7, #7]
 80045fa:	2b02      	cmp	r3, #2
 80045fc:	d05f      	beq.n	80046be <ice_trace6+0xda>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80045fe:	f386 8813 	msr	FAULTMASK, r6
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 8004602:	b004      	add	sp, #16
 8004604:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004608:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 800460a:	883c      	ldrh	r4, [r7, #0]
 800460c:	b2a4      	uxth	r4, r4
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
 800460e:	f8b7 c004 	ldrh.w	ip, [r7, #4]
 8004612:	4d2c      	ldr	r5, [pc, #176]	; (80046c4 <ice_trace6+0xe0>)
 8004614:	ebcc 0c04 	rsb	ip, ip, r4
 8004618:	fa1f fc8c 	uxth.w	ip, ip
 800461c:	f1cc 0c10 	rsb	ip, ip, #16
 8004620:	f1bc 0f06 	cmp.w	ip, #6
 8004624:	d9f3      	bls.n	800460e <ice_trace6+0x2a>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 8004626:	1da7      	adds	r7, r4, #6
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 8004628:	f104 0c05 	add.w	ip, r4, #5
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 800462c:	9702      	str	r7, [sp, #8]
 800462e:	f00c 0c0f 	and.w	ip, ip, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004632:	f004 070f 	and.w	r7, r4, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 8004636:	f8cd c004 	str.w	ip, [sp, #4]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 800463a:	f8dd c008 	ldr.w	ip, [sp, #8]
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800463e:	9703      	str	r7, [sp, #12]
 8004640:	f104 0b01 	add.w	fp, r4, #1
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 8004644:	f00c 070f 	and.w	r7, ip, #15
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004648:	f00b 0b0f 	and.w	fp, fp, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800464c:	f8dd c00c 	ldr.w	ip, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004650:	f10b 0b02 	add.w	fp, fp, #2
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004654:	f10c 0c02 	add.w	ip, ip, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004658:	f8cd b008 	str.w	fp, [sp, #8]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 800465c:	f8dd b004 	ldr.w	fp, [sp, #4]
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004660:	f8cd c00c 	str.w	ip, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004664:	f104 0a02 	add.w	sl, r4, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004668:	f104 0903 	add.w	r9, r4, #3
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 800466c:	f10b 0c02 	add.w	ip, fp, #2
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004670:	f8dd b00c 	ldr.w	fp, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004674:	f00a 0a0f 	and.w	sl, sl, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004678:	f009 090f 	and.w	r9, r9, #15
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800467c:	f845 002b 	str.w	r0, [r5, fp, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004680:	f104 0804 	add.w	r8, r4, #4
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004684:	f10a 0a02 	add.w	sl, sl, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004688:	f109 0902 	add.w	r9, r9, #2
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800468c:	9802      	ldr	r0, [sp, #8]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 800468e:	f008 080f 	and.w	r8, r8, #15
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004692:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 8004696:	f108 0802 	add.w	r8, r8, #2
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 7);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 800469a:	f845 202a 	str.w	r2, [r5, sl, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 800469e:	f845 3029 	str.w	r3, [r5, r9, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80046a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80046a4:	f845 3028 	str.w	r3, [r5, r8, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 80046a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80046aa:	3702      	adds	r7, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 80046ac:	f845 302c 	str.w	r3, [r5, ip, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80046b0:	3407      	adds	r4, #7
 80046b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	ice_comm_blk.tx_head = head;
 80046b4:	b2a4      	uxth	r4, r4
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80046b6:	f845 3027 	str.w	r3, [r5, r7, lsl #2]
	ice_comm_blk.tx_head = head;
 80046ba:	802c      	strh	r4, [r5, #0]
 80046bc:	e79f      	b.n	80045fe <ice_trace6+0x1a>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 80046be:	2365      	movs	r3, #101	; 0x65
 80046c0:	70fb      	strb	r3, [r7, #3]
 80046c2:	e79c      	b.n	80045fe <ice_trace6+0x1a>
 80046c4:	20000ed4 	.word	0x20000ed4

080046c8 <ice_trace7>:
#include <sys/dcclog.h>

void ice_trace7(const struct trace_entry * __entry, int __a, 
				int __b, int __c, int __d, int __e, 
				int __f, int __g)
{
 80046c8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80046cc:	b086      	sub	sp, #24
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 80046ce:	f3ef 8613 	mrs	r6, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 80046d2:	b671      	cpsid	f
	unsigned int head;
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 80046d4:	4f3d      	ldr	r7, [pc, #244]	; (80047cc <ice_trace7+0x104>)
 80046d6:	79fc      	ldrb	r4, [r7, #7]
 80046d8:	2c01      	cmp	r4, #1
 80046da:	d008      	beq.n	80046ee <ice_trace7+0x26>
		if (ice_comm_blk.dbg == DBG_SYNC)
 80046dc:	79fb      	ldrb	r3, [r7, #7]
 80046de:	2b02      	cmp	r3, #2
 80046e0:	d071      	beq.n	80047c6 <ice_trace7+0xfe>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80046e2:	f386 8813 	msr	FAULTMASK, r6
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 80046e6:	b006      	add	sp, #24
 80046e8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80046ec:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 80046ee:	883c      	ldrh	r4, [r7, #0]
 80046f0:	b2a4      	uxth	r4, r4
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
 80046f2:	f8b7 c004 	ldrh.w	ip, [r7, #4]
 80046f6:	4d35      	ldr	r5, [pc, #212]	; (80047cc <ice_trace7+0x104>)
 80046f8:	ebcc 0c04 	rsb	ip, ip, r4
 80046fc:	fa1f fc8c 	uxth.w	ip, ip
 8004700:	f1cc 0c10 	rsb	ip, ip, #16
 8004704:	f1bc 0f07 	cmp.w	ip, #7
 8004708:	d9f3      	bls.n	80046f2 <ice_trace7+0x2a>
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 800470a:	1da7      	adds	r7, r4, #6
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 800470c:	f104 0c05 	add.w	ip, r4, #5
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 8004710:	9705      	str	r7, [sp, #20]
 8004712:	f00c 0c0f 	and.w	ip, ip, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 8004716:	1de7      	adds	r7, r4, #7
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 8004718:	f8cd c004 	str.w	ip, [sp, #4]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 800471c:	f8dd c014 	ldr.w	ip, [sp, #20]
 8004720:	9704      	str	r7, [sp, #16]
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004722:	f004 070f 	and.w	r7, r4, #15
 8004726:	9703      	str	r7, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 8004728:	f00c 070f 	and.w	r7, ip, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 800472c:	f8dd c010 	ldr.w	ip, [sp, #16]
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004730:	f104 0a02 	add.w	sl, r4, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 8004734:	f00c 0c0f 	and.w	ip, ip, #15
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004738:	f00a 0a0f 	and.w	sl, sl, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 800473c:	f8cd c014 	str.w	ip, [sp, #20]
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004740:	f10a 0a02 	add.w	sl, sl, #2
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004744:	f8dd c00c 	ldr.w	ip, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004748:	f8cd a008 	str.w	sl, [sp, #8]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 800474c:	f8dd a004 	ldr.w	sl, [sp, #4]
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004750:	f104 0b01 	add.w	fp, r4, #1
 8004754:	f10c 0c02 	add.w	ip, ip, #2
 8004758:	f8cd c00c 	str.w	ip, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 800475c:	f00b 0b0f 	and.w	fp, fp, #15
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 8004760:	f10a 0c02 	add.w	ip, sl, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 8004764:	f8dd a014 	ldr.w	sl, [sp, #20]
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004768:	f10b 0b02 	add.w	fp, fp, #2
 800476c:	f8cd b010 	str.w	fp, [sp, #16]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 8004770:	f10a 0b02 	add.w	fp, sl, #2
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 8004774:	f8dd a00c 	ldr.w	sl, [sp, #12]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004778:	f104 0903 	add.w	r9, r4, #3
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
 800477c:	f845 002a 	str.w	r0, [r5, sl, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004780:	9804      	ldr	r0, [sp, #16]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 8004782:	f009 090f 	and.w	r9, r9, #15
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
 8004786:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 800478a:	f104 0804 	add.w	r8, r4, #4
 800478e:	f109 0902 	add.w	r9, r9, #2
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004792:	9902      	ldr	r1, [sp, #8]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 8004794:	f008 080f 	and.w	r8, r8, #15
	}
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
 8004798:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 800479c:	f108 0802 	add.w	r8, r8, #2
	head = ice_comm_blk.tx_head;
	while ((16 - ((head - ice_comm_blk.tx_tail) & 0xffff)) < 8);
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
 80047a0:	f845 3029 	str.w	r3, [r5, r9, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
 80047a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80047a6:	f845 3028 	str.w	r3, [r5, r8, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 80047aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80047ac:	3702      	adds	r7, #2
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = (int)__entry;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
 80047ae:	f845 302c 	str.w	r3, [r5, ip, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80047b2:	9b10      	ldr	r3, [sp, #64]	; 0x40
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 80047b4:	3408      	adds	r4, #8
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __a;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
 80047b6:	f845 3027 	str.w	r3, [r5, r7, lsl #2]
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 80047ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
	ice_comm_blk.tx_head = head;
 80047bc:	b2a4      	uxth	r4, r4
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __b;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __c;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __d;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __e;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __f;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = __g;
 80047be:	f845 302b 	str.w	r3, [r5, fp, lsl #2]
	ice_comm_blk.tx_head = head;
 80047c2:	802c      	strh	r4, [r5, #0]
 80047c4:	e78d      	b.n	80046e2 <ice_trace7+0x1a>
	int fm = cm3_faultmask_get(); /* save fault mask */
	
	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 80047c6:	2365      	movs	r3, #101	; 0x65
 80047c8:	70fb      	strb	r3, [r7, #3]
 80047ca:	e78a      	b.n	80046e2 <ice_trace7+0x1a>
 80047cc:	20000ed4 	.word	0x20000ed4

080047d0 <ice_comm_w32>:

#include <sys/ice-comm.h>
#include <arch/cortex-m3.h>

void ice_comm_w32(uint32_t data) 
{
 80047d0:	b410      	push	{r4}
}

static inline uint32_t __attribute__((always_inline)) cm3_faultmask_get(void) {
	uint32_t val;
	asm volatile ("mrs %0, FAULTMASK\n" : "=r" (val));
 80047d2:	f3ef 8213 	mrs	r2, FAULTMASK
	asm volatile ("cpsie i\n");
}

/* disable interrupts and fault handlers (set fault mask) */
static inline void __attribute__((always_inline)) cm3_cpsid_f(void) {
	asm volatile ("cpsid f\n");
 80047d6:	b671      	cpsid	f
	uint32_t fm = cm3_faultmask_get(); /* save fault mask */
	unsigned int head;

	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
 80047d8:	4b0c      	ldr	r3, [pc, #48]	; (800480c <ice_comm_w32+0x3c>)
 80047da:	79d9      	ldrb	r1, [r3, #7]
 80047dc:	2901      	cmp	r1, #1
 80047de:	d006      	beq.n	80047ee <ice_comm_w32+0x1e>
		if (ice_comm_blk.dbg == DBG_SYNC)
 80047e0:	79d9      	ldrb	r1, [r3, #7]
 80047e2:	2902      	cmp	r1, #2
 80047e4:	d00e      	beq.n	8004804 <ice_comm_w32+0x34>
	asm volatile ("mrs %0, PRIMASK\n" : "=r" (val));
	return val;
}

static inline void __attribute__((always_inline)) cm3_faultmask_set(uint32_t val) {
	asm volatile ("msr FAULTMASK, %0\n" : : "r" (val));
 80047e6:	f382 8813 	msr	FAULTMASK, r2
	head = ice_comm_blk.tx_head;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = data;
	ice_comm_blk.tx_head = head;
ret:
	cm3_faultmask_set(fm);  /* restore fault mask */
}
 80047ea:	bc10      	pop	{r4}
 80047ec:	4770      	bx	lr
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
 80047ee:	8819      	ldrh	r1, [r3, #0]
 80047f0:	b289      	uxth	r1, r1
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = data;
 80047f2:	f001 040f 	and.w	r4, r1, #15
 80047f6:	3402      	adds	r4, #2
 80047f8:	3101      	adds	r1, #1
	ice_comm_blk.tx_head = head;
 80047fa:	b289      	uxth	r1, r1
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
		goto ret;
	}
	head = ice_comm_blk.tx_head;
	ice_comm_blk.tx_buf.u32[head++ & 0xf] = data;
 80047fc:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
	ice_comm_blk.tx_head = head;
 8004800:	8019      	strh	r1, [r3, #0]
 8004802:	e7f0      	b.n	80047e6 <ice_comm_w32+0x16>
	unsigned int head;

	cm3_cpsid_f(); /* disable interrupts and faults */
	if (ice_comm_blk.dbg != DBG_CONNECTED) {
		if (ice_comm_blk.dbg == DBG_SYNC)
			ice_comm_blk.dev = DEV_CONNECTED;
 8004804:	2165      	movs	r1, #101	; 0x65
 8004806:	70d9      	strb	r1, [r3, #3]
 8004808:	e7ed      	b.n	80047e6 <ice_comm_w32+0x16>
 800480a:	bf00      	nop
 800480c:	20000ed4 	.word	0x20000ed4
 8004810:	2d2d2d2d 	.word	0x2d2d2d2d
 8004814:	2d2d2d2d 	.word	0x2d2d2d2d
 8004818:	2d2d2d2d 	.word	0x2d2d2d2d
 800481c:	2d2d2d2d 	.word	0x2d2d2d2d
 8004820:	2d2d2d2d 	.word	0x2d2d2d2d
 8004824:	2d2d2d2d 	.word	0x2d2d2d2d
 8004828:	2d2d2d2d 	.word	0x2d2d2d2d
 800482c:	2d2d2d2d 	.word	0x2d2d2d2d
 8004830:	2d2d2d2d 	.word	0x2d2d2d2d
 8004834:	2d2d2d2d 	.word	0x2d2d2d2d
 8004838:	2d2d2d2d 	.word	0x2d2d2d2d
 800483c:	2d2d2d2d 	.word	0x2d2d2d2d
 8004840:	2d2d2d2d 	.word	0x2d2d2d2d
 8004844:	2d2d2d2d 	.word	0x2d2d2d2d
 8004848:	0000002d 	.word	0x0000002d
 800484c:	69685420 	.word	0x69685420
 8004850:	534f6b6e 	.word	0x534f6b6e
 8004854:	41202d20 	.word	0x41202d20
 8004858:	636f6c6c 	.word	0x636f6c6c
 800485c:	6d656420 	.word	0x6d656420
 8004860:	0000006f 	.word	0x0000006f
 8004864:	52524523 	.word	0x52524523
 8004868:	203a524f 	.word	0x203a524f
 800486c:	6e696874 	.word	0x6e696874
 8004870:	5f736f6b 	.word	0x5f736f6b
 8004874:	6574756d 	.word	0x6574756d
 8004878:	6c615f78 	.word	0x6c615f78
 800487c:	28636f6c 	.word	0x28636f6c
 8004880:	61662029 	.word	0x61662029
 8004884:	64656c69 	.word	0x64656c69
 8004888:	00000021 	.word	0x00000021
 800488c:	25202d20 	.word	0x25202d20
 8004890:	756d2064 	.word	0x756d2064
 8004894:	73786574 	.word	0x73786574
 8004898:	6425203a 	.word	0x6425203a
 800489c:	64252e2e 	.word	0x64252e2e
 80048a0:	00000a20 	.word	0x00000a20
 80048a4:	52524523 	.word	0x52524523
 80048a8:	203a524f 	.word	0x203a524f
 80048ac:	6574756d 	.word	0x6574756d
 80048b0:	6f6c5f78 	.word	0x6f6c5f78
 80048b4:	25286b63 	.word	0x25286b63
 80048b8:	66202964 	.word	0x66202964
 80048bc:	656c6961 	.word	0x656c6961
 80048c0:	000a2164 	.word	0x000a2164
 80048c4:	52524523 	.word	0x52524523
 80048c8:	203a524f 	.word	0x203a524f
 80048cc:	6574756d 	.word	0x6574756d
 80048d0:	6e755f78 	.word	0x6e755f78
 80048d4:	6b636f6c 	.word	0x6b636f6c
 80048d8:	29642528 	.word	0x29642528
 80048dc:	69616620 	.word	0x69616620
 80048e0:	2164656c 	.word	0x2164656c
 80048e4:	0000000a 	.word	0x0000000a
 80048e8:	52524523 	.word	0x52524523
 80048ec:	203a524f 	.word	0x203a524f
 80048f0:	6574756d 	.word	0x6574756d
 80048f4:	72665f78 	.word	0x72665f78
 80048f8:	25286565 	.word	0x25286565
 80048fc:	66202964 	.word	0x66202964
 8004900:	656c6961 	.word	0x656c6961
 8004904:	000a2164 	.word	0x000a2164
 8004908:	52524523 	.word	0x52524523
 800490c:	203a524f 	.word	0x203a524f
 8004910:	6e696874 	.word	0x6e696874
 8004914:	5f736f6b 	.word	0x5f736f6b
 8004918:	646e6f63 	.word	0x646e6f63
 800491c:	6c6c615f 	.word	0x6c6c615f
 8004920:	2928636f 	.word	0x2928636f
 8004924:	69616620 	.word	0x69616620
 8004928:	2164656c 	.word	0x2164656c
 800492c:	00000000 	.word	0x00000000
 8004930:	25202d20 	.word	0x25202d20
 8004934:	6f632064 	.word	0x6f632064
 8004938:	7469646e 	.word	0x7469646e
 800493c:	616e6f69 	.word	0x616e6f69
 8004940:	6176206c 	.word	0x6176206c
 8004944:	62616972 	.word	0x62616972
 8004948:	3a73656c 	.word	0x3a73656c
 800494c:	2e642520 	.word	0x2e642520
 8004950:	2064252e 	.word	0x2064252e
 8004954:	0000000a 	.word	0x0000000a
 8004958:	52524523 	.word	0x52524523
 800495c:	203a524f 	.word	0x203a524f
 8004960:	646e6f63 	.word	0x646e6f63
 8004964:	636f6c5f 	.word	0x636f6c5f
 8004968:	6425286b 	.word	0x6425286b
 800496c:	61662029 	.word	0x61662029
 8004970:	64656c69 	.word	0x64656c69
 8004974:	00000a21 	.word	0x00000a21
 8004978:	52524523 	.word	0x52524523
 800497c:	203a524f 	.word	0x203a524f
 8004980:	646e6f63 	.word	0x646e6f63
 8004984:	6572665f 	.word	0x6572665f
 8004988:	64252865 	.word	0x64252865
 800498c:	61662029 	.word	0x61662029
 8004990:	64656c69 	.word	0x64656c69
 8004994:	00000a21 	.word	0x00000a21
 8004998:	52524523 	.word	0x52524523
 800499c:	203a524f 	.word	0x203a524f
 80049a0:	6e696874 	.word	0x6e696874
 80049a4:	5f736f6b 	.word	0x5f736f6b
 80049a8:	5f6d6573 	.word	0x5f6d6573
 80049ac:	6f6c6c61 	.word	0x6f6c6c61
 80049b0:	20292863 	.word	0x20292863
 80049b4:	6c696166 	.word	0x6c696166
 80049b8:	00216465 	.word	0x00216465
 80049bc:	25202d20 	.word	0x25202d20
 80049c0:	65732064 	.word	0x65732064
 80049c4:	6870616d 	.word	0x6870616d
 80049c8:	7365726f 	.word	0x7365726f
 80049cc:	6425203a 	.word	0x6425203a
 80049d0:	64252e2e 	.word	0x64252e2e
 80049d4:	00000a20 	.word	0x00000a20
 80049d8:	52524523 	.word	0x52524523
 80049dc:	203a524f 	.word	0x203a524f
 80049e0:	6e696874 	.word	0x6e696874
 80049e4:	5f736f6b 	.word	0x5f736f6b
 80049e8:	5f6d6573 	.word	0x5f6d6573
 80049ec:	74736f70 	.word	0x74736f70
 80049f0:	29642528 	.word	0x29642528
 80049f4:	69616620 	.word	0x69616620
 80049f8:	2164656c 	.word	0x2164656c
 80049fc:	0000000a 	.word	0x0000000a
 8004a00:	52524523 	.word	0x52524523
 8004a04:	203a524f 	.word	0x203a524f
 8004a08:	6e696874 	.word	0x6e696874
 8004a0c:	5f736f6b 	.word	0x5f736f6b
 8004a10:	5f6d6573 	.word	0x5f6d6573
 8004a14:	74696177 	.word	0x74696177
 8004a18:	29642528 	.word	0x29642528
 8004a1c:	69616620 	.word	0x69616620
 8004a20:	2164656c 	.word	0x2164656c
 8004a24:	0000000a 	.word	0x0000000a
 8004a28:	52524523 	.word	0x52524523
 8004a2c:	203a524f 	.word	0x203a524f
 8004a30:	6e696874 	.word	0x6e696874
 8004a34:	5f736f6b 	.word	0x5f736f6b
 8004a38:	5f6d6573 	.word	0x5f6d6573
 8004a3c:	65657266 	.word	0x65657266
 8004a40:	29642528 	.word	0x29642528
 8004a44:	69616620 	.word	0x69616620
 8004a48:	2164656c 	.word	0x2164656c
 8004a4c:	0000000a 	.word	0x0000000a
 8004a50:	52524523 	.word	0x52524523
 8004a54:	203a524f 	.word	0x203a524f
 8004a58:	6e696874 	.word	0x6e696874
 8004a5c:	5f736f6b 	.word	0x5f736f6b
 8004a60:	615f7665 	.word	0x615f7665
 8004a64:	636f6c6c 	.word	0x636f6c6c
 8004a68:	66202928 	.word	0x66202928
 8004a6c:	656c6961 	.word	0x656c6961
 8004a70:	00002164 	.word	0x00002164
 8004a74:	25202d20 	.word	0x25202d20
 8004a78:	76652064 	.word	0x76652064
 8004a7c:	20746e65 	.word	0x20746e65
 8004a80:	73746573 	.word	0x73746573
 8004a84:	6425203a 	.word	0x6425203a
 8004a88:	64252e2e 	.word	0x64252e2e
 8004a8c:	00000a20 	.word	0x00000a20
 8004a90:	52524523 	.word	0x52524523
 8004a94:	203a524f 	.word	0x203a524f
 8004a98:	6e696874 	.word	0x6e696874
 8004a9c:	5f736f6b 	.word	0x5f736f6b
 8004aa0:	725f7665 	.word	0x725f7665
 8004aa4:	65736961 	.word	0x65736961
 8004aa8:	29642528 	.word	0x29642528
 8004aac:	69616620 	.word	0x69616620
 8004ab0:	2164656c 	.word	0x2164656c
 8004ab4:	0000000a 	.word	0x0000000a
 8004ab8:	52524523 	.word	0x52524523
 8004abc:	203a524f 	.word	0x203a524f
 8004ac0:	6e696874 	.word	0x6e696874
 8004ac4:	5f736f6b 	.word	0x5f736f6b
 8004ac8:	775f7665 	.word	0x775f7665
 8004acc:	28746961 	.word	0x28746961
 8004ad0:	20296425 	.word	0x20296425
 8004ad4:	6c696166 	.word	0x6c696166
 8004ad8:	0a216465 	.word	0x0a216465
 8004adc:	00000000 	.word	0x00000000
 8004ae0:	52524523 	.word	0x52524523
 8004ae4:	203a524f 	.word	0x203a524f
 8004ae8:	6e696874 	.word	0x6e696874
 8004aec:	5f736f6b 	.word	0x5f736f6b
 8004af0:	665f7665 	.word	0x665f7665
 8004af4:	28656572 	.word	0x28656572
 8004af8:	20296425 	.word	0x20296425
 8004afc:	6c696166 	.word	0x6c696166
 8004b00:	0a216465 	.word	0x0a216465
 8004b04:	00000000 	.word	0x00000000
 8004b08:	52524523 	.word	0x52524523
 8004b0c:	203a524f 	.word	0x203a524f
 8004b10:	6e696874 	.word	0x6e696874
 8004b14:	5f736f6b 	.word	0x5f736f6b
 8004b18:	67616c66 	.word	0x67616c66
 8004b1c:	6c6c615f 	.word	0x6c6c615f
 8004b20:	2928636f 	.word	0x2928636f
 8004b24:	69616620 	.word	0x69616620
 8004b28:	2164656c 	.word	0x2164656c
 8004b2c:	00000000 	.word	0x00000000
 8004b30:	25202d20 	.word	0x25202d20
 8004b34:	6c662064 	.word	0x6c662064
 8004b38:	3a736761 	.word	0x3a736761
 8004b3c:	2e642520 	.word	0x2e642520
 8004b40:	2064252e 	.word	0x2064252e
 8004b44:	0000000a 	.word	0x0000000a
 8004b48:	52524523 	.word	0x52524523
 8004b4c:	203a524f 	.word	0x203a524f
 8004b50:	67616c66 	.word	0x67616c66
 8004b54:	6769735f 	.word	0x6769735f
 8004b58:	286c616e 	.word	0x286c616e
 8004b5c:	20296425 	.word	0x20296425
 8004b60:	6c696166 	.word	0x6c696166
 8004b64:	0a216465 	.word	0x0a216465
 8004b68:	00000000 	.word	0x00000000
 8004b6c:	52524523 	.word	0x52524523
 8004b70:	203a524f 	.word	0x203a524f
 8004b74:	67616c66 	.word	0x67616c66
 8004b78:	6961775f 	.word	0x6961775f
 8004b7c:	64252874 	.word	0x64252874
 8004b80:	61662029 	.word	0x61662029
 8004b84:	64656c69 	.word	0x64656c69
 8004b88:	00000a21 	.word	0x00000a21
 8004b8c:	52524523 	.word	0x52524523
 8004b90:	203a524f 	.word	0x203a524f
 8004b94:	67616c66 	.word	0x67616c66
 8004b98:	6572665f 	.word	0x6572665f
 8004b9c:	64252865 	.word	0x64252865
 8004ba0:	61662029 	.word	0x61662029
 8004ba4:	64656c69 	.word	0x64656c69
 8004ba8:	ff000a21 	.word	0xff000a21

08004bac <stm32_gpio_lut>:
 8004bac:	40020000 40020400 40020800 40020c00     ...@...@...@...@
 8004bbc:	40021000 40021400                       ...@...@

08004bc4 <__FUNCTION__.5716>:
 8004bc4:	336d7473 73755f32 5f747261 64756162     stm32_usart_baud
 8004bd4:	65746172 7465735f 00000000              rate_set....

08004be0 <stm32_usart_fops>:
 8004be0:	080015ed 080015d9 080015cd 0800153d     ............=...

08004bf0 <stm32f_otg_fs_dev>:
 8004bf0:	2000000c 08004bf8                       ... .K..

08004bf8 <stm32f_otg_fs_ops>:
 8004bf8:	08000db1 08000935 080008fd 08000901     ....5...........
 8004c08:	080008e1 08000925 08000b35 08000981     ....%...5.......

08004c18 <__FUNCTION__.5986>:
 8004c18:	336d7473 6f5f6632 645f6774 655f7665     stm32f_otg_dev_e
 8004c28:	78745f70 6174735f 00007472              p_tx_start..

08004c34 <__FUNCTION__.6007>:
 8004c34:	336d7473 6f5f6632 645f6774 655f7665     stm32f_otg_dev_e
 8004c44:	6b705f70 65725f74 00007663              p_pkt_recv..

08004c50 <__FUNCTION__.6045>:
 8004c50:	336d7473 6f5f6632 645f6774 655f7665     stm32f_otg_dev_e
 8004c60:	6e695f70 00007469                       p_init..

08004c68 <__FUNCTION__.6284>:
 8004c68:	336d7473 6f5f6632 665f6774 73695f73     stm32f_otg_fs_is
 8004c78:	00000072                                r...

08004c7c <__FUNCTION__.5938>:
 8004c7c:	70655f5f 5f78725f 00706f70              __ep_rx_pop.

08004c88 <__FUNCTION__.6182>:
 8004c88:	336d7473 6f5f6632 645f6774 655f7665     stm32f_otg_dev_e
 8004c98:	695f3070 0000006e                       p0_in...

08004ca0 <__FUNCTION__.5921>:
 8004ca0:	70655f5f 5f78745f 68737570 00000000     __ep_tx_push....

08004cb0 <__FUNCTION__.6212>:
 8004cb0:	336d7473 6f5f6632 645f6774 655f7665     stm32f_otg_dev_e
 8004cc0:	735f3070 70757465 00000000              p0_setup....

08004ccc <stm32f_tim2_hz>:
 8004ccc:	0a037a00                                .z..

08004cd0 <stm32f_apb2_hz>:
 8004cd0:	0501bd00                                ....

08004cd4 <stm32f_tim1_hz>:
 8004cd4:	0501bd00                                ....

08004cd8 <stm32f_apb1_hz>:
 8004cd8:	0280de80                                ....

08004cdc <stm32f_ahb_hz>:
 8004cdc:	0a037a00                                .z..

08004ce0 <cm3_systick_load_1ms>:
 8004ce0:	00005207                                .R..

08004ce4 <stm32_usart_lut>:
 8004ce4:	40011000 40004400 40004800 40004c00     ...@.D.@.H.@.L.@
 8004cf4:	40005000                                .P.@

08004cf8 <stm32_usart_clk_lut>:
 8004cf8:	99918922 00002aa1                       "....*..

08004d00 <stm32_usart_irq_lut>:
 8004d00:	34272625 00000035                       %&'45...

08004d08 <stm32f_otg_fs_ep0_mpsiz_lut>:
 8004d08:	08102040                                @ ..

08004d0c <__FUNCTION__.5810>:
 8004d0c:	336d7473 6f5f6632 665f6774 78745f73     stm32f_otg_fs_tx
 8004d1c:	65735f66 00707574                       f_setup.

08004d24 <__FUNCTION__.5838>:
 8004d24:	336d7473 6f5f6632 665f6774 78745f73     stm32f_otg_fs_tx
 8004d34:	75705f66 00006873                       f_push..

08004d3c <__FUNCTION__.5892>:
 8004d3c:	336d7473 6f5f6632 665f6774 70655f73     stm32f_otg_fs_ep
 8004d4c:	6d75645f 00000070                       _dump...

08004d54 <thinkos_execpt_link>:
 8004d54:	08004ea4                                .N..

08004d58 <thinkos_svc_link>:
 8004d58:	08004d80                                .M..

08004d5c <__FUNCTION__.4881>:
 8004d5c:	6e696874 5f736f6b 65726874 655f6461     thinkos_thread_e
 8004d6c:	00746978                                xit.

08004d70 <__FUNCTION__.4903>:
 8004d70:	6e696874 5f736f6b 74696e69 00000000     thinkos_init....

08004d80 <thinkos_svc_nm>:
 8004d80:	00435653                                SVC.

08004d84 <__FUNCTION__.5285>:
 8004d84:	5f336d63 5f637673 00727369              cm3_svc_isr.

08004d90 <__FUNCTION__.5342>:
 8004d90:	6e696874 5f736f6b 5f717269 74696177     thinkos_irq_wait
 8004da0:	6376735f 00000000                       _svc....

08004da8 <__FUNCTION__.5337>:
 8004da8:	6e696874 5f736f6b 67616c66 6c6c615f     thinkos_flag_all
 8004db8:	735f636f 00006376                       oc_svc..

08004dc0 <__FUNCTION__.5347>:
 8004dc0:	6e696874 5f736f6b 67616c66 6572665f     thinkos_flag_fre
 8004dd0:	76735f65 00000063                       e_svc...

08004dd8 <__FUNCTION__.5358>:
 8004dd8:	6e696874 5f736f6b 67616c66 6961775f     thinkos_flag_wai
 8004de8:	76735f74 00000063                       t_svc...

08004df0 <__FUNCTION__.5378>:
 8004df0:	6e696874 5f736f6b 67616c66 6d69745f     thinkos_flag_tim
 8004e00:	61776465 735f7469 00006376              edwait_svc..

08004e0c <__FUNCTION__.5398>:
 8004e0c:	6e696874 5f736f6b 67616c66 6c65725f     thinkos_flag_rel
 8004e1c:	65736165 6376735f 00000000              ease_svc....

08004e28 <__FUNCTION__.5417>:
 8004e28:	6e696874 5f736f6b 67616c66 6b61745f     thinkos_flag_tak
 8004e38:	76735f65 00000063                       e_svc...

08004e40 <__FUNCTION__.5437>:
 8004e40:	6e696874 5f736f6b 67616c66 6d69745f     thinkos_flag_tim
 8004e50:	61746465 735f656b 00006376              edtake_svc..

08004e5c <__FUNCTION__.5456>:
 8004e5c:	6e696874 5f736f6b 67616c66 7669675f     thinkos_flag_giv
 8004e6c:	76735f65 00000063                       e_svc...

08004e74 <__FUNCTION__.5474>:
 8004e74:	6e696874 5f736f6b 67616c66 726c635f     thinkos_flag_clr
 8004e84:	6376735f 00000000                       _svc....

08004e8c <__FUNCTION__.5489>:
 8004e8c:	6e696874 5f736f6b 67616c66 7465735f     thinkos_flag_set
 8004e9c:	6376735f 00000000                       _svc....

08004ea4 <thinkos_except_nm>:
 8004ea4:	00545845                                EXT.

08004ea8 <__FUNCTION__.6050>:
 8004ea8:	64726168 7561665f 0000746c              hard_fault..

08004eb4 <__FUNCTION__.6112>:
 8004eb4:	5f737562 6c756166 00000074              bus_fault...

08004ec0 <__FUNCTION__.6144>:
 8004ec0:	67617375 61665f65 00746c75 42454420     usage_fault. DEB
 8004ed0:	56454755 00000054 524f4620 00444543     UGEVT... FORCED.
 8004ee0:	43455620 4c425454 00000000 41464220      VECTTBL.... BFA
 8004ef0:	4c415652 00004449 50534c20 00525245     RVALID.. LSPERR.
 8004f00:	4b545320 00525245 564e4920 00004350      STKERR. INVPC..
 8004f10:	504d4920 49434552 52524553 00000000      IMPRECISERR....
 8004f20:	45525020 45534943 00005252 55424920      PRECISERR.. IBU
 8004f30:	52524553 00000000 56494420 455a5942     SERR.... DIVBYZE
 8004f40:	00004f52 414e5520 4e47494c 00004445     RO.. UNALIGNED..
 8004f50:	434f4e20 00000050 564e4920 54415453      NOCP... INVSTAT
 8004f60:	00000045 444e5520 4e494645 00525453     E... UNDEFINSTR.

08004f70 <thinkos_wq_base_lut>:
 8004f70:	00000000 00000000 00020001 00a20052     ............R...
 8004f80:	014200f2 00000000                       ..B.....

08004f88 <thinkos_obj_alloc_lut>:
 8004f88:	00000000 00000000 00000000 00000000     ................
 8004f98:	00000000 00000000 20000c84 20000c90     ........... ... 
 8004fa8:	20000c9c 20000ca8 20000c74 00000000     ... ... t.. ....

08004fb8 <thinkos_obj_type_lut>:
 8004fb8:	05050400 05050505 05050505 05050505     ................
 8004fc8:	05050505 05050505 05050505 05050505     ................
 8004fd8:	05050505 05050505 05050505 05050505     ................
 8004fe8:	05050505 05050505 05050505 05050505     ................
 8004ff8:	05050505 05050505 05050505 05050505     ................
 8005008:	06060505 06060606 06060606 06060606     ................
 8005018:	06060606 06060606 06060606 06060606     ................
 8005028:	06060606 06060606 06060606 06060606     ................
 8005038:	06060606 06060606 06060606 06060606     ................
 8005048:	06060606 06060606 06060606 06060606     ................
 8005058:	07070606 07070707 07070707 07070707     ................
 8005068:	07070707 07070707 07070707 07070707     ................
 8005078:	07070707 07070707 07070707 07070707     ................
 8005088:	07070707 07070707 07070707 07070707     ................
 8005098:	07070707 07070707 07070707 07070707     ................
 80050a8:	08080707 08080808 08080808 08080808     ................
 80050b8:	08080808 08080808 08080808 08080808     ................
 80050c8:	08080808 08080808 08080808 08080808     ................
 80050d8:	08080808 08080808 08080808 08080808     ................
 80050e8:	08080808 08080808 08080808 08080808     ................
 80050f8:	09090808 09090909 09090909 09090909     ................
 8005108:	09090909 09090909 09090909 09090909     ................
 8005118:	09090909 09090909 09090909 09090909     ................
 8005128:	09090909 09090909 09090909 09090909     ................
 8005138:	09090909 09090909 09090909 09090909     ................
 8005148:	00000909                                ....

0800514c <thinkos_main_inf>:
 800514c:	00000000 00000000 4e49414d 00000000     ........MAIN....

0800515c <__FUNCTION__.5197>:
 800515c:	6e696874 5f736f6b 74697865 6376735f     thinkos_exit_svc
 800516c:	00000000                                ....

08005170 <__FUNCTION__.5209>:
 8005170:	6e696874 5f736f6b 65726874 635f6461     thinkos_thread_c
 8005180:	74616572 76735f65 00000063              reate_svc...

0800518c <__FUNCTION__.5196>:
 800518c:	6e696874 5f736f6b 6574756d 72665f78     thinkos_mutex_fr
 800519c:	735f6565 00006376                       ee_svc..

080051a4 <__FUNCTION__.5207>:
 80051a4:	6e696874 5f736f6b 6574756d 6f6c5f78     thinkos_mutex_lo
 80051b4:	735f6b63 00006376                       ck_svc..

080051bc <__FUNCTION__.5234>:
 80051bc:	6e696874 5f736f6b 6574756d 72745f78     thinkos_mutex_tr
 80051cc:	636f6c79 76735f6b 00000063              ylock_svc...

080051d8 <__FUNCTION__.5262>:
 80051d8:	6e696874 5f736f6b 6574756d 69745f78     thinkos_mutex_ti
 80051e8:	6c64656d 5f6b636f 00637673              medlock_svc.

080051f4 <__FUNCTION__.5286>:
 80051f4:	6e696874 5f736f6b 6574756d 6e755f78     thinkos_mutex_un
 8005204:	6b636f6c 6376735f 00000000              lock_svc....

08005210 <__FUNCTION__.5196>:
 8005210:	6e696874 5f736f6b 646e6f63 6572665f     thinkos_cond_fre
 8005220:	76735f65 00000063                       e_svc...

08005228 <__FUNCTION__.5214>:
 8005228:	6e696874 5f736f6b 646e6f63 6961775f     thinkos_cond_wai
 8005238:	76735f74 00000063                       t_svc...

08005240 <__FUNCTION__.5257>:
 8005240:	6e696874 5f736f6b 646e6f63 6d69745f     thinkos_cond_tim
 8005250:	61776465 735f7469 00006376              edwait_svc..

0800525c <__FUNCTION__.5296>:
 800525c:	6e696874 5f736f6b 646e6f63 6769735f     thinkos_cond_sig
 800526c:	5f6c616e 00637673                       nal_svc.

08005274 <__FUNCTION__.5315>:
 8005274:	6e696874 5f736f6b 646e6f63 6f72625f     thinkos_cond_bro
 8005284:	61636461 735f7473 00006376              adcast_svc..

08005290 <__FUNCTION__.5187>:
 8005290:	6e696874 5f736f6b 5f6d6573 6f6c6c61     thinkos_sem_allo
 80052a0:	76735f63 00000063                       c_svc...

080052a8 <__FUNCTION__.5197>:
 80052a8:	6e696874 5f736f6b 5f6d6573 65657266     thinkos_sem_free
 80052b8:	6376735f 00000000                       _svc....

080052c0 <__FUNCTION__.5208>:
 80052c0:	6e696874 5f736f6b 5f6d6573 74696e69     thinkos_sem_init
 80052d0:	6376735f 00000000                       _svc....

080052d8 <__FUNCTION__.5227>:
 80052d8:	6e696874 5f736f6b 5f6d6573 74696177     thinkos_sem_wait
 80052e8:	6376735f 00000000                       _svc....

080052f0 <__FUNCTION__.5245>:
 80052f0:	6e696874 5f736f6b 5f6d6573 77797274     thinkos_sem_tryw
 8005300:	5f746961 00637673                       ait_svc.

08005308 <__FUNCTION__.5261>:
 8005308:	6e696874 5f736f6b 5f6d6573 656d6974     thinkos_sem_time
 8005318:	69617764 76735f74 00000063              dwait_svc...

08005324 <__FUNCTION__.5280>:
 8005324:	6e696874 5f736f6b 5f6d6573 74736f70     thinkos_sem_post
 8005334:	6376735f 00000000                       _svc....

0800533c <__FUNCTION__.5347>:
 800533c:	6e696874 5f736f6b 665f7665 5f656572     thinkos_ev_free_
 800534c:	00637673                                svc.

08005350 <__FUNCTION__.5363>:
 8005350:	6e696874 5f736f6b 775f7665 5f746961     thinkos_ev_wait_
 8005360:	00637673                                svc.

08005364 <__FUNCTION__.5392>:
 8005364:	6e696874 5f736f6b 745f7665 64656d69     thinkos_ev_timed
 8005374:	74696177 6376735f 00000000              wait_svc....

08005380 <__FUNCTION__.5412>:
 8005380:	6e696874 5f736f6b 725f7665 65736961     thinkos_ev_raise
 8005390:	6376735f 00000000                       _svc....

08005398 <__FUNCTION__.5443>:
 8005398:	6e696874 5f736f6b 6d5f7665 5f6b7361     thinkos_ev_mask_
 80053a8:	00637673                                svc.

080053ac <__FUNCTION__.5460>:
 80053ac:	6e696874 5f736f6b 755f7665 73616d6e     thinkos_ev_unmas
 80053bc:	76735f6b 00000063                       k_svc...

080053c4 <__zeros>:
 80053c4:	30303030 30303030 30303030 30303030     0000000000000000
 80053d4:	30303030 30303030 30303030 30303030     0000000000000000

080053e4 <__blanks>:
 80053e4:	20202020 20202020 20202020 20202020                     
 80053f4:	20202020 20202020 20202020 20202020                     
 8005404:	20202020 20202020 20202020 20202020                     
 8005414:	20202020 20202020 20202020 20202020                     

08005424 <__div_tab>:
 8005424:	ee6b2800 2faf0800 04c4b400 007a1200     .(k..../......z.
 8005434:	000c3500 00013880 00001f40 00000320     .5...8..@... ...
 8005444:	00000050 00000008 00000000              P...........

08005450 <__div_tab>:
 8005450:	89e80000 8ac72304 3b200000 6f05b59d     .....#.... ;...o
 8005460:	ec500000 0b1a2bc2 7e080000 011c3793     ..P..+.....~.7..
 8005470:	26340000 001c6bf5 83d20000 0002d798     ..4&.k..........
 8005480:	73950000 000048c2 a5288000 00000746     ...s.H....(.F...
 8005490:	43b74000 000000ba a05f2000 00000012     .@.C..... _.....
 80054a0:	dcd65000 00000001 2faf0800 00000000     .P........./....
 80054b0:	04c4b400 00000000 007a1200 00000000     ..........z.....
 80054c0:	000c3500 00000000 00013880 00000000     .5.......8......
 80054d0:	00001f40 00000000 00000320 00000000     @....... .......
 80054e0:	00000050 00000000 00000008 00000000     P...............
 80054f0:	00000000 00000000                       ........

080054f8 <__hextab>:
 80054f8:	33323130 37363534 62613938 66656463     0123456789abcdef

08005508 <__FUNCTION__.4549>:
 8005508:	5f656369 63617274 6e695f65 00007469     ice_trace_init..
