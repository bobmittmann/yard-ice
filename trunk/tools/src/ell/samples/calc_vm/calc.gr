%token EOF EQU NEQ LT GT GTE LTE LOR LAND ASR SHL PLUS MINUS MUL DIV MOD OR AND XOR INV ASSIGN COMMA SEMICOLON LPAREN RPAREN LBRACE RBRACE VAR PRINT WHILE INT ID TRUE FALSE IF ELSE FOR ERR
%%

program 		: EOF
				| stat program
				;


compound_stat	: LBRACE stat_list RBRACE
				;

stat_list		:
				| stat stat_list
				;

stat			: SEMICOLON
				| FOR LPAREN exp_lst_opt SEMICOLON { op_for_init } exp { op_for_cond } SEMICOLON exp_lst_opt { op_for_after } RPAREN compound_stat { op_for_end }

				| WHILE { op_while_begin } condition { op_while_cond } compound_stat { op_while_end }

				| IF condition { op_if_cond } compound_stat else_opt { op_if_end }

				| PRINT print_list_opt SEMICOLON { op_print_end }
				| VAR var_list SEMICOLON
				| assign_or_call SEMICOLON
				;

print_list_opt	: 
				| print_list
				;

print_list 		: exp { op_print_int } print_list1
				;

print_list1 	: 
				| COMMA { op_print_comma } print_list
				;


else_opt		: 
				| ELSE { op_if_else } compound_stat
				;

condition		: LPAREN exp RPAREN
				;

var_list 		: var var_list1
				;

var_list1 		: 
				| COMMA var_list
				;

var				: ID { op_var_decl, op_lookup_id } var_assign_opt
				;

var_assign_opt  : 
				| ASSIGN { op_push_id_addr } exp { op_assign }
				;

assign_or_call  : ID { op_lookup_id } assign_or_call1
				;

assign_or_call1	: ASSIGN { op_push_id_addr } exp { op_assign }
				;

exp_lst_opt		: 
				| exp_lst
				;

exp_lst			: assign_or_call exp_lst1
				;
				
exp_lst1		: 
				| COMMA exp_lst
				;

exp 			: shift_exp	relational_exp
				;

relational_exp	:
				| EQU exp { op_equ }
				| NEQ exp { op_neq }
				| LT  exp { op_lt }
				| GT  exp { op_gt }
				| GTE exp { op_gte }
				| LTE exp { op_lte }
				;

shift_exp		: additive_exp shift_exp1
				;

shift_exp1		: 
				| SHL shift_exp	{ op_shl }
				| ASR shift_exp	{ op_asr }
				;

additive_exp 	: mult_exp additive_exp1
				;

additive_exp1 	: 
				| PLUS additive_exp { op_add }
				| MINUS additive_exp { op_sub }
				| XOR additive_exp { op_xor }
				| OR additive_exp { op_or }
				| LOR additive_exp { op_logic_or }
				;

mult_exp		: unary_exp mult_exp1		
				;

mult_exp1		: 
				| MUL mult_exp { op_mul }
				| DIV mult_exp { op_div }
				| MOD mult_exp { op_mod }
				| AND mult_exp { op_and }
				| LAND mult_exp { op_logic_and }
				;

unary_exp		: primary_exp
				| INV unary_exp { op_inv }
				| MINUS unary_exp { op_minus }
				| NOT unary_exp { op_not }
				;

primary_exp		: LPAREN exp RPAREN
				| INT { op_push_int }
				| ID { op_lookup_id, op_push_id_addr, op_load_var }
				| TRUE { op_push_true }
				| FALSE { op_push_false }
				;

