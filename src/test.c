/*
Debug Fault Status Register, DFSR
Shows, at the top level, why a debug event occurred.
Writing 1 to a register bit clears the bit to 0.
A read of the HALTED bit by an instruction executed by stepping returns an
value */

/* DFSR bit assignments
EXTERNAL
VCATCH
DWTTRAP
BKPT
HALTED

EXTERNAL
Indicates a debug event generated because of the assertion of EDBGRQ:
0 = No EDBGRQ debug event.
1 = EDBGRQ debug event.

VCATCH
Indicates triggering of a Vector catch:
0 = No Vector catch triggered.
1 = Vector catch triggered.
The corresponding FSR shows the primary cause of the exception.

[2] DWTTRAP
Indicates a debug event generated by the DWT:
0 = No current debug events generated by the DWT.
1 = At least one current debug event generated by the DWT.

[1] BKPT
Indicates a debug event generated by BKPT instruction execution or a breakpoint match in
FPB:
0 = No current breakpoint debug event.
1 = At least one current breakpoint debug event.

[0] HALTED

Indicates a debug event generated by either:
• a C_HALT or C_STEP request, triggered by a write to the DHCSR, see Debug
Halting Control and Status Register, DHCSR on page C1-830
• a step request triggered by setting DEMCR.MON_STEP to 1, see Debug monitor
stepping on page C1-826.
0 = No active halt request debug event.
1 = Halt request debug event active.
*/

/* Debug Halting Control and Status Register, DHCSR */
ARMV7M_DHCSR 0xe000edf0

/* Debug Core Register Selector Register, DCRSR */
ARMV7M_DCRSR 0xe000edf4

/* Debug Core Register Data Register, DCRDR */
ARMV7M_DCRDR 0xe000edf8

/* Debug Exception and Monitor Control Register, DEMCR */
ARMV7M_DEMCR 0xe000edfc

/*
Debug Halting Control and Status Register, DHCSR
Controls halting debug.

• The effect of modifying the C_STEP or C_MASKINTS bit when the system
is running with halting debug enabled is UNPREDICTABLE. Halting debug is
enabled when C_DEBUGEN is set to 1. The system is running when
S_HALT is set to 0.

• When C_DEBUGEN is set to 0, the processor ignores the values of all other
bits in this register.

• DBGKEY
S_RESET_ST
S_RETIRE_ST
S_LOCKUP
S_SLEEP
S_HALT
S_REGRDY
C_SNAPSTALL
C_MASKINTS
C_STEP
C_HALT
C_DEBUGEN

[31:16] DBGKEY
Debug key: Software must write 0xA05F to this field to enable write accesses to bits [15:0], otherwise the processor ignores the write access.

[25] S_RESET_ST
Indicates whether the processor has been reset since the last read of
DHCSR:
0 = No reset since last DHCSR read.
1 = At least one reset since last DHCSR read.
This is a sticky bit, that clears to 0 on a read of DHCSR.

[24] S_RETIRE_ST
Indicates whether the processor has completed the execution of an
instruction since the last read of DHCSR:
0 = No instruction retired since last DHCSR read.
1 = At least one instruction retired since last DHCSR read.
This is a sticky bit, that clears to 0 on a read of DHCSR.
A debugger can check this bit to determine if the processor is stalled on
a load, store or fetch access.
This bit is UNKNOWN after a Power-on or Local reset, but then is set to 1
as soon as the processor executes and retires an instruction.

[19] S_LOCKUP
Indicates whether the processor is locked up because of an
unrecoverable exception:
0 = Not locked up
1 = Locked up
See Unrecoverable exception cases on page B1-674 for more
information.
This bit can only be read as 1 by a remote debugger, using the DAP. The
value of 1 indicates that the processor is running but locked up.
The bit clears to 0 when the processor enters Debug state.

[18] S_SLEEP
Indicates whether the processor is sleeping:
0 = Not sleeping.
1 = Sleeping.
The debugger must set the C_HALT bit to 1 to gain control, or wait for
an interrupt or other wakeup event to wakeup the system.

[17] S_HALT
Indicates whether the processor is in Debug state:
0 = Not in Debug state.
1 = In Debug state.

[16] S_REGRDY
A handshake flag for transfers through the DCRDR:
• Writing to DCRSR clears the bit to 0.
• Completion of the DCRDR transfer then sets the bit to 1.
For more information about DCRDR transfers see Debug Core Register
Data Register, DCRDR on page C1-836.
0 = There has been a write to the DCRDR, but the transfer is not
complete
1 = The transfer to or from the DCRDR is complete.
This bit is valid only when the processor is in Debug state, otherwise the
bit is UNKNOWN.

[5] C_SNAPSTALL
If the processor is stalled on a load or store operation, a debugger can set
this bit to 1 to attempt to break the stall. The effect of this bit is:
0 = No action
1 = Attempt to force any stalled load or store instruction to complete.
The effect of setting this bit to 1 is UNPREDICTABLE unless the DHCSR
write also sets C_DEBUGEN and C_HALT to 1. This means that if the
processor is not already in Debug state a it enters Debug state when the
stalled instruction completes.
Writing 1 to this bit makes the state of the memory system
UNPREDICTABLE. Therefore, if a debugger writes 1 to this bit it must
reset the processor before leaving Debug state.

A debugger can write to the DHCSR to clear this bit to 0.
However, this does not remove the UNPREDICTABLE state of the
memory system caused by setting C_SNAPSTALL to 1.
The architecture does not guarantee that setting this bit to 1 will
force a stalled load or store operation to complete.

[3] C_MASKINTS
When debug is enabled, the debugger can write to this bit to mask
PendSV, SysTick and external configurable interrupts:
0 = Do not mask.
1 = Mask PendSV, SysTick and external configurable interrupts.
The effect of any attempt to change the value of this bit is
UNPREDICTABLE unless both:
• before the write to DHCSR, the value of the C_HALT bit is 1
• the write to the DHCSR that changes the C_MASKINTS bit also
writes 1 to the C_HALT bit.
This means that a single write to DHCSR cannot set the C_HALT to 0
and change the value of the C_MASKINTS bit.
The bit does not affect NMI. When DHCSR.C_DEBUGEN is set to 0,
the value of this bit is UNKNOWN.
For more information about the use of this bit see Halting debug
stepping on page C1-824.
This bit is UNKNOWN after a Power-on reset.

[2] C_STEP
Processor step bit. The effects of writes to this bit are:
0 = No effect.
1 = Step the processor.
For more information about the use of this bit see Table C1-7 on
page C1-825.
This bit is UNKNOWN after a Power-on reset.

[1] C_HALT
Processor halt bit. The effects of writes to this bit are:
0 = No effect.
1 = Halt the processor.
Table C1-7 on page C1-825 shows the effect of writes to this bit when
the processor is in Debug state.
This bit is UNKNOWN after a Power-on reset

[0] C_DEBUGEN
Halting debug enable bit:
0 = Disabled.
1 = Enabled.
If a debugger writes to DHCSR to change the value of this bit from 0 to
1, it must also write 0 to the C_MASKINTS bit, otherwise behavior is
UNPREDICTABLE.
This bit can only be set to 1 from the DAP, it cannot be set to 1 under
software control.
This bit is 0 after a Power-on reset.

a. ARM strongly recommends that software never writes 1 to C_SNAPSTALL when the processor is in Debug state.

See Debug stepping on page C1-824 for more information about the use of this register, including
information on how a debugger can force the processor to enter Debug state as soon as it comes out of reset.
*/

/* Debug Core Register Selector Register, DCRSR */

/*
With the DCRDR, see Debug Core Register Data Register, DCRDR on
page C1-836, the DCRSR provides debug access to the ARM core registers,
special-purpose registers, and Floating-point extension registers. A write to DCRSR specifies the register to transfer, whether the transfer is a read or a write, and starts the transfer.
*/

REGWnR
Specifies the access type for the transfer:
0 = Read
1 = Write

[6:0] REGSEL
Specifies the ARM core register, special-purpose register, or Floating-point extension register, to transfer:

0b0000000-0b0001100 ARM core registers R0-R12. 
For example, 0b0000000 specifies R0, and 0b0000101 specifies R5. 
0b0001101 The current SP. 
0b0001110 LR.
0b0001111 DebugReturnAddress
0b0010000 xPSR.
0b0010001 Main stack pointer, MSP.
0b0010010 Process stack pointer, PSP.
0b0010100
Bits [31:24] CONTROL
Bits [23:16] FAULTMASK
Bits [15:8] BASEPRI
Bits [7:0] PRIMASK.
In each field, the valid bits are packed with leading zeros. For example,
FAULTMASK is always a single bit, DCRDR[16], and DCRDR[23:17] is 0b0000000.
0b0100001 Floating-point Status and Control Register, FPSCR
0b1000000-0b1011111 FP registers S0-S31. For example, 0b1000000 specifies S0, and 0b1000101 specifies S5.


The DebugReturnAddress value
DebugReturnAddress is the address of the first instruction to be executed on exit from Debug state. This address indicates the point in the execution stream where the debug event was invoked. For a hardware or a software breakpoint, this is the address of the breakpointed instruction. For all other debug events, including PC match watchpoints, DebugReturnAddress is the address of the first instruction that both:

• in a simple sequential execution of the program, executes after the instruction that caused the debug event

• has not been executed.

Before entering Debug state, the processor has executed all instructions that are earlier in a simple sequential execution of the program than the instruction indicated by DebugReturnAddress.
Bit [0] of a DebugReturnAddress value is RAZ/SBZ. When writing a DebugReturnAddress, writing bit [0] of the address does not affect the EPSR.T bit, see The special-purpose program status registers, xPSR on

/* Debug Core Register Data Register, DCRDR */

/*
• With the DCRSR, see Debug Core Register Selector Register, DCRSR on
page C1-834, the DCRDR provides debug access to the ARM core registers,
special-purpose registers, and Floating-point extension registers. The
DCRDR is the data register for these accesses.
• Used on its own, the DCRDR provides a message passing resource between
an external debugger and a debug agent running on the processor.
Note
The architecture does not define any handshaking mechanism for this use of
DCRDR. */

/* DCRDR bit assignments. */

[31:0] DBGTMP

/*
Data temporary cache, for reading and writing the ARM core registers, special-purpose registers, and Floating-point extension registers.
The value of this register is UNKNOWN:
• on reset
• if the processor is in Debug state, the debugger has written to DCRSR since entering Debug state and DHCSR.S_REGRDY is set to 0.

Use of DCRSR and DCRDR
In Debug state, writing to DCRSR clears the DHCSR.S_REGRDY bit to 0, and the processor then sets the bit to 1 when the transfer between the DCRDR and the ARM core register, special-purpose register, or Floating-point extension register completes. 
This means that:
• To transfer a data word to an ARM core register, special-purpose register, or Floating-point extension register, a debugger:
1. 2. Writes to the DCRSR, with the REGSEL value indicating the required register, and the REGWnR bit as 1 to indicate a write access.
This write clears the DHCSR S_REGRDY bit to 0.
3. • 
Writes the required word to DCRDR.

If required, polls DHCSR until DHCSR.S_REGRDY reads-as-one. This shows that the
processor has transferred the DCRDR value to the selected register.

To transfer a data word from an ARM core register, special-purpose register, or Floating-point extension register, a debugger:
1. Writes to the DCRSR, with the REGSEL value indicating the required register, and the REGWnR bit as 0 to indicate a read access.
This write clears the DHCSR.S_REGRDY bit to 0.
2. Polls DHCSR until DHCSR.S_REGRDY reads-as-one. This shows that the processor has transferred the value of the selected register to DCRDR.

3. Reads the required value from DCRDR.

When using this mechanism to write to the ARM core registers, special-purpose registers, or Floating-point extension registers:
• All bits of the xPSR registers are fully accessible. The effect of writing an illegal value is

Note
This differs from the behavior of MSR and MRS instruction accesses to the xPSR, where some bits RAZ,
and some bits are ignored on writes.
• The debugger can write to the EPSR.IT bits. If it does this, it must write a value consistent with the instruction to be executed on exiting Debug state, otherwise instruction execution will be UNPREDICTABLE. 
*/

