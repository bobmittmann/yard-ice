
usb_xflash_pic.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .init	00000000 .init
00000004 l    d  .text	00000000 .text
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 usb-xflash.c
00000000 l    df *ABS*	00000000 yflash.c
00000640 l     O .text	0000001c s_xmodem
00000000 l    df *ABS*	00000000 stm32f1xx-flash.c
00000000 l    df *ABS*	00000000 stm32-usb_fs.c
00000000 l    df *ABS*	00000000 
000003a0 g     F .text	0000004c flash_write
000005d4 g     F .text	00000062 usb_drain
00000000 g     F .init	00000004 usb_xflash
00000340 g     F .text	00000060 flash_erase
00000020 g     F .text	00000320 yflash
000003ec g     F .text	0000001c flash_unlock
00000408 g     F .text	000000d8 usb_recv
00000004 g     F .text	0000001a dec2int
000004e0 g     F .text	000000f4 usb_send



Disassembly of section .init:

00000000 <usb_xflash>:
int __attribute__((section (".init"))) usb_xflash(uint32_t blk_offs, 
												  unsigned int blk_size, 
												  const struct magic * magic)
{
//	return xflash(blk_offs, blk_size, magic);
	return yflash(blk_offs, blk_size, magic);
   0:	f000 b80e 	b.w	20 <yflash>

Disassembly of section .text:

00000004 <dec2int>:

	return usb_ymodem_rcv_cancel(rx);
}

unsigned long dec2int(const char * __s)
{
   4:	1e42      	subs	r2, r0, #1
	unsigned long val = 0;
   6:	2000      	movs	r0, #0
	char * cp = (char *)__s;
	char c;

	while ((c = *cp) != '\0') {
   8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   c:	3b30      	subs	r3, #48	; 0x30
   e:	b2d9      	uxtb	r1, r3
  10:	2909      	cmp	r1, #9
  12:	d803      	bhi.n	1c <dec2int+0x18>
		if ((c < '0') || (c > '9'))
			break;
		val = val * 10;
		val += c - '0';
  14:	210a      	movs	r1, #10
  16:	fb01 3000 	mla	r0, r1, r0, r3
  1a:	e7f5      	b.n	8 <dec2int+0x4>
		cp++;
	}

	return val;
}
  1c:	4770      	bx	lr
  1e:	0000      	movs	r0, r0

00000020 <yflash>:

static const char s_xmodem[] = "\r\nYmodem (^X to cancel)... ";
static const char s_invalid[] = "\r\nInvalid file!";
int __attribute__((noreturn)) yflash(uint32_t blk_offs, unsigned int blk_size, 
									 const struct magic * magic)
{
  20:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  24:	f2ad 4db4 	subw	sp, sp, #1204	; 0x4b4
  28:	e88d 0003 	stmia.w	sp, {r0, r1}
	unsigned int cnt;
	uint32_t offs;
	int ret;
	int i;

	if (magic != 0) {
  2c:	b1e2      	cbz	r2, 68 <yflash+0x48>
		/* copy magic check block */
		cnt = magic->hdr.cnt > MAGIC_REC_MAX ? MAGIC_REC_MAX : magic->hdr.cnt;
  2e:	f8b2 8002 	ldrh.w	r8, [r2, #2]
		for (i = 0; i < cnt; ++i) {
  32:	2300      	movs	r3, #0
	int ret;
	int i;

	if (magic != 0) {
		/* copy magic check block */
		cnt = magic->hdr.cnt > MAGIC_REC_MAX ? MAGIC_REC_MAX : magic->hdr.cnt;
  34:	f1b8 0f10 	cmp.w	r8, #16
  38:	bf28      	it	cs
  3a:	f04f 0810 	movcs.w	r8, #16
  3e:	ea4f 05c8 	mov.w	r5, r8, lsl #3
		for (i = 0; i < cnt; ++i) {
  42:	42ab      	cmp	r3, r5
  44:	d00b      	beq.n	5e <yflash+0x3e>
  46:	f50d 6196 	add.w	r1, sp, #1200	; 0x4b0
  4a:	18cc      	adds	r4, r1, r3
  4c:	18d1      	adds	r1, r2, r3
//			usb_send(CDC_TX_EP, "\r\nmagic.", 8);
			magic_buf.rec[i] = magic->rec[i];
  4e:	f5a4 6493 	sub.w	r4, r4, #1176	; 0x498
  52:	3104      	adds	r1, #4
  54:	c903      	ldmia	r1, {r0, r1}
  56:	3308      	adds	r3, #8
  58:	e884 0003 	stmia.w	r4, {r0, r1}
  5c:	e7f1      	b.n	42 <yflash+0x22>
		}	
		magic_buf.hdr.cnt = cnt;
  5e:	fa1f f888 	uxth.w	r8, r8
		magic_buf.hdr.pos = magic->hdr.pos;
  62:	f8b2 9000 	ldrh.w	r9, [r2]
  66:	e001      	b.n	6c <yflash+0x4c>
	} else {
		magic_buf.hdr.cnt = 0;
  68:	4690      	mov	r8, r2
		magic_buf.hdr.pos = 0;
  6a:	4691      	mov	r9, r2
	}

	flash_unlock();
  6c:	f000 f9be 	bl	3ec <flash_unlock>
	/* check whether the magic record is in this
	   data block */
	if (magic->hdr.pos < pos)
		return false;

	if ((magic->hdr.pos + sz) > (pos + len))
  70:	eb09 0bc8 	add.w	fp, r9, r8, lsl #3
	}

	flash_unlock();

	do {
		usb_send(CDC_TX_EP, s_xmodem, sizeof(s_xmodem) - 1);
  74:	49b0      	ldr	r1, [pc, #704]	; (338 <yflash+0x318>)
  76:	2002      	movs	r0, #2
  78:	4479      	add	r1, pc
  7a:	221b      	movs	r2, #27
  7c:	f000 fa30 	bl	4e0 <usb_send>
	} pkt;
};

static int ymodem_rcv_init(struct ymodem_rcv * rx, bool crc_mode, bool xmodem)
{
	rx->pktno = 0;
  80:	ac26      	add	r4, sp, #152	; 0x98
	rx->crc_mode = crc_mode;
  82:	2301      	movs	r3, #1
  84:	7323      	strb	r3, [r4, #12]
	rx->xmodem = xmodem;
	rx->sync = rx->crc_mode ? 'C' : NAK;
  86:	2343      	movs	r3, #67	; 0x43
  88:	73a3      	strb	r3, [r4, #14]
	rx->xmodem = 0;
	rx->retry = 30;
  8a:	231e      	movs	r3, #30
  8c:	73e3      	strb	r3, [r4, #15]
	flash_unlock();

	do {
		usb_send(CDC_TX_EP, s_xmodem, sizeof(s_xmodem) - 1);
		ymodem_rcv_init(&ry, true, false);
		ry.fsize = blk_size;
  8e:	9b01      	ldr	r3, [sp, #4]
	} pkt;
};

static int ymodem_rcv_init(struct ymodem_rcv * rx, bool crc_mode, bool xmodem)
{
	rx->pktno = 0;
  90:	2700      	movs	r7, #0

	do {
		usb_send(CDC_TX_EP, s_xmodem, sizeof(s_xmodem) - 1);
		ymodem_rcv_init(&ry, true, false);
		ry.fsize = blk_size;
		offs = blk_offs;
  92:	f8dd a000 	ldr.w	sl, [sp]
	} pkt;
};

static int ymodem_rcv_init(struct ymodem_rcv * rx, bool crc_mode, bool xmodem)
{
	rx->pktno = 0;
  96:	6027      	str	r7, [r4, #0]
	rx->crc_mode = crc_mode;
	rx->xmodem = xmodem;
  98:	7367      	strb	r7, [r4, #13]
	rx->sync = rx->crc_mode ? 'C' : NAK;
	rx->xmodem = 0;
	rx->retry = 30;
	rx->fsize = 1024 * 1024;
	rx->count = 0;
  9a:	60a7      	str	r7, [r4, #8]
	flash_unlock();

	do {
		usb_send(CDC_TX_EP, s_xmodem, sizeof(s_xmodem) - 1);
		ymodem_rcv_init(&ry, true, false);
		ry.fsize = blk_size;
  9c:	6063      	str	r3, [r4, #4]
	int rem;
	int pos;
	int i;

	for (;;) {
		if ((ret = usb_send(CDC_TX_EP, &rx->sync, 1)) < 0) {
  9e:	2002      	movs	r0, #2
  a0:	f10d 01a6 	add.w	r1, sp, #166	; 0xa6
  a4:	2201      	movs	r2, #1
  a6:	f000 fa1b 	bl	4e0 <usb_send>
  aa:	2800      	cmp	r0, #0
  ac:	dbe2      	blt.n	74 <yflash+0x54>
  ae:	2300      	movs	r3, #0
  b0:	4618      	mov	r0, r3
		rem = 0;
		pos = 0;
		for (;;) {
			int c;

			if (rem == 0) {
  b2:	b950      	cbnz	r0, ca <yflash+0xaa>
				ret = usb_recv(CDC_RX_EP, pkt, 128, 2000);
  b4:	2001      	movs	r0, #1
  b6:	a92a      	add	r1, sp, #168	; 0xa8
  b8:	2280      	movs	r2, #128	; 0x80
  ba:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
  be:	f000 f9a3 	bl	408 <usb_recv>

				if (ret <= 0)
  c2:	2800      	cmp	r0, #0
  c4:	f340 8101 	ble.w	2ca <yflash+0x2aa>
					goto timeout;

				pos = 0;
  c8:	2300      	movs	r3, #0
				rem = ret;
			}

			c = pkt[pos];
  ca:	18e2      	adds	r2, r4, r3
  cc:	7c12      	ldrb	r2, [r2, #16]
			pos++;
  ce:	3301      	adds	r3, #1
			rem--;

			if (c == STX) {
  d0:	2a02      	cmp	r2, #2
				rem = ret;
			}

			c = pkt[pos];
			pos++;
			rem--;
  d2:	f100 30ff 	add.w	r0, r0, #4294967295

			if (c == STX) {
  d6:	d061      	beq.n	19c <yflash+0x17c>
				cnt = 1024;
				break;
			}

			if (c == SOH) {
  d8:	2a01      	cmp	r2, #1
  da:	d062      	beq.n	1a2 <yflash+0x182>
				cnt = 128;
				break;
			}

			if (c == CAN) {
  dc:	2a18      	cmp	r2, #24
  de:	d0c9      	beq.n	74 <yflash+0x54>
				return -1;
			}

			if (c == EOT) {
  e0:	2a04      	cmp	r2, #4
  e2:	d1e6      	bne.n	b2 <yflash+0x92>
				/* end of transmission */
				rx->sync = rx->crc_mode ? 'C' : NAK;
  e4:	7b23      	ldrb	r3, [r4, #12]
				rx->pktno = 0;
				pkt[0] = ACK;
				usb_send(CDC_TX_EP, pkt, 1);
  e6:	2002      	movs	r0, #2
				return -1;
			}

			if (c == EOT) {
				/* end of transmission */
				rx->sync = rx->crc_mode ? 'C' : NAK;
  e8:	2b00      	cmp	r3, #0
  ea:	bf14      	ite	ne
  ec:	2343      	movne	r3, #67	; 0x43
  ee:	2315      	moveq	r3, #21
  f0:	73a3      	strb	r3, [r4, #14]
				rx->pktno = 0;
  f2:	2300      	movs	r3, #0
  f4:	6023      	str	r3, [r4, #0]
				pkt[0] = ACK;
  f6:	2306      	movs	r3, #6
  f8:	7423      	strb	r3, [r4, #16]
				usb_send(CDC_TX_EP, pkt, 1);
  fa:	a92a      	add	r1, sp, #168	; 0xa8
  fc:	2201      	movs	r2, #1
  fe:	f000 f9ef 	bl	4e0 <usb_send>
		ry.fsize = blk_size;
		offs = blk_offs;
		cnt = 0;

		while ((ret = usb_ymodem_rcv_pkt(&ry)) >= 0) {
			if ((ret == 0) && (ry.xmodem) )
 102:	f89d 50a5 	ldrb.w	r5, [sp, #165]	; 0xa5
 106:	2d00      	cmp	r5, #0
 108:	f040 80f6 	bne.w	2f8 <yflash+0x2d8>
				break;
			int len = ret;
			if (ry.pktno == 1) {
 10c:	ae26      	add	r6, sp, #152	; 0x98
 10e:	6833      	ldr	r3, [r6, #0]
 110:	2b01      	cmp	r3, #1
 112:	d10e      	bne.n	132 <yflash+0x112>
 114:	f10d 03ab 	add.w	r3, sp, #171	; 0xab
 118:	4618      	mov	r0, r3
				char * cp;
				int fsize;
				cp = (char *)ry.pkt.data;
				while (*cp != '\0')
 11a:	7802      	ldrb	r2, [r0, #0]
 11c:	3301      	adds	r3, #1
 11e:	2a00      	cmp	r2, #0
 120:	d1fa      	bne.n	118 <yflash+0xf8>
					cp++;
				cp++; /* skip null */
				fsize = dec2int(cp);
 122:	4618      	mov	r0, r3
 124:	f7ff ff6e 	bl	4 <dec2int>
				if (fsize == 0) {
 128:	2800      	cmp	r0, #0
 12a:	f000 80e5 	beq.w	2f8 <yflash+0x2d8>
					ret = 0;
					break;
				}
				ry.fsize = fsize;
 12e:	6070      	str	r0, [r6, #4]
 130:	e7b5      	b.n	9e <yflash+0x7e>
			} else {
				if (ry.pktno == 2) {
 132:	2b02      	cmp	r3, #2
 134:	d125      	bne.n	182 <yflash+0x162>
	int k;
	int j;

	/* check whether the magic record is in this
	   data block */
	if (magic->hdr.pos < pos)
 136:	45b9      	cmp	r9, r7
 138:	f2c0 80d5 	blt.w	2e6 <yflash+0x2c6>
		return false;

	if ((magic->hdr.pos + sz) > (pos + len))
 13c:	197b      	adds	r3, r7, r5
 13e:	459b      	cmp	fp, r3
 140:	f300 80d1 	bgt.w	2e6 <yflash+0x2c6>
		return false;

	k = magic->hdr.pos - pos;
 144:	ebc7 0309 	rsb	r3, r7, r9
 148:	4433      	add	r3, r6
 14a:	2101      	movs	r1, #1
 14c:	1e4a      	subs	r2, r1, #1
	for (j = 0; j < magic->hdr.cnt; ++j) {
 14e:	4542      	cmp	r2, r8
 150:	da17      	bge.n	182 <yflash+0x162>
		uint32_t data;

		data = buf[k] + (buf[k + 1] << 8) + 
 152:	7d18      	ldrb	r0, [r3, #20]
 154:	7cda      	ldrb	r2, [r3, #19]
 156:	3304      	adds	r3, #4
 158:	eb02 2200 	add.w	r2, r2, r0, lsl #8
			(buf[k + 2] << 16) + (buf[k + 3] << 24);
 15c:	7c58      	ldrb	r0, [r3, #17]

	k = magic->hdr.pos - pos;
	for (j = 0; j < magic->hdr.cnt; ++j) {
		uint32_t data;

		data = buf[k] + (buf[k + 1] << 8) + 
 15e:	eb02 4200 	add.w	r2, r2, r0, lsl #16
			(buf[k + 2] << 16) + (buf[k + 3] << 24);
 162:	7c98      	ldrb	r0, [r3, #18]
 164:	eb02 6200 	add.w	r2, r2, r0, lsl #24
 168:	a805      	add	r0, sp, #20
 16a:	eb00 06c1 	add.w	r6, r0, r1, lsl #3

		if ((data & magic->rec[j].mask) != magic->rec[j].comp) {
 16e:	f856 6c04 	ldr.w	r6, [r6, #-4]
 172:	f850 0031 	ldr.w	r0, [r0, r1, lsl #3]
 176:	4032      	ands	r2, r6
 178:	4282      	cmp	r2, r0
 17a:	f101 0101 	add.w	r1, r1, #1
 17e:	d0e5      	beq.n	14c <yflash+0x12c>
 180:	e0b1      	b.n	2e6 <yflash+0x2c6>
						break;
					}
//					flash_erase(offs, ry->fsize);
				}

				flash_erase(offs, len);
 182:	4650      	mov	r0, sl
 184:	4629      	mov	r1, r5
 186:	f000 f8db 	bl	340 <flash_erase>
				flash_write(offs, ry.pkt.data, len);
 18a:	4650      	mov	r0, sl
 18c:	f10d 01ab 	add.w	r1, sp, #171	; 0xab
 190:	462a      	mov	r2, r5
 192:	f000 f905 	bl	3a0 <flash_write>
				offs += len;
 196:	44aa      	add	sl, r5
				cnt += len;
 198:	442f      	add	r7, r5
 19a:	e780      	b.n	9e <yflash+0x7e>
			c = pkt[pos];
			pos++;
			rem--;

			if (c == STX) {
				cnt = 1024;
 19c:	f44f 6580 	mov.w	r5, #1024	; 0x400
 1a0:	e000      	b.n	1a4 <yflash+0x184>
				break;
			}

			if (c == SOH) {
				cnt = 128;
 1a2:	2580      	movs	r5, #128	; 0x80
 1a4:	aa2a      	add	r2, sp, #168	; 0xa8
 1a6:	f100 0110 	add.w	r1, r0, #16
 1aa:	4421      	add	r1, r4
 1ac:	9202      	str	r2, [sp, #8]
				return 0;
			}
		}

		cp = pkt + 1;
		for (i = 0; i < rem; ++i)
 1ae:	428a      	cmp	r2, r1
 1b0:	d003      	beq.n	1ba <yflash+0x19a>
			cp[i] = pkt[pos + i];
 1b2:	5cd6      	ldrb	r6, [r2, r3]
 1b4:	f802 6f01 	strb.w	r6, [r2, #1]!
 1b8:	e7f9      	b.n	1ae <yflash+0x18e>
		cp += rem;

		rem = cnt + ((rx->crc_mode) ? 4 : 3) - rem;
 1ba:	7b23      	ldrb	r3, [r4, #12]
		}

		cp = pkt + 1;
		for (i = 0; i < rem; ++i)
			cp[i] = pkt[pos + i];
		cp += rem;
 1bc:	f10d 0ca9 	add.w	ip, sp, #169	; 0xa9

		rem = cnt + ((rx->crc_mode) ? 4 : 3) - rem;
 1c0:	2b00      	cmp	r3, #0
 1c2:	bf14      	ite	ne
 1c4:	2604      	movne	r6, #4
 1c6:	2603      	moveq	r6, #3
 1c8:	442e      	add	r6, r5
		}

		cp = pkt + 1;
		for (i = 0; i < rem; ++i)
			cp[i] = pkt[pos + i];
		cp += rem;
 1ca:	4484      	add	ip, r0

		rem = cnt + ((rx->crc_mode) ? 4 : 3) - rem;
 1cc:	1a36      	subs	r6, r6, r0

		/* receive the packet */
		while (rem) {
			ret = usb_recv(CDC_RX_EP, cp, rem, 500);
 1ce:	2001      	movs	r0, #1
 1d0:	4661      	mov	r1, ip
 1d2:	4632      	mov	r2, r6
 1d4:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 1d8:	f8cd c00c 	str.w	ip, [sp, #12]
 1dc:	f000 f914 	bl	408 <usb_recv>
			if (ret < 0)
 1e0:	2800      	cmp	r0, #0
 1e2:	db72      	blt.n	2ca <yflash+0x2aa>
				goto timeout;

			rem -= ret;
			cp += ret;
 1e4:	f8dd c00c 	ldr.w	ip, [sp, #12]
		cp += rem;

		rem = cnt + ((rx->crc_mode) ? 4 : 3) - rem;

		/* receive the packet */
		while (rem) {
 1e8:	1a36      	subs	r6, r6, r0
			ret = usb_recv(CDC_RX_EP, cp, rem, 500);
			if (ret < 0)
				goto timeout;

			rem -= ret;
			cp += ret;
 1ea:	4484      	add	ip, r0
		cp += rem;

		rem = cnt + ((rx->crc_mode) ? 4 : 3) - rem;

		/* receive the packet */
		while (rem) {
 1ec:	d1ef      	bne.n	1ce <yflash+0x1ae>
		}

		/* sequence */
		seq = pkt[1];
		/* inverse sequence */
		nseq = pkt[2];
 1ee:	7ca3      	ldrb	r3, [r4, #18]
			rem -= ret;
			cp += ret;
		}

		/* sequence */
		seq = pkt[1];
 1f0:	7c61      	ldrb	r1, [r4, #17]
		/* inverse sequence */
		nseq = pkt[2];

		if (seq != ((~nseq) & 0xff)) {
 1f2:	43db      	mvns	r3, r3
 1f4:	b2db      	uxtb	r3, r3
 1f6:	4299      	cmp	r1, r3
 1f8:	d154      	bne.n	2a4 <yflash+0x284>
			goto error;
		}

		cp = &pkt[3];

		if (rx->crc_mode) {
 1fa:	7b23      	ldrb	r3, [r4, #12]
 1fc:	b1eb      	cbz	r3, 23a <yflash+0x21a>
 1fe:	4633      	mov	r3, r6

#ifndef __CRC_H__
#define __CRC_H__

static inline unsigned int __crc16ccitt(unsigned int crc, int c) {
	crc = (crc >> 8) | ((crc & 0xff) << 8);
 200:	0218      	lsls	r0, r3, #8
 202:	19a2      	adds	r2, r4, r6
	crc ^= c;
 204:	7cd2      	ldrb	r2, [r2, #19]

#ifndef __CRC_H__
#define __CRC_H__

static inline unsigned int __crc16ccitt(unsigned int crc, int c) {
	crc = (crc >> 8) | ((crc & 0xff) << 8);
 206:	b280      	uxth	r0, r0
 208:	ea40 2313 	orr.w	r3, r0, r3, lsr #8
	crc ^= c;
 20c:	4053      	eors	r3, r2
	crc ^= (crc & 0xff) >> 4;
 20e:	f3c3 1203 	ubfx	r2, r3, #4, #4
 212:	405a      	eors	r2, r3
	crc ^= (crc & 0x0f) << 12;
 214:	0313      	lsls	r3, r2, #12
 216:	b29b      	uxth	r3, r3
 218:	4053      	eors	r3, r2
	crc ^= (crc & 0xff) << 5;
 21a:	b2da      	uxtb	r2, r3
			unsigned short crc = 0;
			unsigned short cmp;
			int i;

			for (i = 0; i < cnt; ++i)
 21c:	3601      	adds	r6, #1
 21e:	ea83 1342 	eor.w	r3, r3, r2, lsl #5
 222:	42ae      	cmp	r6, r5
				crc = CRC16CCITT(crc, cp[i]);
 224:	b29b      	uxth	r3, r3
		if (rx->crc_mode) {
			unsigned short crc = 0;
			unsigned short cmp;
			int i;

			for (i = 0; i < cnt; ++i)
 226:	d1eb      	bne.n	200 <yflash+0x1e0>
				crc = CRC16CCITT(crc, cp[i]);

			cmp = (unsigned short)cp[i] << 8 | cp[i + 1];
 228:	f10d 02ab 	add.w	r2, sp, #171	; 0xab
 22c:	5d50      	ldrb	r0, [r2, r5]
 22e:	aa2b      	add	r2, sp, #172	; 0xac
 230:	5d52      	ldrb	r2, [r2, r5]

			if (cmp != crc) {
 232:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 236:	429a      	cmp	r2, r3
 238:	e00b      	b.n	252 <yflash+0x232>
			goto error;
		}

		cp = &pkt[3];

		if (rx->crc_mode) {
 23a:	4633      	mov	r3, r6
 23c:	18e2      	adds	r2, r4, r3
		} else {
			unsigned char cks = 0;
			int i;

			for (i = 0; i < cnt; ++i)
				cks += cp[i];
 23e:	7cd0      	ldrb	r0, [r2, #19]

		} else {
			unsigned char cks = 0;
			int i;

			for (i = 0; i < cnt; ++i)
 240:	3301      	adds	r3, #1
				cks += cp[i];
 242:	4406      	add	r6, r0

		} else {
			unsigned char cks = 0;
			int i;

			for (i = 0; i < cnt; ++i)
 244:	42ab      	cmp	r3, r5
				cks += cp[i];
 246:	b2f6      	uxtb	r6, r6

		} else {
			unsigned char cks = 0;
			int i;

			for (i = 0; i < cnt; ++i)
 248:	d1f8      	bne.n	23c <yflash+0x21c>
				cks += cp[i];

			if (cp[i] != cks) {
 24a:	f10d 03ab 	add.w	r3, sp, #171	; 0xab
 24e:	5d5b      	ldrb	r3, [r3, r5]
 250:	42b3      	cmp	r3, r6
 252:	d127      	bne.n	2a4 <yflash+0x284>
				goto error;
			}
		}

		if (seq == ((rx->pktno - 1) & 0xff)) {
 254:	6823      	ldr	r3, [r4, #0]
 256:	1e5a      	subs	r2, r3, #1
 258:	b2d2      	uxtb	r2, r2
 25a:	4291      	cmp	r1, r2
 25c:	f43f af1f 	beq.w	9e <yflash+0x7e>
			/* retransmission */
			continue;
		}

		if (seq != (rx->pktno & 0xff)) {
 260:	b2da      	uxtb	r2, r3
 262:	4291      	cmp	r1, r2
 264:	d004      	beq.n	270 <yflash+0x250>
			if ((rx->pktno == 0) && (seq == 1)) {
 266:	b9eb      	cbnz	r3, 2a4 <yflash+0x284>
 268:	2901      	cmp	r1, #1
 26a:	d11b      	bne.n	2a4 <yflash+0x284>
				rx->pktno++;
 26c:	6021      	str	r1, [r4, #0]
				/* Fallback to XMODEM */
				rx->xmodem = 1;
 26e:	7361      	strb	r1, [r4, #13]
				goto error;
			}
		}

		/* YModem first packet ... */
		if (rx->pktno == 0) {
 270:	ab26      	add	r3, sp, #152	; 0x98
 272:	6819      	ldr	r1, [r3, #0]
 274:	2206      	movs	r2, #6
 276:	b931      	cbnz	r1, 286 <yflash+0x266>
			pkt[0] = ACK;
 278:	741a      	strb	r2, [r3, #16]
			usb_send(CDC_TX_EP, pkt, 1);
 27a:	a92a      	add	r1, sp, #168	; 0xa8
 27c:	2201      	movs	r2, #1
 27e:	2002      	movs	r0, #2
 280:	f000 f92e 	bl	4e0 <usb_send>
 284:	e00a      	b.n	29c <yflash+0x27c>
		} else {
			rx->retry = 10;
 286:	210a      	movs	r1, #10
			rx->sync = ACK;
 288:	739a      	strb	r2, [r3, #14]
			if ((rx->count + cnt) > rx->fsize)
 28a:	689a      	ldr	r2, [r3, #8]
		/* YModem first packet ... */
		if (rx->pktno == 0) {
			pkt[0] = ACK;
			usb_send(CDC_TX_EP, pkt, 1);
		} else {
			rx->retry = 10;
 28c:	73d9      	strb	r1, [r3, #15]
			rx->sync = ACK;
			if ((rx->count + cnt) > rx->fsize)
 28e:	6859      	ldr	r1, [r3, #4]
 290:	18a8      	adds	r0, r5, r2
 292:	4288      	cmp	r0, r1
				cnt = rx->fsize - rx->count;
 294:	bf88      	it	hi
 296:	1a8d      	subhi	r5, r1, r2
			rx->count += cnt;
 298:	442a      	add	r2, r5
 29a:	609a      	str	r2, [r3, #8]
		}

		rx->pktno++;
 29c:	6823      	ldr	r3, [r4, #0]
 29e:	3301      	adds	r3, #1
 2a0:	6023      	str	r3, [r4, #0]
 2a2:	e01a      	b.n	2da <yflash+0x2ba>

		return cnt;

error:
		/* flush */
		while (usb_recv(CDC_RX_EP, pkt, 1024, 100) > 0);
 2a4:	2001      	movs	r0, #1
 2a6:	9902      	ldr	r1, [sp, #8]
 2a8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 2ac:	2364      	movs	r3, #100	; 0x64
 2ae:	f000 f8ab 	bl	408 <usb_recv>
 2b2:	2800      	cmp	r0, #0
 2b4:	dcf6      	bgt.n	2a4 <yflash+0x284>

static int usb_ymodem_rcv_cancel(struct ymodem_rcv * rx)
{
	unsigned char * pkt = rx->pkt.hdr;

	pkt[0] = CAN;
 2b6:	2318      	movs	r3, #24
	pkt[1] = CAN;

	return usb_send(CDC_TX_EP, pkt, 2);
 2b8:	2002      	movs	r0, #2

static int usb_ymodem_rcv_cancel(struct ymodem_rcv * rx)
{
	unsigned char * pkt = rx->pkt.hdr;

	pkt[0] = CAN;
 2ba:	7423      	strb	r3, [r4, #16]
	pkt[1] = CAN;
 2bc:	7463      	strb	r3, [r4, #17]

	return usb_send(CDC_TX_EP, pkt, 2);
 2be:	a92a      	add	r1, sp, #168	; 0xa8
 2c0:	4602      	mov	r2, r0
 2c2:	f000 f90d 	bl	4e0 <usb_send>
 2c6:	4605      	mov	r5, r0
 2c8:	e007      	b.n	2da <yflash+0x2ba>
		while (usb_recv(CDC_RX_EP, pkt, 1024, 100) > 0);
		ret = -1;
		break;

timeout:
		if ((--rx->retry) == 0) {
 2ca:	7be3      	ldrb	r3, [r4, #15]
 2cc:	3b01      	subs	r3, #1
 2ce:	b2db      	uxtb	r3, r3
 2d0:	73e3      	strb	r3, [r4, #15]
 2d2:	2b00      	cmp	r3, #0
 2d4:	f47f aee3 	bne.w	9e <yflash+0x7e>
 2d8:	e7ed      	b.n	2b6 <yflash+0x296>
		ymodem_rcv_init(&ry, true, false);
		ry.fsize = blk_size;
		offs = blk_offs;
		cnt = 0;

		while ((ret = usb_ymodem_rcv_pkt(&ry)) >= 0) {
 2da:	2d00      	cmp	r5, #0
 2dc:	f6ff aeca 	blt.w	74 <yflash+0x54>
			if ((ret == 0) && (ry.xmodem) )
 2e0:	f47f af14 	bne.w	10c <yflash+0xec>
 2e4:	e70d      	b.n	102 <yflash+0xe2>

static int usb_ymodem_rcv_cancel(struct ymodem_rcv * rx)
{
	unsigned char * pkt = rx->pkt.hdr;

	pkt[0] = CAN;
 2e6:	2318      	movs	r3, #24
	pkt[1] = CAN;

	return usb_send(CDC_TX_EP, pkt, 2);
 2e8:	2002      	movs	r0, #2

static int usb_ymodem_rcv_cancel(struct ymodem_rcv * rx)
{
	unsigned char * pkt = rx->pkt.hdr;

	pkt[0] = CAN;
 2ea:	7423      	strb	r3, [r4, #16]
	pkt[1] = CAN;
 2ec:	7463      	strb	r3, [r4, #17]

	return usb_send(CDC_TX_EP, pkt, 2);
 2ee:	a92a      	add	r1, sp, #168	; 0xa8
 2f0:	4602      	mov	r2, r0
 2f2:	f000 f8f5 	bl	4e0 <usb_send>
 2f6:	e6bd      	b.n	74 <yflash+0x54>
				offs += len;
				cnt += len;
			}
		}

	} while ((ret < 0) || (cnt == 0));
 2f8:	2f00      	cmp	r7, #0
 2fa:	f43f aebb 	beq.w	74 <yflash+0x54>

	usb_send(CDC_TX_EP, "\r\nDone.\r\n", 9);
 2fe:	490f      	ldr	r1, [pc, #60]	; (33c <yflash+0x31c>)
 300:	2209      	movs	r2, #9
 302:	4479      	add	r1, pc
 304:	2002      	movs	r0, #2
 306:	f000 f8eb 	bl	4e0 <usb_send>

	usb_drain(CDC_TX_EP);
 30a:	2002      	movs	r0, #2
 30c:	f000 f962 	bl	5d4 <usb_drain>
 310:	f640 33b8 	movw	r3, #3000	; 0xbb8
	for(;;);
}

static void delay(unsigned int msec)
{
	while (msec > 0) {
 314:	b133      	cbz	r3, 324 <yflash+0x304>
		if (CM3_SYSTICK->csr & SYSTICK_CSR_COUNTFLAG)
 316:	4a05      	ldr	r2, [pc, #20]	; (32c <yflash+0x30c>)
 318:	6812      	ldr	r2, [r2, #0]
 31a:	03d2      	lsls	r2, r2, #15
			msec--;
 31c:	bf48      	it	mi
 31e:	f103 33ff 	addmi.w	r3, r3, #4294967295
 322:	e7f7      	b.n	314 <yflash+0x2f4>

#define FLASH_WR_BLK_SIZE 128

static void __attribute__((noreturn)) reset(void)
{
	CM3_SCB->aircr =  SCB_AIRCR_VECTKEY | SCB_AIRCR_SYSRESETREQ;
 324:	4a02      	ldr	r2, [pc, #8]	; (330 <yflash+0x310>)
 326:	4b03      	ldr	r3, [pc, #12]	; (334 <yflash+0x314>)
 328:	60da      	str	r2, [r3, #12]
 32a:	e7fe      	b.n	32a <yflash+0x30a>
 32c:	e000e010 	.word	0xe000e010
 330:	05fa0004 	.word	0x05fa0004
 334:	e000ed00 	.word	0xe000ed00
 338:	000005c4 	.word	0x000005c4
 33c:	00000330 	.word	0x00000330

00000340 <flash_erase>:

}

/* erase flash blocks */
int flash_erase(uint32_t offs, unsigned int len)
{
 340:	b530      	push	{r4, r5, lr}
	uint32_t sr;
	int rem;
	int cnt;

	/* get the nearest block. */
	blk_offs = (offs + FLASH_BLOCK_SIZE - 1) & ~(FLASH_BLOCK_SIZE - 1);
 342:	f200 33ff 	addw	r3, r0, #1023	; 0x3ff
 346:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 34a:	f023 0303 	bic.w	r3, r3, #3
 34e:	4401      	add	r1, r0
	addr = STM32_FLASH_ADDR + blk_offs;
 350:	f103 6200 	add.w	r2, r3, #134217728	; 0x8000000

	cnt = 0;
	rem = len + (offs - blk_offs);
 354:	1ac9      	subs	r1, r1, r3

	/* get the nearest block. */
	blk_offs = (offs + FLASH_BLOCK_SIZE - 1) & ~(FLASH_BLOCK_SIZE - 1);
	addr = STM32_FLASH_ADDR + blk_offs;

	cnt = 0;
 356:	2000      	movs	r0, #0
 358:	1a0b      	subs	r3, r1, r0
	rem = len + (offs - blk_offs);


	while (rem > 0) {
 35a:	2b00      	cmp	r3, #0
 35c:	dd19      	ble.n	392 <flash_erase+0x52>
{
	uint32_t sr;

	DCC_LOG1(LOG_TRACE, "addr=%08x", addr);

	flash->cr = FLASH_SER;
 35e:	4b0f      	ldr	r3, [pc, #60]	; (39c <flash_erase+0x5c>)
 360:	2402      	movs	r4, #2
 362:	611c      	str	r4, [r3, #16]
	do {
		sr = flash->sr;
 364:	68dd      	ldr	r5, [r3, #12]
 366:	4c0d      	ldr	r4, [pc, #52]	; (39c <flash_erase+0x5c>)
	} while (sr & FLASH_BSY);
 368:	07ed      	lsls	r5, r5, #31
 36a:	d4fb      	bmi.n	364 <flash_erase+0x24>
	flash->ar = addr;
	flash->cr = FLASH_STRT | FLASH_SER;
 36c:	2542      	movs	r5, #66	; 0x42

	flash->cr = FLASH_SER;
	do {
		sr = flash->sr;
	} while (sr & FLASH_BSY);
	flash->ar = addr;
 36e:	6162      	str	r2, [r4, #20]
	flash->cr = FLASH_STRT | FLASH_SER;
 370:	6125      	str	r5, [r4, #16]
static inline void __attribute__((always_inline)) __isb(void) {
	asm volatile ("isb" : );
}

static inline void __attribute__((always_inline)) __nop(void) {
	asm volatile ("nop" : );
 372:	bf00      	nop
 374:	bf00      	nop
*/
	__nop();
	__nop();

	do {
		sr = flash->sr;
 376:	68dc      	ldr	r4, [r3, #12]
	} while (sr & FLASH_BSY);
 378:	f014 0501 	ands.w	r5, r4, #1
 37c:	d1fb      	bne.n	376 <flash_erase+0x36>

	flash->cr = 0;
 37e:	4b07      	ldr	r3, [pc, #28]	; (39c <flash_erase+0x5c>)


	while (rem > 0) {
	
		sr = stm32f10x_flash_blk_erase(flash, addr);
		if (sr & FLASH_ERR) {
 380:	f014 0f14 	tst.w	r4, #20

	do {
		sr = flash->sr;
	} while (sr & FLASH_BSY);

	flash->cr = 0;
 384:	611d      	str	r5, [r3, #16]


	while (rem > 0) {
	
		sr = stm32f10x_flash_blk_erase(flash, addr);
		if (sr & FLASH_ERR) {
 386:	d105      	bne.n	394 <flash_erase+0x54>
			cnt = -1;
			break;
		}

		addr += FLASH_BLOCK_SIZE;
 388:	f502 6280 	add.w	r2, r2, #1024	; 0x400
		rem -= FLASH_BLOCK_SIZE;
		cnt += FLASH_BLOCK_SIZE;
 38c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 390:	e7e2      	b.n	358 <flash_erase+0x18>
 392:	bd30      	pop	{r4, r5, pc}

	while (rem > 0) {
	
		sr = stm32f10x_flash_blk_erase(flash, addr);
		if (sr & FLASH_ERR) {
			cnt = -1;
 394:	f04f 30ff 	mov.w	r0, #4294967295
		rem -= FLASH_BLOCK_SIZE;
		cnt += FLASH_BLOCK_SIZE;
	}

	return cnt;
}
 398:	bd30      	pop	{r4, r5, pc}
 39a:	bf00      	nop
 39c:	40022000 	.word	0x40022000

000003a0 <flash_write>:
	uint16_t * addr;
	uint8_t * ptr;
	int n;
	int i;

	n = (len + 1) / 2;
 3a0:	3201      	adds	r2, #1

	return 0;
}

int flash_write(uint32_t offs, const void * buf, unsigned int len)
{
 3a2:	b570      	push	{r4, r5, r6, lr}
	uint16_t * addr;
	uint8_t * ptr;
	int n;
	int i;

	n = (len + 1) / 2;
 3a4:	0852      	lsrs	r2, r2, #1

	ptr = (uint8_t *)buf;
	addr = (uint16_t *)(STM32_FLASH_ADDR + offs);
 3a6:	f100 6000 	add.w	r0, r0, #134217728	; 0x8000000
 3aa:	3102      	adds	r1, #2

	for (i = 0; i < n; i++) {
 3ac:	2400      	movs	r4, #0
 3ae:	4294      	cmp	r4, r2
 3b0:	da14      	bge.n	3dc <flash_write+0x3c>
		data = ptr[0] | (ptr[1] << 8);
 3b2:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 3b6:	f811 5c01 	ldrb.w	r5, [r1, #-1]
static int stm32f10x_flash_wr16(struct stm32_flash * flash,
						 uint16_t volatile * addr, uint16_t data)
{
	uint32_t sr;

	flash->cr = FLASH_PG;
 3ba:	2601      	movs	r6, #1

	ptr = (uint8_t *)buf;
	addr = (uint16_t *)(STM32_FLASH_ADDR + offs);

	for (i = 0; i < n; i++) {
		data = ptr[0] | (ptr[1] << 8);
 3bc:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
static int stm32f10x_flash_wr16(struct stm32_flash * flash,
						 uint16_t volatile * addr, uint16_t data)
{
	uint32_t sr;

	flash->cr = FLASH_PG;
 3c0:	4b09      	ldr	r3, [pc, #36]	; (3e8 <flash_write+0x48>)
 3c2:	611e      	str	r6, [r3, #16]
	*addr = data;
 3c4:	8005      	strh	r5, [r0, #0]
	
	do {
		sr = flash->sr;
 3c6:	68dd      	ldr	r5, [r3, #12]
	} while (sr & FLASH_BSY);
 3c8:	07ee      	lsls	r6, r5, #31
 3ca:	d4fc      	bmi.n	3c6 <flash_write+0x26>

	if (sr & FLASH_ERR)
 3cc:	f015 0f14 	tst.w	r5, #20
 3d0:	f101 0102 	add.w	r1, r1, #2
 3d4:	d104      	bne.n	3e0 <flash_write+0x40>
	for (i = 0; i < n; i++) {
		data = ptr[0] | (ptr[1] << 8);
		if (stm32f10x_flash_wr16(flash, addr, data) < 0)
			return -1;
		ptr += 2;
		addr++;
 3d6:	3002      	adds	r0, #2
	n = (len + 1) / 2;

	ptr = (uint8_t *)buf;
	addr = (uint16_t *)(STM32_FLASH_ADDR + offs);

	for (i = 0; i < n; i++) {
 3d8:	3401      	adds	r4, #1
 3da:	e7e8      	b.n	3ae <flash_write+0xe>
			return -1;
		ptr += 2;
		addr++;
	}
	
	return n * 2;
 3dc:	0050      	lsls	r0, r2, #1
 3de:	bd70      	pop	{r4, r5, r6, pc}
	addr = (uint16_t *)(STM32_FLASH_ADDR + offs);

	for (i = 0; i < n; i++) {
		data = ptr[0] | (ptr[1] << 8);
		if (stm32f10x_flash_wr16(flash, addr, data) < 0)
			return -1;
 3e0:	f04f 30ff 	mov.w	r0, #4294967295
		ptr += 2;
		addr++;
	}
	
	return n * 2;
}
 3e4:	bd70      	pop	{r4, r5, r6, pc}
 3e6:	bf00      	nop
 3e8:	40022000 	.word	0x40022000

000003ec <flash_unlock>:
void flash_unlock(void)
{
	struct stm32_flash * flash = STM32_FLASH;
	uint32_t cr;

	cr = flash->cr;
 3ec:	4b04      	ldr	r3, [pc, #16]	; (400 <flash_unlock+0x14>)
 3ee:	691a      	ldr	r2, [r3, #16]
	if (cr & FLASH_LOCK) {
 3f0:	0612      	lsls	r2, r2, #24
		/* unlock flash write */
		flash->keyr = FLASH_KEY1;
 3f2:	bf41      	itttt	mi
 3f4:	4a03      	ldrmi	r2, [pc, #12]	; (404 <flash_unlock+0x18>)
 3f6:	605a      	strmi	r2, [r3, #4]
		flash->keyr = FLASH_KEY2;
 3f8:	f102 3288 	addmi.w	r2, r2, #2290649224	; 0x88888888
 3fc:	605a      	strmi	r2, [r3, #4]
 3fe:	4770      	bx	lr
 400:	40022000 	.word	0x40022000
 404:	45670123 	.word	0x45670123

00000408 <usb_recv>:
}

/* ------------------------------------------------------------------------- */

int usb_recv(int ep_id, void * buf, unsigned int len, unsigned int msec)
{
 408:	b5f0      	push	{r4, r5, r6, r7, lr}
 40a:	0086      	lsls	r6, r0, #2
 40c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000

	epr = usb->epr[ep_id];
again:
	if (epr & USB_EP_DBL_BUF) {
		/* select the descriptor according to the data toggle bit */
		rx_pktbuf = &pktbuf[ep_id].dbrx[(epr & USB_SWBUF_RX) ? 1 : 0];
 410:	0105      	lsls	r5, r0, #4
 412:	f506 46b8 	add.w	r6, r6, #23552	; 0x5c00
 416:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
}

/* ------------------------------------------------------------------------- */

int usb_recv(int ep_id, void * buf, unsigned int len, unsigned int msec)
{
 41a:	469e      	mov	lr, r3

	epr = usb->epr[ep_id];
again:
	if (epr & USB_EP_DBL_BUF) {
		/* select the descriptor according to the data toggle bit */
		rx_pktbuf = &pktbuf[ep_id].dbrx[(epr & USB_SWBUF_RX) ? 1 : 0];
 41c:	f505 45c0 	add.w	r5, r5, #24576	; 0x6000
	struct stm32f_usb * usb = STM32F_USB;
	struct stm32f_usb_rx_pktbuf * rx_pktbuf;
	uint32_t epr;
	int cnt;

	epr = usb->epr[ep_id];
 420:	6833      	ldr	r3, [r6, #0]
	if (epr & USB_EP_DBL_BUF) {
		/* select the descriptor according to the data toggle bit */
		rx_pktbuf = &pktbuf[ep_id].dbrx[(epr & USB_SWBUF_RX) ? 1 : 0];
	} else {
		/* single buffer */
		rx_pktbuf = &pktbuf[ep_id].rx;
 422:	f105 0c08 	add.w	ip, r5, #8
	uint32_t epr;
	int cnt;

	epr = usb->epr[ep_id];
again:
	if (epr & USB_EP_DBL_BUF) {
 426:	f413 7780 	ands.w	r7, r3, #256	; 0x100
		/* select the descriptor according to the data toggle bit */
		rx_pktbuf = &pktbuf[ep_id].dbrx[(epr & USB_SWBUF_RX) ? 1 : 0];
	} else {
		/* single buffer */
		rx_pktbuf = &pktbuf[ep_id].rx;
 42a:	bf0e      	itee	eq
 42c:	4664      	moveq	r4, ip

	epr = usb->epr[ep_id];
again:
	if (epr & USB_EP_DBL_BUF) {
		/* select the descriptor according to the data toggle bit */
		rx_pktbuf = &pktbuf[ep_id].dbrx[(epr & USB_SWBUF_RX) ? 1 : 0];
 42e:	f3c3 1480 	ubfxne	r4, r3, #6, #1
 432:	eb05 04c4 	addne.w	r4, r5, r4, lsl #3
	} else {
		/* single buffer */
		rx_pktbuf = &pktbuf[ep_id].rx;
	}
	if (rx_pktbuf->count == 0) {
 436:	6860      	ldr	r0, [r4, #4]
 438:	f3c0 0009 	ubfx	r0, r0, #0, #10
 43c:	b990      	cbnz	r0, 464 <usb_recv+0x5c>
		while (!(epr & USB_CTR_RX)) {
 43e:	0418      	lsls	r0, r3, #16
 440:	d40a      	bmi.n	458 <usb_recv+0x50>
			if (systick->csr & SYSTICK_CSR_COUNTFLAG) {
 442:	4b26      	ldr	r3, [pc, #152]	; (4dc <usb_recv+0xd4>)
 444:	681b      	ldr	r3, [r3, #0]
 446:	03dc      	lsls	r4, r3, #15
 448:	d504      	bpl.n	454 <usb_recv+0x4c>
				if (msec == 0)
 44a:	f1be 0f00 	cmp.w	lr, #0
 44e:	d041      	beq.n	4d4 <usb_recv+0xcc>
					return -1;
				msec--;
 450:	f10e 3eff 	add.w	lr, lr, #4294967295
			}
			epr = usb->epr[ep_id];
 454:	6833      	ldr	r3, [r6, #0]
 456:	e7f2      	b.n	43e <usb_recv+0x36>

static inline void __clr_ep_flag(struct stm32f_usb * usb, 
							   int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
	usb->epr[ep_id] = (epr & ~flag) & USB_EPREG_MASK;
 458:	f640 748f 	movw	r4, #3983	; 0xf8f


static inline void __clr_ep_flag(struct stm32f_usb * usb, 
							   int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 45c:	6830      	ldr	r0, [r6, #0]
	usb->epr[ep_id] = (epr & ~flag) & USB_EPREG_MASK;
 45e:	4004      	ands	r4, r0
 460:	6034      	str	r4, [r6, #0]
 462:	e7e0      	b.n	426 <usb_recv+0x1e>
		/* OUT */
		__clr_ep_flag(usb, ep_id, USB_CTR_RX);
		goto again;
	}

	cnt = MIN(rx_pktbuf->count, len);
 464:	6863      	ldr	r3, [r4, #4]
 466:	f3c3 0309 	ubfx	r3, r3, #0, #10
 46a:	4293      	cmp	r3, r2
 46c:	bf28      	it	cs
 46e:	4610      	movcs	r0, r2
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* copy data to destination buffer */
	src = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (rx->addr / 2);
 470:	6823      	ldr	r3, [r4, #0]
		/* OUT */
		__clr_ep_flag(usb, ep_id, USB_CTR_RX);
		goto again;
	}

	cnt = MIN(rx_pktbuf->count, len);
 472:	bf38      	it	cc
 474:	6860      	ldrcc	r0, [r4, #4]
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* copy data to destination buffer */
	src = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (rx->addr / 2);
 476:	ea4f 0353 	mov.w	r3, r3, lsr #1
		/* OUT */
		__clr_ep_flag(usb, ep_id, USB_CTR_RX);
		goto again;
	}

	cnt = MIN(rx_pktbuf->count, len);
 47a:	bf38      	it	cc
 47c:	f3c0 0009 	ubfxcc	r0, r0, #0, #10
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* copy data to destination buffer */
	src = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (rx->addr / 2);
 480:	009b      	lsls	r3, r3, #2
 482:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
	for (i = 0; i < (cnt + 1) / 2; i++) {
 486:	1c42      	adds	r2, r0, #1
	uint8_t * dst = (uint8_t *)ptr;
	uint32_t data;
	int i;

	/* copy data to destination buffer */
	src = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (rx->addr / 2);
 488:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
	for (i = 0; i < (cnt + 1) / 2; i++) {
 48c:	0852      	lsrs	r2, r2, #1
 48e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 492:	4293      	cmp	r3, r2
 494:	f101 0102 	add.w	r1, r1, #2
 498:	d007      	beq.n	4aa <usb_recv+0xa2>
		data = *src++;
 49a:	f853 5b04 	ldr.w	r5, [r3], #4
		*dst++ = data;
 49e:	f801 5c02 	strb.w	r5, [r1, #-2]
		*dst++ = data >> 8;
 4a2:	0a2d      	lsrs	r5, r5, #8
 4a4:	f801 5c01 	strb.w	r5, [r1, #-1]
 4a8:	e7f3      	b.n	492 <usb_recv+0x8a>

	cnt = MIN(rx_pktbuf->count, len);

	/* Data received */
	__copy_from_pktbuf(buf, rx_pktbuf, cnt);
	rx_pktbuf->count = 0;
 4aa:	6863      	ldr	r3, [r4, #4]
 4ac:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 4b0:	f023 0303 	bic.w	r3, r3, #3
 4b4:	6063      	str	r3, [r4, #4]
}

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 4b6:	6832      	ldr	r2, [r6, #0]

	if (epr & USB_EP_DBL_BUF) {
 4b8:	b12f      	cbz	r7, 4c6 <usb_recv+0xbe>
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 4ba:	f648 738f 	movw	r3, #36751	; 0x8f8f
 4be:	4013      	ands	r3, r2
 4c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 4c4:	e004      	b.n	4d0 <usb_recv+0xc8>
};

static inline void __set_ep_rxstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPRX_DTOGMASK;
 4c6:	f64b 738f 	movw	r3, #49039	; 0xbf8f
 4ca:	4013      	ands	r3, r2
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_RX_MSK);
 4cc:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 4d0:	6033      	str	r3, [r6, #0]
 4d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	}
	if (rx_pktbuf->count == 0) {
		while (!(epr & USB_CTR_RX)) {
			if (systick->csr & SYSTICK_CSR_COUNTFLAG) {
				if (msec == 0)
					return -1;
 4d4:	f04f 30ff 	mov.w	r0, #4294967295
		/* free the out(rx) packet buffer */
		__set_ep_rxstat(usb, ep_id, USB_RX_VALID);
	}

	return cnt;
}
 4d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 4da:	bf00      	nop
 4dc:	e000e010 	.word	0xe000e010

000004e0 <usb_send>:

/* start sending */
int usb_send(int ep_id, void * buf, unsigned int len)
{
 4e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4e4:	468e      	mov	lr, r1

	

	epr = usb->epr[ep_id];
	ptr = (uint8_t *)buf;
	rem = len;
 4e6:	4611      	mov	r1, r2
 4e8:	0083      	lsls	r3, r0, #2
 4ea:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 4ee:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00

	while (rem > 0) {
		if (epr & USB_EP_DBL_BUF) {
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
 4f2:	0100      	lsls	r0, r0, #4
 4f4:	f100 4580 	add.w	r5, r0, #1073741824	; 0x40000000
	uint8_t * ptr; /* Pointer to the next transfer */
	unsigned int pktsz = 0;

	

	epr = usb->epr[ep_id];
 4f8:	681c      	ldr	r4, [r3, #0]
	rem = len;

	while (rem > 0) {
		if (epr & USB_EP_DBL_BUF) {
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
 4fa:	f505 45c0 	add.w	r5, r5, #24576	; 0x6000
	struct stm32f_usb * usb = STM32F_USB;
	uint32_t epr;
	unsigned int mxpktsz = 64; /* Maximum packet size for this EP */
	unsigned int rem; /* Bytes pendig in the transfer buffer */
	uint8_t * ptr; /* Pointer to the next transfer */
	unsigned int pktsz = 0;
 4fe:	2700      	movs	r7, #0
 500:	f404 7080 	and.w	r0, r4, #256	; 0x100

	epr = usb->epr[ep_id];
	ptr = (uint8_t *)buf;
	rem = len;

	while (rem > 0) {
 504:	2900      	cmp	r1, #0
 506:	d042      	beq.n	58e <usb_send+0xae>
		if (epr & USB_EP_DBL_BUF) {
 508:	b120      	cbz	r0, 514 <usb_send+0x34>
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
 50a:	f3c4 3480 	ubfx	r4, r4, #14, #1
 50e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 512:	e000      	b.n	516 <usb_send+0x36>
		} else {
			tx_pktbuf = &pktbuf[ep_id].tx;
 514:	462c      	mov	r4, r5
		}
		pktsz = MIN(rem, mxpktsz);
 516:	460f      	mov	r7, r1
 518:	46f0      	mov	r8, lr
{
	uint32_t * dst;
	int i;

	/* copy data to destination buffer */
	dst = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (tx->addr / 2);
 51a:	6826      	ldr	r6, [r4, #0]
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
		} else {
			tx_pktbuf = &pktbuf[ep_id].tx;
		}
		pktsz = MIN(rem, mxpktsz);
 51c:	2940      	cmp	r1, #64	; 0x40
{
	uint32_t * dst;
	int i;

	/* copy data to destination buffer */
	dst = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (tx->addr / 2);
 51e:	ea4f 0656 	mov.w	r6, r6, lsr #1
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
		} else {
			tx_pktbuf = &pktbuf[ep_id].tx;
		}
		pktsz = MIN(rem, mxpktsz);
 522:	bf28      	it	cs
 524:	2740      	movcs	r7, #64	; 0x40
{
	uint32_t * dst;
	int i;

	/* copy data to destination buffer */
	dst = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (tx->addr / 2);
 526:	00b6      	lsls	r6, r6, #2
 528:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
	for (i = 0; i < ((len + 1) / 2); i++) {
 52c:	f107 0901 	add.w	r9, r7, #1
{
	uint32_t * dst;
	int i;

	/* copy data to destination buffer */
	dst = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (tx->addr / 2);
 530:	f506 46c0 	add.w	r6, r6, #24576	; 0x6000
	for (i = 0; i < ((len + 1) / 2); i++) {
 534:	ea4f 0969 	mov.w	r9, r9, asr #1
 538:	f04f 0c00 	mov.w	ip, #0
 53c:	45cc      	cmp	ip, r9
 53e:	f108 0802 	add.w	r8, r8, #2
 542:	d00a      	beq.n	55a <usb_send+0x7a>
		*dst++ = src[0] | (src[1] << 8);
 544:	f818 bc01 	ldrb.w	fp, [r8, #-1]
 548:	f818 ac02 	ldrb.w	sl, [r8, #-2]
 54c:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
 550:	f846 a02c 	str.w	sl, [r6, ip, lsl #2]
	uint32_t * dst;
	int i;

	/* copy data to destination buffer */
	dst = (uint32_t *)STM32F_USB_PKTBUF_ADDR + (tx->addr / 2);
	for (i = 0; i < ((len + 1) / 2); i++) {
 554:	f10c 0c01 	add.w	ip, ip, #1
 558:	e7f0      	b.n	53c <usb_send+0x5c>
		*dst++ = src[0] | (src[1] << 8);
		src += 2;
	}

	tx->count = len;
 55a:	6067      	str	r7, [r4, #4]
		} else {
			tx_pktbuf = &pktbuf[ep_id].tx;
		}
		pktsz = MIN(rem, mxpktsz);
		__copy_to_pktbuf(tx_pktbuf, ptr, pktsz);
		rem -= pktsz;
 55c:	1bc9      	subs	r1, r1, r7
		ptr += pktsz;
 55e:	44be      	add	lr, r7
}

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 560:	681c      	ldr	r4, [r3, #0]

		if (epr & USB_EP_DBL_BUF) {
 562:	b128      	cbz	r0, 570 <usb_send+0x90>
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 564:	f648 708f 	movw	r0, #36751	; 0x8f8f
 568:	4020      	ands	r0, r4
 56a:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 56e:	e004      	b.n	57a <usb_send+0x9a>
#define EPRX_DTOGMASK  (USB_STAT_RX_MSK | USB_EPREG_MASK)

static inline void __set_ep_txstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPTX_DTOGMASK;
 570:	f648 70bf 	movw	r0, #36799	; 0x8fbf
 574:	4020      	ands	r0, r4
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_TX_MSK);
 576:	f080 0030 	eor.w	r0, r0, #48	; 0x30
 57a:	6018      	str	r0, [r3, #0]
			__toggle_ep_flag(usb, ep_id, USB_SWBUF_TX);
		} else {
			__set_ep_txstat(usb, ep_id, USB_TX_VALID);
		}

		while (!((epr = usb->epr[ep_id]) & USB_CTR_TX)) {
 57c:	681c      	ldr	r4, [r3, #0]
 57e:	0620      	lsls	r0, r4, #24
 580:	d5fc      	bpl.n	57c <usb_send+0x9c>

static inline void __clr_ep_flag(struct stm32f_usb * usb, 
							   int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
	usb->epr[ep_id] = (epr & ~flag) & USB_EPREG_MASK;
 582:	f648 700f 	movw	r0, #36623	; 0x8f0f


static inline void __clr_ep_flag(struct stm32f_usb * usb, 
							   int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 586:	681e      	ldr	r6, [r3, #0]
	usb->epr[ep_id] = (epr & ~flag) & USB_EPREG_MASK;
 588:	4030      	ands	r0, r6
 58a:	6018      	str	r0, [r3, #0]
 58c:	e7b8      	b.n	500 <usb_send+0x20>

		/* IN */
		__clr_ep_flag(usb, ep_id, USB_CTR_TX);
	}

	if (pktsz == mxpktsz) {
 58e:	2f40      	cmp	r7, #64	; 0x40
 590:	d115      	bne.n	5be <usb_send+0xde>
		if (epr & USB_EP_DBL_BUF) {
 592:	b160      	cbz	r0, 5ae <usb_send+0xce>
			/* select the descriptor according to the data toggle bit */
			tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
 594:	f3c4 3480 	ubfx	r4, r4, #14, #1
			tx_pktbuf->count = 0;
 598:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 59c:	6061      	str	r1, [r4, #4]

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 59e:	f648 718f 	movw	r1, #36751	; 0x8f8f
}

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 5a2:	681c      	ldr	r4, [r3, #0]
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 5a4:	4021      	ands	r1, r4
 5a6:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 5aa:	6019      	str	r1, [r3, #0]
 5ac:	e007      	b.n	5be <usb_send+0xde>
#define EPRX_DTOGMASK  (USB_STAT_RX_MSK | USB_EPREG_MASK)

static inline void __set_ep_txstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPTX_DTOGMASK;
 5ae:	f648 71bf 	movw	r1, #36799	; 0x8fbf
 5b2:	6818      	ldr	r0, [r3, #0]
 5b4:	4001      	ands	r1, r0
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_TX_MSK);
 5b6:	f081 0120 	eor.w	r1, r1, #32
 5ba:	6019      	str	r1, [r3, #0]
 5bc:	e000      	b.n	5c0 <usb_send+0xe0>
		} else {
			__set_ep_txstat(usb, ep_id, USB_TX_NAK);
		}
	}	

	if (!(epr & USB_EP_DBL_BUF)) {
 5be:	b930      	cbnz	r0, 5ce <usb_send+0xee>
#define EPRX_DTOGMASK  (USB_STAT_RX_MSK | USB_EPREG_MASK)

static inline void __set_ep_txstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPTX_DTOGMASK;
 5c0:	f648 71bf 	movw	r1, #36799	; 0x8fbf
 5c4:	6818      	ldr	r0, [r3, #0]
 5c6:	4001      	ands	r1, r0
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_TX_MSK);
 5c8:	f081 0120 	eor.w	r1, r1, #32
 5cc:	6019      	str	r1, [r3, #0]
		__set_ep_txstat(usb, ep_id, USB_TX_NAK);
	}

	return len;
}
 5ce:	4610      	mov	r0, r2
 5d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000005d4 <usb_drain>:

void usb_drain(int ep_id)
{
 5d4:	0083      	lsls	r3, r0, #2
 5d6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 5da:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
	struct stm32f_usb_pktbuf * pktbuf = STM32F_USB_PKTBUF;
	struct stm32f_usb_tx_pktbuf * tx_pktbuf;
	struct stm32f_usb * usb = STM32F_USB;
	uint32_t epr;

	epr = usb->epr[ep_id];
 5de:	681a      	ldr	r2, [r3, #0]
 5e0:	0100      	lsls	r0, r0, #4

	if (epr & USB_EP_DBL_BUF) {
		/* select the descriptor according to the data toggle bit */
		tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
		tx_pktbuf->count = 0;
 5e2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
	struct stm32f_usb * usb = STM32F_USB;
	uint32_t epr;

	epr = usb->epr[ep_id];

	if (epr & USB_EP_DBL_BUF) {
 5e6:	f412 7180 	ands.w	r1, r2, #256	; 0x100
		/* select the descriptor according to the data toggle bit */
		tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
		tx_pktbuf->count = 0;
 5ea:	f500 40c0 	add.w	r0, r0, #24576	; 0x6000
	struct stm32f_usb * usb = STM32F_USB;
	uint32_t epr;

	epr = usb->epr[ep_id];

	if (epr & USB_EP_DBL_BUF) {
 5ee:	d00c      	beq.n	60a <usb_drain+0x36>
		/* select the descriptor according to the data toggle bit */
		tx_pktbuf = &pktbuf[ep_id].dbtx[(epr & USB_SWBUF_TX) ? 1: 0];
 5f0:	f3c2 3280 	ubfx	r2, r2, #14, #1
		tx_pktbuf->count = 0;
 5f4:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 5f8:	2200      	movs	r2, #0
 5fa:	6042      	str	r2, [r0, #4]

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 5fc:	f648 728f 	movw	r2, #36751	; 0x8f8f
}

static inline void __toggle_ep_flag(struct stm32f_usb * usb, 
									int ep_id, uint32_t flag) {
	uint32_t epr;
	epr = usb->epr[ep_id];
 600:	6819      	ldr	r1, [r3, #0]
	usb->epr[ep_id] = (epr & USB_EPREG_MASK) | flag;
 602:	400a      	ands	r2, r1
 604:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 608:	e006      	b.n	618 <usb_drain+0x44>
#define EPRX_DTOGMASK  (USB_STAT_RX_MSK | USB_EPREG_MASK)

static inline void __set_ep_txstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPTX_DTOGMASK;
 60a:	f648 72bf 	movw	r2, #36799	; 0x8fbf
		__toggle_ep_flag(usb, ep_id, USB_SWBUF_TX);
	} else {
		tx_pktbuf = &pktbuf[ep_id].tx;
		tx_pktbuf->count = 0;
 60e:	6041      	str	r1, [r0, #4]
 610:	6819      	ldr	r1, [r3, #0]
 612:	400a      	ands	r2, r1
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_TX_MSK);
 614:	f082 0230 	eor.w	r2, r2, #48	; 0x30
 618:	601a      	str	r2, [r3, #0]
		__set_ep_txstat(usb, ep_id, USB_TX_VALID);
	}

	while (!((epr = usb->epr[ep_id]) & USB_CTR_TX)) {
 61a:	681a      	ldr	r2, [r3, #0]
 61c:	0611      	lsls	r1, r2, #24
 61e:	d5fc      	bpl.n	61a <usb_drain+0x46>
	}

	if (!(epr & USB_EP_DBL_BUF)) {
 620:	05d2      	lsls	r2, r2, #23
#define EPRX_DTOGMASK  (USB_STAT_RX_MSK | USB_EPREG_MASK)

static inline void __set_ep_txstat(struct stm32f_usb * usb, 
								 unsigned int ep_id, uint32_t stat) {
	uint32_t epr;
	epr = usb->epr[ep_id] & EPTX_DTOGMASK;
 622:	bf5f      	itttt	pl
 624:	f648 72bf 	movwpl	r2, #36799	; 0x8fbf
 628:	6819      	ldrpl	r1, [r3, #0]
 62a:	400a      	andpl	r2, r1
	usb->epr[ep_id] = epr ^ (stat & USB_STAT_TX_MSK);
 62c:	f082 0220 	eorpl.w	r2, r2, #32
 630:	bf58      	it	pl
 632:	601a      	strpl	r2, [r3, #0]
 634:	4770      	bx	lr
 636:	0a0d      	.short	0x0a0d
 638:	656e6f44 	.word	0x656e6f44
 63c:	000a0d2e 	.word	0x000a0d2e

00000640 <s_xmodem>:
 640:	6d590a0d 6d65646f 585e2820 206f7420     ..Ymodem (^X to 
 650:	636e6163 2e296c65 00202e2e              cancel)... .
